<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Charles抓包HTTP、HTTPS</title>
    <url>/2019/02/14/Charles%E6%8A%93%E5%8C%85HTTP%E3%80%81HTTPS/</url>
    <content><![CDATA[<p>抓包分析数据在移动开发中十分重要，可以帮助我们更快的了解数据构成，提高开发效率。但是在苹果要求上线的App必须使用HTTS之后，HTTPS数据包的抓取分析较为麻烦，在此总结了在mac上使用Charles抓包的详细步骤。</p>
<span id="more"></span>

<p>首先我们下载最先版本的Charles<br>官网下载：<a href="https://www.charlesproxy.com/download/">https://www.charlesproxy.com/download/</a><br>免费版下载：<a href="http://xclient.info/search/s/charles/">http://xclient.info/search/s/charles/</a></p>
<h1 id="一、开启网络请求记录，设置系统网络代理"><a href="#一、开启网络请求记录，设置系统网络代理" class="headerlink" title="一、开启网络请求记录，设置系统网络代理"></a>一、开启网络请求记录，设置系统网络代理</h1><p>安装Charles之后，我们选择Proxy-&gt;Start Recording，开始记录网络请求，然后勾选MacOS Proxy(和其他的代理对象如：Mozilla Firefox Proxy火狐浏览器）,将系统代理设置通过Charles Proxy。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-1e102569baeb07af?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p>
<p>此时打开系统偏好设置-&gt;网络-&gt;高级，我们可以看到本机HTTP和HTTPS请求被代理到127.0.0.1，端口号是8888。至此，我们已经完成了基本的网路请求设置，通过此Mac发起的HTTP请求，我们都可以通过Charles分析。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-33e1d1bfc220ab1b?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p>
<p>注：在Charles关闭的时候，这里的web代理和安全web代理也会变成无勾选状态。保证无代理时，Mac也能够访问网络。</p>
<h1 id="二、iPhone数据包的抓取"><a href="#二、iPhone数据包的抓取" class="headerlink" title="二、iPhone数据包的抓取"></a>二、iPhone数据包的抓取</h1><h2 id="1-打开Charles的代理功能"><a href="#1-打开Charles的代理功能" class="headerlink" title="1.打开Charles的代理功能"></a>1.打开Charles的代理功能</h2><p>为了使用Charles抓取到iPhone设备的数据包，我们首先要打开Charles的代理功能。选择Proxy -&gt;Proxy Setting，设置Port:8888，选择Enable TransParent HTTP Proxying。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-6c21a8f2c7faee79?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p>
<h2 id="2-获取本机电脑IP"><a href="#2-获取本机电脑IP" class="headerlink" title="2.获取本机电脑IP"></a>2.获取本机电脑IP</h2><p>接下来我们要将手机的网络代理IP设置为Charles运行所在的电脑IP，获取本机电脑的IP方法如下：<br>方法一：Mac电脑上使用Control +空格键，并输入Terminal 可以进入控制台，然后键入 ifconfig en0命令 ，我们查看到当前电脑的IP地址。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-f4824f4de52c2055?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p>
<p>方法二：通过Charles查看本机的IP地址：打开Charles -&gt;Help-&gt;Local IP Address</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-0ee7a9fb94f18a45?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p>
<h2 id="3-设置手机网络代理IP"><a href="#3-设置手机网络代理IP" class="headerlink" title="3. 设置手机网络代理IP"></a>3. 设置手机网络代理IP</h2><p>我们依次打开iphone “设置-&gt;无线局域网”，点击当前连接Wifi右侧的详情按钮。这里显示了当前连接Wifi的基本信息，我们需要将这里底部的HTTP代理改为手动，然后填上Charles运行所在电脑的IP和端口号8888。如图：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-f783e5356c3885f6?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p>
<p>此时，iPhone的网络代理就设置完成了，手机上请求将会被代理到mac上，我们可以很方便的通过Charles查看到手机应用发起的网络请求数据包。</p>
<h1 id="三、抓取HTTPS数据包"><a href="#三、抓取HTTPS数据包" class="headerlink" title="三、抓取HTTPS数据包"></a>三、抓取HTTPS数据包</h1><p>相对于HTTP类的网络请求，HTTPS请求更加安全，这也使得抓取这类的数据包进行分析要麻烦一些。抓取HTTPS请求数据包进行分析，关键的步骤如下：</p>
<h2 id="1-安装Charles根证书"><a href="#1-安装Charles根证书" class="headerlink" title="1.安装Charles根证书"></a>1.安装Charles根证书</h2><p>打开charles,依次点击Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate，安装根证书</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-04d82ed6515f81b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p>
<h2 id="2-设置证书信任"><a href="#2-设置证书信任" class="headerlink" title="2.设置证书信任"></a>2.设置证书信任</h2><p>在安装证书之后，我们查看钥匙串。选择所有项目，我们会看到一个带有红叉标记不被信任的Charles证书。Charles证书默认是不信任的，需要我们手动设置。右键-&gt;显示简介-&gt;点击信任，我们如图设置始终信任。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-b4a018da38edecc0?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p>
<h2 id="3-设置-SSL-代理"><a href="#3-设置-SSL-代理" class="headerlink" title="3.设置 SSL 代理"></a>3.设置 SSL 代理</h2><p>打开charles应用，选择Proxy-&gt;SSL Proxying Settings,我们在这里设置SSL Proxy,点击面板上的add，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-e3955f415befd14d?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述">在这里我们设置主机地址Host是*,使用通配符表示检测所有网络请求。然后设置端口号是443</p>
<h2 id="4-iOS设备安装证书"><a href="#4-iOS设备安装证书" class="headerlink" title="4.iOS设备安装证书"></a>4.iOS设备安装证书</h2><p>最后我们还需要在iOS设备上安装证书。点击 Charles 的顶部菜单，选择 Help –&gt; SSL Proxying–&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser，然后就可以看到 Charles 显示如下弹窗：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-b99d87289ffa281f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="屏幕快照 2017-01-09 下午2.18.11.png"></p>
<p>然后我们需要打开safari ,输入网址： <a href="http://charlesproxy.com/getssl%EF%BC%8C">http://charlesproxy.com/getssl，</a><br>这时候会弹出安装证书的界面，我们点击安装证书，如图：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-8bf445a572b2f7e8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"><br>目前为止，我们就完成了Charles抓取HTTPS数据包的所有设置了。查看Charles,我们可以看到数据包的内容了。</p>
<h2 id="5-失败请求的处理"><a href="#5-失败请求的处理" class="headerlink" title="5.失败请求的处理"></a>5.失败请求的处理</h2><p>iOS10.3之后，在上述设置完成之后，所有的https请求都会失败。提示错误：Failure SSLHandshake: Received fatal alert: unknown_ca 和You may need to configure your browser or application to trust the Charles Root Certificate.<br>原因：charles的根证书虽然已经在安装列表中,但在iOS 10.3之后,安装新的自定义证书默认是不受信任的。如果要信任已安装的自定义证书,需要手动打开开关以信任证书。<br>解决：设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy custom root certificate然后信任该证书即可. 模拟器也是这样处理。</p>
<h1 id="四、使用Charles遇到的问题"><a href="#四、使用Charles遇到的问题" class="headerlink" title="四、使用Charles遇到的问题"></a>四、使用Charles遇到的问题</h1><p>我在使用Charles抓包https之后，在使用applicationLoader上传ipa包的时候遇到了下面的问题：<br>Communication error. Please use diagnostic mode to check connectivity. You need to have outbound access to TCP port 443.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-d3fb57a7e92f23ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="屏幕快照 2017-01-11 下午5.14.08.png"></p>
<p>解决：将charles关闭，然后再上传ipa文件。<br>至于原因我也没弄明白，如果哪位朋友知道也可以告诉我一下。</p>
]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
      <tags>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习(2)：环境安装与运行</title>
    <url>/2018/08/02/Python%E5%AD%A6%E4%B9%A002-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<p><code>Python</code>作为一门跨平台语言，能够在不同的操作系统上很好的运行。当前主流计算机的操作系统有<code>Windows</code>，<code>Mac OS</code>，<code>Linux</code>三种，而在不同操作系统上安装<code>Pyhton</code>环境会有些许不同。</p>
<span id="more"></span>

<h4 id="一、选择Python版本"><a href="#一、选择Python版本" class="headerlink" title="一、选择Python版本"></a>一、选择Python版本</h4><p><code>Python</code>目前有两个版本，一个是<code>2.x</code>版本，一个是<code>3.x</code>版本，两个版本互不兼容。但由于<code>3.x</code>版本越来越流行，所以我们都应该选择<code>3.x</code>版本进行安装。</p>
<h4 id="二、Windows安装Python"><a href="#二、Windows安装Python" class="headerlink" title="二、Windows安装Python"></a>二、Windows安装Python</h4><p><code>Windows</code>操作系统并没有内置<code>Python</code>环境，需要独立安装。</p>
<h5 id="1-下载Python"><a href="#1-下载Python" class="headerlink" title="1.下载Python"></a>1.下载Python</h5><p>进入<a href="https://www.python.org/">Python官网</a>，选择<code>Downloads</code>-&gt;<code>Windows</code>-&gt;选择<code>Python</code>版本下载</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/python_install_version.png" >

<p><strong>选择系统版本</strong>:<br><code>x86-64</code>(简称<code>x64</code>)支持<code>64</code>位系统安装，<code>x84</code>支持<code>32</code>位系统安装</p>
<p><strong>选择安装方式</strong>:</p>
<ol>
<li><code>web-based</code>: 通过网络安裝，下载的文件很小，点击运行会从网络下载安装<code>Python</code>;</li>
<li><code>executable</code>: 下载后得到完整的<code>Python</code>，在本机安装；</li>
<li><code>embeddable zip file</code>: 下载得到打包成<code>zip</code>的<code>Python</code></li>
</ol>
<h5 id="2-安装Python-exe"><a href="#2-安装Python-exe" class="headerlink" title="2.安装Python.exe"></a>2.安装Python.exe</h5><p>运行下载的<code>Python.exe</code>，勾选<code>Add Python to PATH</code>(添加后可以在<code>window</code>的命令行下运行<code>Python</code>)，然后选择<code>Customize Installation</code>，按照提示即可完成<code>Python</code>的安装。<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/python_install_exe.png" ></p>
<h4 id="三、Mac-OS与Linux安装Python"><a href="#三、Mac-OS与Linux安装Python" class="headerlink" title="三、Mac OS与Linux安装Python"></a>三、Mac OS与Linux安装Python</h4><p>这两种系统其实已经替我们安装好了<code>Python</code>，而无需像<code>Windows</code>那样的下载安装，而且系统中提供两种<code>Python</code>的版本；</p>
<ol>
<li>终端中输入<code>Python</code>：进入低版本<code>Python</code>环境；</li>
<li>终端中输入<code>Python3</code>：进入新版本<code>Python3</code>环境；</li>
<li>如果想在终端关闭<code>Python</code>环境，使用<code>contrl + d</code>命令</li>
</ol>
<h4 id="四、Python的三种运行方式"><a href="#四、Python的三种运行方式" class="headerlink" title="四、Python的三种运行方式"></a>四、Python的三种运行方式</h4><h5 id="1-使用自带的交互式解释器：REPL-Read、Eval、Print、Loop-运行环境"><a href="#1-使用自带的交互式解释器：REPL-Read、Eval、Print、Loop-运行环境" class="headerlink" title="1.使用自带的交互式解释器：REPL(Read、Eval、Print、Loop)运行环境"></a>1.使用自带的交互式解释器：REPL(Read、Eval、Print、Loop)运行环境</h5><p>在安装了<code>Python</code>环境之后，可以直接在<code>Python</code>自带的交互式解释器中编写和运行<code>Python</code>代码。</p>
<p>步骤1：进入<code>Python</code>运行环境<br><code>Windows</code>系统需要搜索<code>IDLE</code>或者在<code>windows</code>终端界面中输入<code>python</code>，进入<code>python</code>的编译运行环境，而<code>Linux</code>和<code>Mac OS</code>系统：使用<code>terminal</code>命令进入终端，并输入<code>python</code>或者<code>python3</code>命令进入<code>Python</code>环境。</p>
<p><code>步骤2：编写和运行</code>Python<code>，以</code>Mac<code>为例 在</code>Mac<code>上的</code>Python<code>环境中编写代码如：</code>print(“Hello World”)&#96;，按下回车即可执行代码，效果图如下：</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/python_run_repl.png" >

<h5 id="2-命令行执行Python脚本"><a href="#2-命令行执行Python脚本" class="headerlink" title="2.命令行执行Python脚本"></a>2.命令行执行Python脚本</h5><p>步骤1：创建脚本文件</p>
<p>使用任意的文本编辑器，写入Python代码如：print(“Hello World”)，并将文件保存为demo.py，注意后缀一定要是py。</p>
<p>步骤2：系统终端中执行脚本文件</p>
<p><code>Windows</code>系统中的<code>Python</code>环境是我们下载的指定版本的，所以可以直接进入终端中执行命令：<code>“python + 文件名.py”</code>。而对于<code>Linux</code>和<code>Mac OS</code>系统，有两种不同的执行方式。</p>
<ol>
<li>使用低版本<code>Python</code>运行脚本文件：<code>python + 文件名.py</code></li>
<li>使用新版本<code>Python</code>运行脚本文件：<code>python3 + 文件名.py</code></li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/python_run_demopy.png" >

<p>需要注意：</p>
<ol>
<li>一定要在<code>python</code>脚本的当前目录下操作。</li>
<li>另外，在系统终端关于<code>python</code>的其他命令如下：</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/python_run_cmd.png" >

<h5 id="3-集成开发环境Pycharm"><a href="#3-集成开发环境Pycharm" class="headerlink" title="3.集成开发环境Pycharm"></a>3.集成开发环境Pycharm</h5><p><code>PyCharm</code> 是由 <code>JetBrains</code> 打造的一款 <code>Python IDE</code>，支持 <code>macOS</code>、 <code>Windows</code>、 <code>Linux</code> 系统。</p>
<p><code>PyCharm</code> 功能 : 调试、语法高亮、<code>Project</code>管理、代码跳转、智能提示、自动完成、单元测试、版本控制……</p>
<ol>
<li><a href="https://www.jetbrains.com/pycharm/download/">PyCharm官方下载地址</a></li>
<li><a href="http://xclient.info/s/pycharm.html?t=680034e137bc7cc9b41bad81241e03e932425016#versions">PyCharm破解下载地址</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习(1)：入门与导学</title>
    <url>/2018/08/01/Python%E5%AD%A6%E4%B9%A001-%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AF%BC%E5%AD%A6/</url>
    <content><![CDATA[<p><strong>Life is simple ,I use Python.</strong></p>
<p>代码：代码是现实世界事物在计算机世界中的映射<br>编程：将现实世界中事物用计算机语言来描述</p>
<span id="more"></span>

<p>最近在网上找了一些资料在学习<code>Python</code>，就想把每次的学习内容记录下来，这也是为了避免新学的东西容易遗忘。自己选择<code>Python</code>只有一个原因，那就是兴趣。作为一个<code>iOS</code>开发者，我也很好奇，传说中无所不能的<code>Python</code>到底是怎样的一种语言，使用<code>Python</code>是否也能做出一些有意思的事情，比如爬虫、机器学习等。下面的系列文章就是我的<code>Python</code>学习之旅。</p>
<h4 id="一、了解Python"><a href="#一、了解Python" class="headerlink" title="一、了解Python"></a>一、了解Python</h4><p><code>Python</code>并不是一门新兴的语言，反而是诞生于上世纪90年代初的语言。 随着大数据与人工智能的流行，<code>Python</code>逐步的流行起来。<code>Python</code>就像一个技术的润滑剂，大多数互联网公司或多或少都会用到，可以在开发中解决大大小小的很多问题。根据<code>TIOBE</code>语言排行，<code>Python</code>的语言排行为第四位，热度上升很快，其流行程度可见一斑。</p>
<p>说明：本系列文章是本人的<code>Python</code>学习记录，在<code>1-9</code>篇都是在<code>Python</code>自带的解释器<code>IDLE</code>中编写和运行代码。在实际开发中专业的开发工具使用<code>Pycharm</code>，而做一些轻量化的开发使用的是<code>Sublime text3</code>或者<code>Visual Studio Code</code></p>
<h4 id="二、Python能做些什么"><a href="#二、Python能做些什么" class="headerlink" title="二、Python能做些什么"></a>二、Python能做些什么</h4><p><code>Pyhotn</code>几乎是万能的，相对于其他语言可以做的事情很多:</p>
<ol>
<li>爬虫 </li>
<li>大数据与数据分析(<code>Spark</code>)</li>
<li>自动化运维与自动化测试</li>
<li><code>Web</code>开发：<code>Flask</code>，<code>Diango</code></li>
<li>机器学习：Tensor<code> </code>Flow</li>
<li>胶水语言：混合其他如<code>C++</code>、<code>Java</code>等来编程。能够把用其他语言制作的各种模块(尤其是<code>C/C++</code>)很轻松的结合在一起。</li>
</ol>
<h4 id="三、Pthon特点"><a href="#三、Pthon特点" class="headerlink" title="三、Pthon特点"></a>三、Pthon特点</h4><ol>
<li><code>Python</code>语法简洁，灵活，优雅，哲学，编写程序容易阅读;</li>
<li><code>Python</code>支持跨平台，可以运行在<code>Windows</code>、<code>Linux</code>以及<code>MacOS</code>;</li>
<li><code>Python</code>是面向对象的动态语言，既有动态脚本的特性，又有面向对象的特性，非常具有自己的特点;</li>
<li><code>Python</code>拥有极为强大而丰富的标准库与第三方库，比如电子邮件，比如图形<code>GUI</code>界面;</li>
<li><code>Python</code>易于上手，难于精通;</li>
<li><code>Python</code>的语言靠缩进区分代码块，不强制每句代码添加分号；也不需要花括号确定作用域;</li>
<li><code>Python</code>依靠缩进区分作用域，因此不支持代码压缩，常常以源代码形式的存在，开源性较好;</li>
</ol>
<h4 id="四、Python的缺点"><a href="#四、Python的缺点" class="headerlink" title="四、Python的缺点"></a>四、Python的缺点</h4><h5 id="1-运行效率低"><a href="#1-运行效率低" class="headerlink" title="1.运行效率低"></a>1.运行效率低</h5><p><code>Python</code>主要缺点就是一个字：慢，其相对于<code>C</code>、<code>C++</code>、<code>Java</code>运行效率较慢。</p>
<p>这主要是因为<code>Pyhton</code>是一种解释性语言，对于当前主流的编程语言大致可分为两类：编译型语言(<code>C</code>、<code>C++</code>)和解释型语言(<code>Javascript</code>、<code>Python</code>)。</p>
<p><strong>编译型语言</strong>：<br>程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如<code>C</code>、<code>C++</code>、<code>Delphi</code>等. [1] </p>
<p><strong>解释型语言</strong>：<br>解释性语言编写的程序不进行预先编译，以文本方式存储程序代码。在发布程序时，看起来省了道编译工序。但是，在运行程序的时候，解释性语言必须先解释再运行</p>
<p> 运行效率与开发效率，鱼与熊掌不可兼得。类似汇编和C的运行效率很高，但是却不适合做web开发。对于语言的选择，适合的才是最好的。</p>
<h5 id="2-不能加密"><a href="#2-不能加密" class="headerlink" title="2.不能加密"></a>2.不能加密</h5><p><code>python</code>依靠缩进来编写代码，代码不能被压缩和混淆，所以这也注定了<code>Python</code>代码不能被加密的特性。</p>
<h4 id="五、Python之禅"><a href="#五、Python之禅" class="headerlink" title="五、Python之禅"></a>五、Python之禅</h4><p><code>Python</code>的交互式编译器内嵌了几句话(输入<code>import this</code>)，被开发者称之为<code>Pyhon</code>之禅，包含了<code>Python</code>编程的一种大致思想和规范。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Simple <span class="keyword">is</span> better than <span class="built_in">complex</span></span><br><span class="line">简洁胜于复杂</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>Now <span class="keyword">is</span> better than never ，Although never <span class="keyword">is</span> often  better than right now</span><br><span class="line">做也许好过不做，但不加思索就动手还不如不做</span><br></pre></td></tr></table></figure>


<h4 id="六、Python学习的相关资料"><a href="#六、Python学习的相关资料" class="headerlink" title="六、Python学习的相关资料"></a>六、Python学习的相关资料</h4><ol>
<li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">廖雪峰Python3的官方网站</a></li>
<li><a href="http://www.runoob.com/python/python-tutorial.html">Python基本教程</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习03-理解计算机中的编码</title>
    <url>/2018/08/03/Python%E5%AD%A6%E4%B9%A003-%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>我们学习<code>Python</code>编程，经常对字符串这样的数据进行处理。我们也都知道计算机内部信息是采用二进制编码的，那么这其中的处理原理是什么呢？本篇就计算机中关于编码的知识进行总结。</p>
<span id="more"></span>

<h4 id="一、为什么计算机内部信息采用二进制编码"><a href="#一、为什么计算机内部信息采用二进制编码" class="headerlink" title="一、为什么计算机内部信息采用二进制编码"></a>一、为什么计算机内部信息采用二进制编码</h4><p>计算机是由逻辑电路组成的，而逻辑电路只有<code>接通</code>与<code>断开</code>两个状态，正好可以对映二进制的<code>“1”</code>与<code>“0”</code>。这样的计算机设计在技术上会简单许多。</p>
<h4 id="二、计算机编码的由来"><a href="#二、计算机编码的由来" class="headerlink" title="二、计算机编码的由来"></a>二、计算机编码的由来</h4><p>计算机内部信息采用二进制编码，这决定了它只能直接识别<code>0</code>和<code>1</code>。我们所有各类型数据也都需要被转换为二进制<code>0</code>和<code>1</code>的序列存放在计算机中的。但是这样就产生了问题，对于一个很长的二进制序列，我们很难理解它的含义。</p>
<p>因此，我们可以规定每个字符的二进制序列，并把它存在计算机内，当需要将二进制位转换成我们能看懂的字符数据时，让计算机去截取二进制位查找对应的表，翻译成我们看的懂的数据。这种规定字符的二进制序列的做法就是一种<code>编码</code>行为，让计算机翻译就是一种<code>解码</code>行为。 </p>
<p>这样，也就产生了各种我们常见的计算机编码，如：<code>ASCll</code>编码、<code>UTF-8</code>编码、<code>Unicode</code>编码等。</p>
<h4 id="三、认识常见的计算机编码"><a href="#三、认识常见的计算机编码" class="headerlink" title="三、认识常见的计算机编码"></a>三、认识常见的计算机编码</h4><h5 id="1-ASCll编码"><a href="#1-ASCll编码" class="headerlink" title="1.ASCll编码"></a>1.ASCll编码</h5><p>计算机是由美国人发明的，他们设计的<code>ASCll</code>编码是基于罗马字母表的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。英语只有<code>26</code>个英文字母，所以<code>ASCll</code>编码只用<code>8</code>位二进制就表示了所有他们需要的字符。<code>ASCll</code>编码也是现今最通用的单字节编码系统。但是我们的汉字有几万个之多，<code>ASCll</code>编码并不能完全适用，所以后来我们也创造了适合中文的编码方式。</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/python_coding_ascall.png" >

<p>在计算机的存储中，一个<code>ASCII</code>码值占一个字节(<code>8</code>个二进制位)，其最高位(<code>b7</code>)用作奇偶校验位。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。</p>
<ul>
<li>奇校验规定：正确的代码一个字节中<code>1</code>的个数必须是奇数，若非奇数，则在最高位<code>b7</code>添<code>1</code>；</li>
<li>偶校验规定：正确的代码一个字节中<code>1</code>的个数必须是偶数，若非偶数，则在最高位<code>b7</code>添<code>1</code>。</li>
</ul>
<h5 id="2-ISO-8859-1-Windows-1252"><a href="#2-ISO-8859-1-Windows-1252" class="headerlink" title="2.ISO-8859-1&#x2F;Windows-1252"></a>2.ISO-8859-1&#x2F;Windows-1252</h5><p><code>ISO-8859-1</code>编码:<br><code>ASCll</code>编码的一个字节并未用完，后来的欧洲国家为了增加它们经常使用的字符，就在原<code>ASCll</code>编码的基础上扩充进而创造了<code>ISO-8859-1</code>编码，又称西欧语言。</p>
<p><code>Windows-1252</code>编码:<br><code>Windows-1252</code>编码是<code>ISO-8859-1</code>编码的超集，现在的<code>HTML5</code>规范中就要求<code>ISO-8859-1</code> 的文档实际上用 <code>Windows-1252</code> 编码进行分析。</p>
<h5 id="3-GB2312编码-简体中文-与GBK编码"><a href="#3-GB2312编码-简体中文-与GBK编码" class="headerlink" title="3.GB2312编码(简体中文)与GBK编码"></a>3.GB2312编码(简体中文)与GBK编码</h5><p>汉字众多，一个字节长度的编码显然不适合，所以我国在<code>1981</code>年<code>5</code>月<code>1</code>日开始实施的一套国家标准<code>GB2312</code>，适用于汉字处理、汉字通信等系统之间的信息交换。</p>
<p><code>GB2312</code>使用两个字节来表示汉字。小于<code>127</code>的依然表示原来的字符（也就是该字节最高位为<code>0</code>），当计算机遇到两个大于<code>127</code>的字节时候（也就是两个字节的最高位都是<code>1</code>），就一次性读取两个字节，将它解码成一个汉字。</p>
<p><code>GB2312</code>标准共收录<code>6763</code>个汉字，其中一级汉字<code>3755</code>个，二级汉字<code>3008</code>个；同时，<code>GB2312</code>收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的<code>682</code>个全角字符。</p>
<h5 id="4-GBK与GB18030"><a href="#4-GBK与GB18030" class="headerlink" title="4.GBK与GB18030"></a>4.GBK与GB18030</h5><p><code>GB2312</code>的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆<code>99.75%</code>的使用频率。但是对于人名、古汉语等方面出现的罕用字，<code>GB2312</code>不能处理，这导致了后来<code>GBK</code>及<code>GB18030</code>汉字字符集的出现。</p>
<ul>
<li><code>GBK</code>：向下兼容<code>GB2312</code>，增加新的汉字，共收录了<code>21003</code>个汉字。</li>
<li><code>GB18030</code>：再次对<code>GBK</code>的扩充，增加了日韩和少数民族的字符编码。</li>
</ul>
<h5 id="5-Unicode编码"><a href="#5-Unicode编码" class="headerlink" title="5.Unicode编码"></a>5.Unicode编码</h5><p>如果每个国家都按照自己的标准编码字符集，就会对编码不同的两个国家的交流造成很困难。为了统一所有文字的编码，<code>Unicode</code>应运而生。</p>
<p>但是，<code>UNicode</code>仅仅只是一个字符集，就是为每个字符规定一个用来表示该字符的二进制数字，至于这个二进制代码如何存储则没有任何规定。试想，如果按照汉字所需的<code>2</code>到<code>4</code>个字节来编码，那么英文文档的大小也就大出了<code>1</code>到<code>3</code>倍。</p>
<p>为了解决<code>Unicode</code>编码的问题，<code>UTT-8</code>和<code>UTF-16</code>以及<code>UTF-32</code>出现了。</p>
<ul>
<li><code>UTF-8</code>是目前互联网上使用最广泛的一种 <code>Unicode</code> 编码方式，它的最大特点就是可变长。它可以使用 <code>1 - 4 </code>个字节表示一个字符，根据字符的不同变换长度；<br>*<code> UTF-16</code>编码介于 <code>UTF-32</code> 与 <code>UTF-8 </code>之间，同时结合了定长和变长两种编码方法的特点；</li>
</ul>
<h4 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h4><ol>
<li><a href="https://baike.baidu.com/item/ISO-8859-1/7878872">ISO-8859-1编码</a></li>
<li><a href="https://en.wikipedia.org/wiki/Windows-1252">Windows-1252编码</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习04-变量与数据类型</title>
    <url>/2018/08/04/Python%E5%AD%A6%E4%B9%A004-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>学习一门新语言，一切从变量与基本类型说起。<code>Python</code>中的变量使用与其他常见语言有所不同，最大的特点就是<code>Python</code>的变量不需要声明。</p>
<span id="more"></span>

<h4 id="一、Python中变量使用特点"><a href="#一、Python中变量使用特点" class="headerlink" title="一、Python中变量使用特点"></a>一、Python中变量使用特点</h4><ol>
<li>每个变量在使用前都必须赋值，变量赋值后才会被创建。</li>
<li><code>Python</code>中的变量就是变量，它没有类型，我们所说的<code>&quot;类型&quot;</code>是变量所指的内存中对象的类型。</li>
<li>等号(<code>=</code>)用来给变量赋值。</li>
<li>等号(<code>=</code>)运算符左边是一个变量名，等号(<code>=</code>)运算符右边是存储在变量中的值。</li>
<li>变量名的首字母不能是数字，而是字母、数字、下划线的组合;</li>
</ol>
<h4 id="二、Python变量的定义"><a href="#二、Python变量的定义" class="headerlink" title="二、Python变量的定义"></a>二、Python变量的定义</h4><h5 id="1-单个变量的定义"><a href="#1-单个变量的定义" class="headerlink" title="1. 单个变量的定义"></a>1. 单个变量的定义</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;fengzi&quot;</span></span><br><span class="line">age  = <span class="number">18</span></span><br></pre></td></tr></table></figure>
<h5 id="2-多个变量的定义如下："><a href="#2-多个变量的定义如下：" class="headerlink" title="2. 多个变量的定义如下："></a>2. 多个变量的定义如下：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line">a,b,c = <span class="number">1</span>,<span class="number">2</span>, <span class="string">&quot;fengzi&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="三、基本数据类型"><a href="#三、基本数据类型" class="headerlink" title="三、基本数据类型"></a>三、基本数据类型</h4><p>在内存中存储的数据可以有多种类型。例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。<code>Python</code>也定义了一些基本的数据类型，用于存储各种类型的数据，大致可以被归纳为以下几种：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/python_variable_type.png"></p>
<h5 id="1-打印类型"><a href="#1-打印类型" class="headerlink" title="1.打印类型"></a>1.打印类型</h5><p>在<code>Python</code>的解释器中可以使用<code>type</code>函数来打印各种数据类型的值。尤其在学习初期，可以很方便的帮助我们理解各种类型的使用，操作如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/python_variable_print.png"></p>
<h5 id="2-测试可变与不可变"><a href="#2-测试可变与不可变" class="headerlink" title="2.测试可变与不可变"></a>2.测试可变与不可变</h5><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/python_variable_mutable_immutable.png">

<h5 id="四、值类型与引用类型"><a href="#四、值类型与引用类型" class="headerlink" title="四、值类型与引用类型"></a>四、值类型与引用类型</h5><ul>
<li><code>Number</code>、<code>str</code>、<code>tuple</code>是值类型</li>
<li><code>list</code> 、<code>set</code>、 <code>dict</code> 是引用类型</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/python_variable_and_reference.png">]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习05-数据类型(01)-Number</title>
    <url>/2018/08/05/Python%E5%AD%A6%E4%B9%A005-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(01)-Number/</url>
    <content><![CDATA[<p>主要内容：</p>
<ol>
<li><code>Number</code>类型</li>
<li><code>Number</code>的各种运算</li>
<li><code>Number</code>数据类型之间的转换</li>
</ol>
<span id="more"></span>

<h4 id="一、Number类型"><a href="#一、Number类型" class="headerlink" title="一、Number类型"></a>一、Number类型</h4><ol>
<li><code>Python3</code>的<code>Number</code>类型支持 <code>int</code>、<code>float</code>、<code>bool</code>、<code>complex(复数)</code>四种；</li>
<li><code>Python3</code>只有一种整数类型 <code>int</code>，表示为长整型，没有 <code>python2</code> 中的 <code>Long</code>；</li>
<li><code>Number</code>是不可改变的数据类型，这意味着改变数字，数据类型会分配一个新的对象；</li>
</ol>
<h5 id="1-整型"><a href="#1-整型" class="headerlink" title="1.整型"></a>1.整型</h5><p><code>Python3</code>中的整型包括<code>正</code>或<code>负</code>整数;</p>
<p>区别于其他语言的是，其他语言中的整型细分为：短整型(<code>short</code>) 、整型(<code>int</code>)、长整型(<code>long</code>);</p>
<p>不同进制数字表示：</p>
<ul>
<li>表示二进制：数字前加<code>&quot;ob&quot;</code>，比如表示十进制<code>2</code>：<code>&quot;0b10&quot;</code>;</li>
<li>表示八进制：数字前加<code>&quot;0o&quot;</code>，比如表示十进制<code>8</code>：<code>&quot;0o10&quot;</code>;</li>
<li>表示十进制：不需要特殊前缀；</li>
<li>表示十六进制：数字前加<code>&quot;0x&quot;</code>，比如表示十进制<code>31</code>：<code>&quot;0x1F&quot;</code>;</li>
</ul>
<h6 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2.浮点型"></a>2.浮点型</h6><p><code>Python</code>中的浮点型数字由<code>整数部分</code>与<code>小数部分</code>组成;</p>
<p>区别于其他语言的是，其他语言中的浮点型细分为：单精度(<code>float</code>)、双精度(<code>double</code>);</p>
<h5 id="3-复数"><a href="#3-复数" class="headerlink" title="3.复数"></a>3.复数</h5><p>复数由<code>实数部分</code>和<code>虚数部分</code>构成，有一下几种表示方式：</p>
<ol>
<li>可以用<code>a + bj</code>,或者<code>complex(a,b)</code>表示， 复数的实部<code>a</code>和虚部<code>b</code>都是浮点型;</li>
<li>以后缀<code>“j”</code>结尾表示复数，如<code>36j</code>；</li>
</ol>
<h5 id="4-布尔型"><a href="#4-布尔型" class="headerlink" title="4.布尔型"></a>4.布尔型</h5><p>布尔型是<code>Number</code>类型的一种，表示真(<code>True</code>)与假(<code>False</code>)，它可以和整型相互转换。在<code>Python</code>解释器中，测试它的用法：</p>
<ul>
<li>语法：<code>int(True)</code>、<code>int(false)</code>，可以分别转化为数字：<code>1</code>和<code>0</code>;</li>
<li>语法：<code>bool(1)</code>、<code>bool(0)</code>，可以分别转化为布尔型：<code>True</code>和<code>False</code>;</li>
</ul>
<p>注意：但是并只有数字<code>1</code>和<code>0</code>可以表示<code>True</code>和<code>False</code>；对于数字<code>0</code>、<code>空字符串</code>、<code>空数字</code>等空数据对象都可以被转化为<code>False</code>，反之为<code>True</code>;</p>
<h4 id="二、Number的各种运算"><a href="#二、Number的各种运算" class="headerlink" title="二、Number的各种运算"></a>二、Number的各种运算</h4><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/python_basic_number_operation.png">

<h4 id="三、Number数据类型之间的转换"><a href="#三、Number数据类型之间的转换" class="headerlink" title="三、Number数据类型之间的转换"></a>三、Number数据类型之间的转换</h4><table>
<thead>
<tr>
<th>类型转换:</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>int(x)</td>
<td>类型转换：将x转换为整型</td>
</tr>
<tr>
<td>float()</td>
<td>类型转换：将x转换为浮点型</td>
</tr>
<tr>
<td>bool(x)</td>
<td>类型转换：将x转换成一个布尔类型</td>
</tr>
<tr>
<td>complex(x, y)</td>
<td>类型转换：将x和y转换成一个复数，实数部分为x，虚数部分为y</td>
</tr>
<tr>
<td>进制转换:</td>
<td></td>
</tr>
<tr>
<td>bin(number)</td>
<td>进制转换：将number转换为二进制数</td>
</tr>
<tr>
<td>oct(number)</td>
<td>进制转换：将number转换为八进制数</td>
</tr>
<tr>
<td>int(number)</td>
<td>进制转换：将number转换为十进制数</td>
</tr>
<tr>
<td>hex(number)</td>
<td>进制转换：将number转换为十六进制数</td>
</tr>
<tr>
<td>其他操作：</td>
<td></td>
</tr>
<tr>
<td>chr(x)</td>
<td>将一个整数转换为字符</td>
</tr>
<tr>
<td>str(x)</td>
<td>讲一个数字转换为字符串</td>
</tr>
</tbody></table>
<p>注意：在<code>Python</code>解释器中输入各进制数后直接回车，<code>Python</code>也会将其自动转换为十进制；</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习05-数据类型(02)-str</title>
    <url>/2018/08/06/Python%E5%AD%A6%E4%B9%A005-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(02)-str/</url>
    <content><![CDATA[<p>主要内容：</p>
<ol>
<li>引号的使用</li>
<li>多行字符串</li>
<li>转义字符<span id="more"></span></li>
<li>字符串常规操作</li>
</ol>
<h4 id="一、引号的使用"><a href="#一、引号的使用" class="headerlink" title="一、引号的使用"></a>一、引号的使用</h4><p><code>Python</code>中的字符串是由数字、字母、下划线组成的一串字符：</p>
<ol>
<li>表示字符串需要使用用<code>单引号</code>、<code>双引号</code>和<code>三引号</code>；</li>
<li>用于表示字符串的引号必须是成对出现的；</li>
<li>字符串中使用引号，需要使用转义字符<code>&quot;\&quot;</code>；</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;str1&#x27;</span></span><br><span class="line"><span class="string">&#x27;str1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;str2&quot;</span></span><br><span class="line"><span class="string">&#x27;str2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&quot;&quot;str3&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;str3&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;str4\&#x27;str5&quot;</span></span><br><span class="line"><span class="string">&quot;str4&#x27;str5&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>


<h4 id="二、多行字符串"><a href="#二、多行字符串" class="headerlink" title="二、多行字符串"></a>二、多行字符串</h4><p>在<code>Python</code>的解释器中输入多行字符串，并且可以在输入过程中换行，需要在字符串首尾使用三引号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>123</span></span><br><span class="line"><span class="string"><span class="meta">... </span>456</span></span><br><span class="line"><span class="string"><span class="meta">... </span>789</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;\n123\n456\n789\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Life is simple, \nI use Python&quot;</span></span><br><span class="line"><span class="string">&#x27;Life is simple, \nI use Python&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Life is simple, \nI use Python&quot;</span>)</span><br><span class="line">Life <span class="keyword">is</span> simple, </span><br><span class="line">I use Python</span><br></pre></td></tr></table></figure>
<ol>
<li>这里的三引号可以是<code>三个单引号；</code>也可以<code>三个双引号</code>；</li>
<li>输入多行字符串并手动换行，直接打印后，手动换行的操作会被转化为<code>&quot;\n&quot;</code>；</li>
<li>输入字符串中存在换行符<code>&quot;\n&quot;</code>，直接打印后，其中的<code>&quot;\n&quot;</code>不会显示为换行，若要显示换行，还需要使用<code>print</code>函数；</li>
</ol>
<h4 id="三、转义字符"><a href="#三、转义字符" class="headerlink" title="三、转义字符"></a>三、转义字符</h4><p><code>Python</code>使用反斜杠<code>\</code>转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个<code>r</code>，表示原始字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Helllo\nWorld&#x27;</span>)</span><br><span class="line">Helllo</span><br><span class="line">World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;Helllo\nWorld&#x27;</span>)</span><br><span class="line">Helllo\nWorld</span><br></pre></td></tr></table></figure>

<p>另外，反斜杠<code>(\)</code>可以作为续行符，解决长字符串的输入的问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;111\</span></span><br><span class="line"><span class="string">... 222\</span></span><br><span class="line"><span class="string">... 333\</span></span><br><span class="line"><span class="string">... &quot;</span></span><br><span class="line"><span class="string">&#x27;111222333&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>


<h4 id="四、字符串常规操作"><a href="#四、字符串常规操作" class="headerlink" title="四、字符串常规操作"></a>四、字符串常规操作</h4><p>首先，定义三个字符串变量来测试字符串操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">b=<span class="string">&quot;Python&quot;</span></span><br><span class="line">c=<span class="string">&quot;Hello Python Java C# javascript Php Ruby&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="1-字符串拼接-”-”"><a href="#1-字符串拼接-”-”" class="headerlink" title="1.字符串拼接:”+”"></a>1.字符串拼接:”+”</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+b</span><br><span class="line"><span class="string">&#x27;Hello WorldPython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<h5 id="2-字符串重复：”-”"><a href="#2-字符串重复：”-”" class="headerlink" title="2.字符串重复：”*”"></a>2.字符串重复：”*”</h5><p>字符串乘以一个整型数字，可以将原字符串按倍数重复连接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b*<span class="number">3</span></span><br><span class="line"><span class="string">&#x27;PythonPythonPython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<h5 id="3-通过索引获取指定位置字符串："><a href="#3-通过索引获取指定位置字符串：" class="headerlink" title="3.通过索引获取指定位置字符串：[]"></a>3.通过索引获取指定位置字符串：[]</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;H&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">100</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: string index out of <span class="built_in">range</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<h5 id="4-截取字符串，又称字符串切片："><a href="#4-截取字符串，又称字符串切片：" class="headerlink" title="4.截取字符串，又称字符串切片：[:]"></a>4.截取字符串，又称字符串切片：[:]</h5><p>测试1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;Hello Worl&#x27;</span></span><br></pre></td></tr></table></figure>

<p>测试2：截取”World“</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">6</span>:<span class="number">11</span>]</span><br><span class="line"><span class="string">&#x27;World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">6</span>:]</span><br><span class="line"><span class="string">&#x27;World&#x27;</span></span><br></pre></td></tr></table></figure>

<p>测试3：截取长字符串后的的部分，如c的”Ruby”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[-<span class="number">4</span>:]</span><br><span class="line"><span class="string">&#x27;Ruby&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="5-判断字符串：“in”-，判断字符串非包含：“not-in”"><a href="#5-判断字符串：“in”-，判断字符串非包含：“not-in”" class="headerlink" title="5.判断字符串：“in” ，判断字符串非包含：“not in”"></a>5.判断字符串：“in” ，判断字符串非包含：“not in”</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;H&quot;</span> <span class="keyword">in</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;H&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> a</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h5 id="6-获取字符串长度"><a href="#6-获取字符串长度" class="headerlink" title="6.获取字符串长度"></a>6.获取字符串长度</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(a)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>

<h5 id="7-获取字符串最大和最小字符-按照ASCll码规则-：max-字符串-，min-字符串"><a href="#7-获取字符串最大和最小字符-按照ASCll码规则-：max-字符串-，min-字符串" class="headerlink" title="7.获取字符串最大和最小字符(按照ASCll码规则)：max(字符串)，min(字符串)"></a>7.获取字符串最大和最小字符(按照ASCll码规则)：max(字符串)，min(字符串)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="string">&#x27;r&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="string">&#x27;w&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line"><span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="8-获取字符串的ASCll码：ord-字符串"><a href="#8-获取字符串的ASCll码：ord-字符串" class="headerlink" title="8.获取字符串的ASCll码：ord(字符串)"></a>8.获取字符串的ASCll码：ord(字符串)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="number">119</span></span><br></pre></td></tr></table></figure>



<p>   </p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习05-数据类型(03)-list与tuple</title>
    <url>/2018/08/07/Python%E5%AD%A6%E4%B9%A005-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(03)-list%E4%B8%8Etuple/</url>
    <content><![CDATA[<h4 id="一、理解列表list"><a href="#一、理解列表list" class="headerlink" title="一、理解列表list"></a>一、理解列表list</h4><p><code>列表</code>类似其他语言中数组的概念，使用<code>type</code>方法打印会得到<code>&lt;class &#39;list&#39;&gt;</code>，列表具有以下特点：</p>
<ol>
<li>列表使用中括号<code>[]</code>来表示;</li>
<li>组中的数据类型并不是固定的，可以是字符串，整型，布尔值等的混合元素，如<code>[1,False，&quot;helloworld&quot;]</code>;</li>
<li>嵌套列表，即列表中还有列表元素，如<code>[[1,2],[False],[&quot;Hello&quot;,&quot;World&quot;]]</code>;</li>
<li>列表作为一个容器，其中的元素都是有序的；</li>
</ol>
<span id="more"></span>

<h4 id="二、理解元组tuple"><a href="#二、理解元组tuple" class="headerlink" title="二、理解元组tuple"></a>二、理解元组tuple</h4><p>元组类似其他语言中结构体的概念，使用<code>type</code>方法打印会得到<code>&lt;class &#39;tuple&#39;&gt;</code>，元组具有以下特点：</p>
<ol>
<li>元组使用小括号<code>()</code>来表示；</li>
<li>元组中的元素个数是确定的；</li>
</ol>
<h4 id="三、区分列表与元组"><a href="#三、区分列表与元组" class="headerlink" title="三、区分列表与元组"></a>三、区分列表与元组</h4><p>相同点：</p>
<ol>
<li>列表、元组和字符串都是序列型数据，即它们中存放的元素都是有序的；</li>
<li>因此，所有适用于字符串的那些切片操作也能在列表和元组中使用；</li>
</ol>
<p>不同点：</p>
<ol>
<li>列表<code>list</code>是可变数据类型，可以追加和修改元素，但是元组则不能；</li>
<li>实际开发中，在不确定长度的相同类型队列的时候用列表，而对于提前知道元素数量的时候用元组；</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;Python&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.append(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;append&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">2</span>] = <span class="string">&quot;Python&quot;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>


<h4 id="四、关于元组的一个有趣的测试"><a href="#四、关于元组的一个有趣的测试" class="headerlink" title="四、关于元组的一个有趣的测试"></a>四、关于元组的一个有趣的测试</h4><p>在<code>Python</code>解释器中，使用<code>type</code>函数打印只有一个元素的元组如：<code>type((1))</code>，结果为<code>int</code>类型；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>((<span class="number">1</span>))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>分析原因：<code>Python</code>中的小括号既表示数学的优先运算，也可以表示元组，此处存在歧义；</p>
<p>表示只有一个元素的元组和空元组，分别使用<code>(1,)</code>，<code>(())</code>，测试如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>((<span class="number">1</span>,))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(())</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>


<p> </p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习05-数据类型(04)-set与dict</title>
    <url>/2018/08/08/Python%E5%AD%A6%E4%B9%A005-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(04)-set%E4%B8%8Edict/</url>
    <content><![CDATA[<p>区别于序列型数据类型(<code>str</code>、<code>list</code>、<code>tuple</code>)，此篇学习到的是无序数据类型：<code>set</code>和<code>dict</code>；</p>
<h4 id="一、集合set"><a href="#一、集合set" class="headerlink" title="一、集合set"></a>一、集合set</h4><ol>
<li>集合<code>set</code>使用<code>&#123;&#125;</code>表示，定义一个空的集合使用<code>set()</code>;</li>
<li>集合中的数据无序存放的，因此也不能使用索引取值和切片操作；</li>
<li>集合中的元素是非重复的；</li>
<li>从数学的角度理解，集合可以实现差集<code>(&#39;-&#39;)</code>、交集<code>(&#39;&amp;&#39;)</code>、并集<code>(&#39;|&#39;)</code></li>
</ol>
<span id="more"></span>

<h5 id="测试1：创建集合有如下两种方法，-其中的元素是非重复的"><a href="#测试1：创建集合有如下两种方法，-其中的元素是非重复的" class="headerlink" title="测试1：创建集合有如下两种方法， 其中的元素是非重复的"></a>测试1：创建集合有如下两种方法， 其中的元素是非重复的</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(set1)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(set1)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set2 = <span class="built_in">set</span>([<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(set2)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(set2)</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试2：集合之间的操作"><a href="#测试2：集合之间的操作" class="headerlink" title="测试2：集合之间的操作"></a>测试2：集合之间的操作</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>set2 - set1</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1 &amp; set2</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1 | set2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试3：向集合中添加和删除元素"><a href="#测试3：向集合中添加和删除元素" class="headerlink" title="测试3：向集合中添加和删除元素"></a>测试3：向集合中添加和删除元素</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1.add(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(set1)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(set1)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1.remove(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(set1)</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>


<h4 id="二、字典dict"><a href="#二、字典dict" class="headerlink" title="二、字典dict"></a>二、字典dict</h4><ol>
<li>字典<code>dict</code>使用<code>&#123;&#125;</code>表示，其中的键值对使用逗号将分开，定义一个空字典可以使用<code>&#123;&#125;</code>；</li>
<li>字典的数据是无序存放的，因此也不能使用索引取值和切片操作；</li>
<li>字典的元素是非重复的，新值会覆盖旧值;</li>
<li>字典的<code>key</code>不一定非要是字符串，也可以是数字等，但<code>key</code>必须不可变，比如<code>list</code>不可以作为<code>key</code>，<code>tuple</code>可以；</li>
</ol>
<h5 id="测试1：创建一个字典，并且通过key增加新的值"><a href="#测试1：创建一个字典，并且通过key增加新的值" class="headerlink" title="测试1：创建一个字典，并且通过key增加新的值"></a>测试1：创建一个字典，并且通过key增加新的值</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1 = &#123;<span class="string">&quot;1&quot;</span>:<span class="string">&quot;one&quot;</span>, <span class="string">&quot;2&quot;</span>:<span class="string">&quot;two&quot;</span>, <span class="string">&quot;3&quot;</span>:<span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dict1)</span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;three&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试2：一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值覆盖掉"><a href="#测试2：一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值覆盖掉" class="headerlink" title="测试2：一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值覆盖掉"></a>测试2：一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值覆盖掉</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1[<span class="string">&quot;1&quot;</span>]=<span class="string">&quot;oneone&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dict1)</span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;oneone&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;three&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试3：key不存在时取值报错，若要避免报错，有两种方法"><a href="#测试3：key不存在时取值报错，若要避免报错，有两种方法" class="headerlink" title="测试3：key不存在时取值报错，若要避免报错，有两种方法"></a>测试3：key不存在时取值报错，若要避免报错，有两种方法</h5><ul>
<li>方法1：使用<code>in</code>判断<code>key</code>是否在当前的字典中</li>
<li>方法2：使用字典的<code>get</code>方法，<code>key</code>不存在时会返回<code>None</code>，或者自定义返回的<code>value</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1[<span class="string">&quot;5&quot;</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;5&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;5&quot;</span> <span class="keyword">in</span> dict1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dict1.get(<span class="string">&quot;5&quot;</span>))</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dict1.get(<span class="string">&quot;5&quot;</span>,-<span class="number">1</span>))</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift学习01-属性</title>
    <url>/2017/08/01/Swift%E5%AD%A6%E4%B9%A001-%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p><strong>属性</strong>：是与特定的Swift类、结构体、枚举相关联的值；与其他语言相比，属性不再是被类所特有；</p>
<p><strong>主要内容</strong>：</p>
<ol>
<li>存储属性与计算属性</li>
<li>属性观察器</li>
<li>类型属性</li>
<li>全局变量与局部变量</li>
</ol>
<span id="more"></span>
<h4 id="一、存储属性与计算属性"><a href="#一、存储属性与计算属性" class="headerlink" title="一、存储属性与计算属性"></a>一、存储属性与计算属性</h4><p>从属性被定义的方式上看，<code>Swift</code>属性有存储属性和计算属性两种：</p>
<ul>
<li>存储属性：存储在特定类或结构体实例里的一个常量(<code>let</code>)或变量(<code>var</code>)，作为实例的一部分；</li>
<li>计算属性：计算属性不直接存储值，而是提供一个<code>getter</code>和一个可选的<code>setter</code>，来间接设置其他属性或变量值；</li>
</ul>
<p>下面通过一段代码演示这两种属性的区别：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Square</span>&#123;</span><br><span class="line">    <span class="comment">//存储属性</span></span><br><span class="line">    <span class="keyword">var</span> width:<span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算属性：通过一定计算方法得到的属性</span></span><br><span class="line">    <span class="keyword">var</span> area:<span class="type">Double</span>&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> width <span class="operator">*</span> width</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> square <span class="operator">=</span> <span class="type">Square</span>(width: <span class="number">10.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正方形边长：<span class="subst">\(square.width)</span>&quot;</span>)     <span class="comment">//正方形边长：10.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正方形面积：<span class="subst">\(square.area)</span>&quot;</span>)      <span class="comment">//正方形面积：100.0</span></span><br></pre></td></tr></table></figure>

<p>总结存储属性和计算属性的用法还有如下几种情况：</p>
<h5 id="1-1-常量结构体的存储属性"><a href="#1-1-常量结构体的存储属性" class="headerlink" title="1.1.常量结构体的存储属性"></a>1.1.常量结构体的存储属性</h5><p>如果创建一个结构体的实例并且将其赋值给一个常量，则无法再修改该实例的任何属性(包括其中的变量属性)。这是因为结构体是值类型，值类型实例被声明为常量，其所有属性都成了常量；在这点上，类与结构体不同，这种情况下，类中的可变属性可以被修改。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> square1 <span class="operator">=</span> <span class="type">Square</span>(width: <span class="number">10.0</span>)</span><br><span class="line"><span class="comment">//square1.width = 11.0      //报错</span></span><br><span class="line"><span class="keyword">var</span> square2 <span class="operator">=</span> <span class="type">Square</span>(width:<span class="number">20.0</span>)</span><br><span class="line">square2.width <span class="operator">=</span> <span class="number">21.0</span>      <span class="comment">//可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注：如果Squre是一个类，那么以上两种情况都可以通过</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-延迟存储属性"><a href="#1-2-延迟存储属性" class="headerlink" title="1.2.延迟存储属性"></a>1.2.延迟存储属性</h5><ul>
<li>定义：第一次被调用的时候才会计算其初始值的属性。在属性声明前使用<code>lazy</code>来表示一个延迟存储属性；</li>
<li>作用：当属性的值依赖于在实例的构造过程结束后才会知道影响值的外部因素时，或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它；</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="comment">//存储属性</span></span><br><span class="line">    <span class="keyword">var</span> startNum: <span class="type">Int</span>!</span><br><span class="line">    <span class="keyword">var</span> endNum:<span class="type">Int</span>!</span><br><span class="line">    <span class="comment">//计算属性</span></span><br><span class="line">    <span class="keyword">var</span> length :<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> endNum <span class="operator">-</span> startNum <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//延迟属性：使用闭包计算出了延迟属性的值，此过程只执行一次</span></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> sum: <span class="type">Int</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;计算延迟属性。。。。&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> tempNum <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">self</span>.startNum<span class="operator">...</span><span class="keyword">self</span>.endNum&#123;</span><br><span class="line">            tempNum <span class="operator">+=</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempNum</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可失败的构造方法</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">startNum</span>: <span class="type">Int</span> , <span class="params">endNum</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(startNum <span class="operator">&gt;</span> endNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.startNum <span class="operator">=</span> startNum</span><br><span class="line">        <span class="keyword">self</span>.endNum <span class="operator">=</span> endNum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> number <span class="operator">=</span> <span class="type">Number</span>(startNum: <span class="number">1</span>, endNum: <span class="number">100</span>)</span><br><span class="line">number<span class="operator">?</span>.length  <span class="comment">//100</span></span><br><span class="line">number<span class="operator">?</span>.sum    <span class="comment">//5050</span></span><br><span class="line">number<span class="operator">?</span>.sum    <span class="comment">//5050</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ol>
<li>必须将延迟存储属性声明成变量(使用<code>var</code>关键字)，因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性；</li>
<li>如果一个被标记为 <code>lazy</code> 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次；</li>
</ol>
<h5 id="1-3-计算属性的使用"><a href="#1-3-计算属性的使用" class="headerlink" title="1.3.计算属性的使用"></a>1.3.计算属性的使用</h5><p>计算属性不直接存储值，而是提供一个<code>getter</code>和一个可选的<code>setter</code>，来间接设置其他属性或变量值；总结它的使用特点如下：</p>
<ol>
<li>只有<code>getter</code>没有<code>setter</code>的计算属性就是只读计算属性。只读属性通过点运算符访问，只能返回值而不可设置新值；</li>
<li>计算属性与其他属性相关，是变化的，所以必须使用<code>var</code>关键字进行修饰，包括只读计算属性；</li>
<li>只读计算属性可以去掉<code>get</code>关键字和花括号；</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="comment">//存储型数据</span></span><br><span class="line">    <span class="keyword">var</span> originPoint  <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算型属性</span></span><br><span class="line">    <span class="keyword">var</span> center:<span class="type">Point</span>&#123;</span><br><span class="line">        <span class="comment">//get方法：获取计算属性值</span></span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> center_x <span class="operator">=</span> originPoint.x <span class="operator">+</span> size.width<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            <span class="keyword">let</span> center_y <span class="operator">=</span> originPoint.y <span class="operator">+</span> size.height<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: center_x, y: center_y)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有set方法，是只读，</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         set(newCenter)&#123;</span></span><br><span class="line"><span class="comment">            originPoint.x = newCenter.x - size.width/2</span></span><br><span class="line"><span class="comment">            originPoint.y = newCenter.y - size.height/2</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//set方法：设置计算属性新值</span></span><br><span class="line">        <span class="comment">//这里也可以省略括号和newCenter.使用newValue</span></span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">            originPoint.x <span class="operator">=</span> newValue.x <span class="operator">-</span> size.width<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            originPoint.y <span class="operator">=</span> newValue.y <span class="operator">-</span> size.height<span class="operator">/</span><span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算属性：area属性只有get,可以不显式的声明出get；此属性为只读属性</span></span><br><span class="line">    <span class="keyword">var</span> area:<span class="type">Double</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size.width <span class="operator">*</span> size.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">origin</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.originPoint  <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size  <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个长方形</span></span><br><span class="line"><span class="keyword">var</span> rect <span class="operator">=</span> <span class="type">Rectangle</span>(origin: <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), size: <span class="type">Size</span>(width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">rect.center</span><br><span class="line">rect.area  <span class="comment">//10000</span></span><br></pre></td></tr></table></figure>

<h4 id="二、属性观察器"><a href="#二、属性观察器" class="headerlink" title="二、属性观察器"></a>二、属性观察器</h4><p>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外；</p>
<p>属性观察器可以为延迟属性外的其他存储属性添加属性观察，也可以通过继承的方式重写父类属性，为其添加属性观察期。但是我们没有必要为非重写的计算属性添加属性观察器，因为它本身就可以通过自己的<code>setter</code>直接监控和响应值的变化；</p>
<p>添加属性观察器方式如下：</p>
<ul>
<li><code>willSet</code>方法：在新的值被设置之前调用，拥有一个默认参数<code>newValue</code>(代表新的属性值)；</li>
<li><code>didSet</code>方法：在新的值被设置之后立刻调用,拥有一个默认参数<code>oldValue</code>(代表就的属性值)；</li>
</ul>
<p>下面通过<code>lightBlub</code>演示用法，其中为<code>currentDianYa</code>属性添加了观察器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lightBlub</span> &#123;</span><br><span class="line">    <span class="comment">//最大电压和当前电压</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> maxDianYa <span class="operator">=</span> <span class="number">30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性监听</span></span><br><span class="line">    <span class="comment">//注意：willSet和didSet括号中的值可以省略，直接使用系统自带的newVlaue和oldValue</span></span><br><span class="line">    <span class="keyword">var</span> currentDianYa <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//可以使用系统默认的属性newValue和oldValue</span></span><br><span class="line">        <span class="keyword">willSet</span>(newCurrentDianya)&#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;当前电压值将要改变:  <span class="subst">\(currentDianYa)</span> -&gt; <span class="subst">\(newCurrentDianya)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当调用此方法时，已经设置了值的时候,</span></span><br><span class="line">        <span class="keyword">didSet</span>(oldCurentDianYa)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentDianYa <span class="operator">==</span> lightBlub.maxDianYa)&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;请注意 ,当前电压达到了最大电压值&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">self</span>.currentDianYa <span class="operator">&gt;</span> lightBlub.maxDianYa)&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;当前电压过高，不能设置新的电压值&quot;</span>)</span><br><span class="line">                currentDianYa <span class="operator">=</span> oldCurentDianYa</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> light <span class="operator">=</span> lightBlub()</span><br><span class="line">light.currentDianYa <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">light.currentDianYa <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">light.currentDianYa <span class="operator">=</span> <span class="number">40</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 打印结果：</span></span><br><span class="line"><span class="comment"> 当前电压值将要改变:  0 -&gt; 10</span></span><br><span class="line"><span class="comment"> 当前电压值将要改变:  10 -&gt; 30</span></span><br><span class="line"><span class="comment"> 请注意 ,当前电压达到了最大电压值</span></span><br><span class="line"><span class="comment"> 当前电压值将要改变:  30 -&gt; 40</span></span><br><span class="line"><span class="comment"> 当前电压过高，不能设置新的电压值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：willSet和didSet并不会在初始化时被调用</strong></p>
<h4 id="三、类型属性"><a href="#三、类型属性" class="headerlink" title="三、类型属性"></a>三、类型属性</h4><p><strong>实例属性</strong>属于一个特定类型的实例，因此实例之间的属性相互独立。但其实，也可以为类型本身定义属性，这样无论创建了多少个该类型实例，这些属性只有唯一的一份，这种属性就是<strong>类型属性</strong>。</p>
<p><code>Swift</code>的类型属性就相当于<code>OC</code>或者<code>C</code>中的类变量，但他们有着以下的不同： 在<code>OC</code>或者<code>C</code>中，与某个类型相关的静态常量和静态变量，是作为全局静态变量来定义的。但是Swift中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内；</p>
<p><code>Swift</code>类型属性使用关键字<code>static</code>,下面是一个具体示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试Int的类型属性</span></span><br><span class="line"><span class="type">Int</span>.min </span><br><span class="line"><span class="type">Int</span>.max</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment">//对象属性：本人的得分</span></span><br><span class="line">    <span class="keyword">var</span> score: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">//类型属性：本游戏的最高得分,使用类名来访问，使用关键字static声明</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> heighestScore:<span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//玩一句游戏得分</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">playGame</span>()&#123;</span><br><span class="line">        <span class="keyword">let</span> tempNum <span class="operator">=</span> <span class="type">Int</span>(arc4random()<span class="operator">%</span><span class="number">100</span>)<span class="operator">+</span><span class="number">1</span></span><br><span class="line">        <span class="keyword">self</span>.score <span class="operator">+=</span> tempNum</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> 的游戏得分是：<span class="subst">\(score)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">self</span>.score <span class="operator">&gt;</span> <span class="type">Player</span>.heighestScore)&#123;</span><br><span class="line">            <span class="type">Player</span>.heighestScore <span class="operator">=</span> <span class="keyword">self</span>.score</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前本游戏的最高分是:<span class="subst">\(Player.heighestScore)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> player1 <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;zs&quot;</span>)</span><br><span class="line">player1.playGame()</span><br><span class="line">player1.playGame()</span><br><span class="line"><span class="keyword">let</span> player2 <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;cf&quot;</span>)</span><br><span class="line">player2.playGame()</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 打印结果</span></span><br><span class="line"><span class="comment"> zs 的游戏得分是：11</span></span><br><span class="line"><span class="comment"> 当前本游戏的最高分是:11</span></span><br><span class="line"><span class="comment"> zs 的游戏得分是：87</span></span><br><span class="line"><span class="comment"> 当前本游戏的最高分是:87</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> cf 的游戏得分是：88</span></span><br><span class="line"><span class="comment"> 当前本游戏的最高分是:88</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="四、全局变量与局部变量"><a href="#四、全局变量与局部变量" class="headerlink" title="四、全局变量与局部变量"></a>四、全局变量与局部变量</h4><ul>
<li><p>全局变量：在函数、方法、闭包或者任意类型之外定义的变量；</p>
</li>
<li><p>局部变量：在函数、方法或者闭包内部定义的变量；</p>
<p>全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于：全局的常量或变量不需要标记lazy修饰符。</p>
</li>
</ul>
<p>局部范围的常量或变量从不延迟计算。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift学习02-函数</title>
    <url>/2017/08/02/Swift%E5%AD%A6%E4%B9%A002-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>函数</strong>：是一段完成特定任务的独立代码片段。你可以通过给函数命名来标识某个函数的功能，这个名字可以被用来在需要的时候”调用”这个函数来完成它的任务；</p>
<span id="more"></span>

<p><strong>主要内容：</strong></p>
<ol>
<li>函数的定义与调用</li>
<li>函数参数与返回值</li>
<li>函数外部参数名和参数名称<!--more--></li>
<li>默认参数</li>
<li>可变参数</li>
<li>输入输出参数</li>
<li>函数类型</li>
<li>函数类型</li>
</ol>
<h1 id="一、函数的定义与调用"><a href="#一、函数的定义与调用" class="headerlink" title="一、函数的定义与调用"></a>一、函数的定义与调用</h1><p>下面演示了在Swift中，定义函数和调用函数的基本操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">&quot;Anna&quot;</span>))         <span class="comment">// 打印 &quot;Hello, Anna!”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">greetAgain</span>(<span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello again, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greetAgain(person: <span class="string">&quot;Anna&quot;</span>))    <span class="comment">// 打印 &quot;Hello again, Anna!”</span></span><br></pre></td></tr></table></figure>

<h1 id="二、函数参数与返回值"><a href="#二、函数参数与返回值" class="headerlink" title="二、函数参数与返回值"></a>二、函数参数与返回值</h1><h4 id="2-1-无参，有返回值函数"><a href="#2-1-无参，有返回值函数" class="headerlink" title="2.1.无参，有返回值函数"></a>2.1.无参，有返回值函数</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHi</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi！&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHi())</span><br></pre></td></tr></table></figure>

<h4 id="2-2-多参，有返回值函数"><a href="#2-2-多参，有返回值函数" class="headerlink" title="2.2.多参，有返回值函数"></a>2.2.多参，有返回值函数</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHi</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">greet</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greetString <span class="operator">=</span> greet  <span class="operator">+</span> person</span><br><span class="line">    <span class="keyword">return</span> greetString</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHi(person: <span class="string">&quot;zhoushuai&quot;</span>, greet: <span class="string">&quot;Hi！&quot;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="2-3-无返回值函数"><a href="#2-3-无返回值函数" class="headerlink" title="2.3.无返回值函数"></a>2.3.无返回值函数</h4><p>严格意义上，虽然没有返回值，但是sayHello函数依然返回了值。没有定义返回类型的函数会返回一个特殊的Void值。它其实是一个空的元组(tuple)，没有任何元素，可以写成()</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHi</span>(<span class="params">person</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi-Hi, <span class="subst">\(person)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayHi(person: <span class="string">&quot;Tom”)  //打印 &quot;</span><span class="type">Hi</span><span class="operator">-</span><span class="type">Hi</span>, <span class="type">Tom</span>!”</span><br><span class="line"></span><br><span class="line"><span class="comment">//sayHello函数与下面的两个函数，会被Swift识别为同一种函数，进而报错重复定义。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func sayHi(person: String) -&gt;()&#123;</span></span><br><span class="line"><span class="comment">    print(&quot;Hello, \(person)!&quot;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">func sayHi(person: String) -&gt;Void &#123;</span></span><br><span class="line"><span class="comment">    print(&quot;Hello, \(person)!&quot;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-多重返回值函数"><a href="#2-4-多重返回值函数" class="headerlink" title="2.4.多重返回值函数"></a>2.4.多重返回值函数</h4><p>可以用元组（tuple）类型让多个值作为一个复合值从函数中返回,即返回多个参数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findMaxMin</span>(<span class="params">array</span>:[<span class="type">Int</span>]) -&gt;(max:<span class="type">Int</span>,min:<span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> max <span class="operator">=</span> array.max()</span><br><span class="line">    <span class="keyword">let</span> min <span class="operator">=</span> array.min()</span><br><span class="line">    <span class="keyword">return</span> (max<span class="operator">!</span>,min<span class="operator">!</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bounds <span class="operator">=</span> findMaxMin(array: [<span class="number">8</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;min is <span class="subst">\(bounds.min)</span> and max is <span class="subst">\(bounds.max)</span>&quot;</span>)</span><br><span class="line"><span class="comment">//打印 &quot;min is -6 and max is 109</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-可选返回值类型"><a href="#2-5-可选返回值类型" class="headerlink" title="2.5.可选返回值类型"></a>2.5.可选返回值类型</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findMaxMin2</span>(<span class="params">array</span>:[<span class="type">Int</span>]) -&gt;(max:<span class="type">Int</span>,min:<span class="type">Int</span>)<span class="operator">?</span>&#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>array.isEmpty <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> maxVlaue <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> minValue <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> array&#123;</span><br><span class="line">        maxVlaue <span class="operator">=</span> maxVlaue <span class="operator">&gt;</span> number <span class="operator">?</span> maxVlaue : number</span><br><span class="line">        minValue <span class="operator">=</span> minValue <span class="operator">&lt;</span> number <span class="operator">?</span> minValue : number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回的类型是可选型，因为结果有可能是nil</span></span><br><span class="line">    <span class="keyword">return</span> (maxVlaue, minValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> bounds2 <span class="operator">=</span> findMaxMin2(array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;min is <span class="subst">\(bounds2.min)</span> and max is <span class="subst">\(bounds2.max)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：可选元组类型如 (Int, Int)? 与元组包含可选类型如 (Int?, Int?) 是不同的.可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。</p>
<h4 id="2-6-无参，无返回值函数"><a href="#2-6-无参，无返回值函数" class="headerlink" title="2.6.无参，无返回值函数"></a>2.6.无参，无返回值函数</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHiHi</span>()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sayHiHi:无参五返回值的函数！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayHiHi()</span><br></pre></td></tr></table></figure>

<h1 id="三、函数外部参数名和参数名称"><a href="#三、函数外部参数名和参数名称" class="headerlink" title="三、函数外部参数名和参数名称"></a>三、函数外部参数名和参数名称</h1><p>每个函数参数都有一个外部参数名(参数标签)以及参数名称，只不过默认情况下，函数参数直接使用参数名来作为它们的外部参数名。下面来总结函数外部参数名的各种用法。</p>
<h4 id="3-1-指定外部参数名，让函数表意更明确"><a href="#3-1-指定外部参数名，让函数表意更明确" class="headerlink" title="3.1.指定外部参数名，让函数表意更明确"></a>3.1.指定外部参数名，让函数表意更明确</h4><p>函数外部参数名的使用能够让一个函数在调用时更有表达力，更类似自然语言，并且仍保持了函数内部的可读性以及清晰的意图。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正常写法：</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">sayHelloTo</span>(<span class="params">name</span>: <span class="type">String</span> , <span class="params">greeting</span>: <span class="type">String</span>) -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(greeting)</span>, <span class="subst">\(name)</span>!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sayHelloTo(name: <span class="string">&quot;风恣&quot;</span>, greeting: <span class="string">&quot;Hello”)) </span></span><br><span class="line"><span class="string">//打印：&quot;</span><span class="type">Hello，风恣！</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//改进上面的函数，为第二个参数指定外部参数名，让表意更加明确</span></span><br><span class="line"><span class="string">func sayHelloTo(name: String, withGreetingWord greeting:String) -&gt; String&#123;</span></span><br><span class="line"><span class="string">    return &quot;</span>\(greeting),\(name)<span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">print(sayHelloTo(name: &quot;</span><span class="type">FengZi</span><span class="string">&quot;, withGreetingWord: &quot;</span><span class="type">Hello</span><span class="string">&quot;))</span></span><br><span class="line"><span class="string">//打印：&quot;</span><span class="type">Hello，FengZi</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>特别说明</strong>： <strong>一般情况下，第一个参数不设置外部参数名，因为第一个参数的外部参数名是隐藏在函数名中的。</strong></p>
<h4 id="3-2-忽略参数标签"><a href="#3-2-忽略参数标签" class="headerlink" title="3.2.忽略参数标签"></a>3.2.忽略参数标签</h4><p>有时候，使用外部参数名反而会使函数更加繁琐，这又需要隐藏外部参数名：这时候使用下划线**”_“**来代替一个明确的参数标签。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正常写法：</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">mutipleOf</span>(<span class="params">num1</span>: <span class="type">Int</span>, <span class="params">and</span> <span class="params">num2</span>:<span class="type">Int</span>)-&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">*</span> num2</span><br><span class="line">&#125;</span><br><span class="line">mutipleOf(num1: <span class="number">1</span>, and: <span class="number">6</span>)    <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改进1：忽略参数标签</span></span><br><span class="line"><span class="keyword">func</span>  <span class="title function_">mutipleOf</span>(<span class="params">num1</span>:<span class="type">Int</span> , <span class="params">num2</span>:<span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">*</span> num2;</span><br><span class="line">&#125;</span><br><span class="line">mutipleOf(num1: <span class="number">1</span>, num2: <span class="number">6</span>)   <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改进2:彻底不使用参数名,使用下划线省略</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">mutiply</span>(<span class="keyword">_</span> <span class="params">num1</span>:<span class="type">Int</span>, <span class="keyword">_</span> <span class="params">num2</span>:<span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">*</span> num2</span><br><span class="line">&#125;</span><br><span class="line">mutiply(<span class="number">1</span>, <span class="number">6</span>)                <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<h1 id="四、默认参数"><a href="#四、默认参数" class="headerlink" title="四、默认参数"></a>四、默认参数</h1><p>定义函数的时候，可以给某些参数设置默认值(Deafult Value)，当默认值被定义后，调用这个函数时可以忽略这个参数。 下面的函数包括两个默认参数，而且设置的默认参数都要在非默认参数后面。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">playMusic</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">instrument</span>:<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;drum&quot;</span>, <span class="params">sound</span>:<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;咚咚咚。。。&quot;</span>) -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> scene <span class="operator">=</span> name <span class="operator">+</span> <span class="string">&quot; play the &quot;</span> <span class="operator">+</span> instrument <span class="operator">+</span> <span class="string">&quot;,&quot;</span> <span class="operator">+</span> sound;</span><br><span class="line">    <span class="built_in">print</span>(scene)</span><br><span class="line">    <span class="keyword">return</span> scene;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用了默认参数的参数, 相关的默认参数可以不用传值</span></span><br><span class="line">playMusic(name: <span class="string">&quot;zhoushuai”)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//对于默认参数，可以有选择的传入值</span></span><br><span class="line"><span class="string">playMusic(name: &quot;</span>zhoushuai<span class="string">&quot;, instrument: &quot;</span>panio<span class="string">&quot;)</span></span><br><span class="line"><span class="string">playMusic(name: &quot;</span>zhoushuai<span class="string">&quot;, instrument: &quot;</span>panio<span class="string">&quot; ,sound: &quot;</span>lingling<span class="operator">~</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//测试打印：</span></span><br><span class="line"><span class="string">//zhoushuai play the drum,咚咚咚。。。</span></span><br><span class="line"><span class="string">//zhoushuai play the panio,咚咚咚。。。</span></span><br><span class="line"><span class="string">//zhoushuai play the panio,lingling~</span></span><br></pre></td></tr></table></figure>

<h1 id="五、可变参数"><a href="#五、可变参数" class="headerlink" title="五、可变参数"></a>五、可变参数</h1><p>一个可变参数可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数传入不确定数量的输入值。通过在变量类型名后面加入（…）的方式来定义可变参数。下面的算术平均函数演示了可变参数的用法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">arithmeticMean</span>(<span class="keyword">_</span> <span class="params">numbers</span>: <span class="type">Double</span>...) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total <span class="operator">+=</span> number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total <span class="operator">/</span> <span class="type">Double</span>(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)   <span class="comment">//返回3.0, 是这5个数的平均数。</span></span><br><span class="line"></span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>, <span class="number">18.75</span>)  <span class="comment">//返回10.0, 是这3个数的平均数。</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：一个函数只能拥有一个可变参数</strong></p>
<h1 id="六、输入输出参数"><a href="#六、输入输出参数" class="headerlink" title="六、输入输出参数"></a>六、输入输出参数</h1><p>函数参数默认是常量形参，所以我们在函数中对其修改都不会对参数的原值产生影响。为了解决这个问题，我们可以将这些需要修改的参数定义为输入输出参数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> somInt <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//普通函数:报错，因为num是常量，不能被再次修改</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func modifyNum(num:Int)&#123;</span></span><br><span class="line"><span class="comment">    num = num * 2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带有输入输出函数的函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">modifyNum2</span>(<span class="params">num</span>:<span class="keyword">inout</span> <span class="type">Int</span>)&#123;</span><br><span class="line">    num <span class="operator">=</span> num <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">modifyNum2(num: <span class="operator">&amp;</span>somInt)</span><br><span class="line"><span class="built_in">print</span>(somInt)           <span class="comment">//20，someIn被修改</span></span><br></pre></td></tr></table></figure>

<p>注意： 1.只能传递变量给输入输出参数，而不能是常量或者字面量，因为这些量是不能被修改的； 2.传入参数作为输入输出参数时，需要在参数名前添加&amp;符号，表示这个值可以被修改；</p>
<h1 id="七、函数类型"><a href="#七、函数类型" class="headerlink" title="七、函数类型"></a>七、函数类型</h1><p>如同参数有整型，布尔型等参数类型一样，每个函数都有种特定的函数类型。函数的类型由函数的参数类型和返回值类型组成。下面举例说明：</p>
<h4 id="1-以下两个函数具有相同的函数类型：（Int-Int）-Int"><a href="#1-以下两个函数具有相同的函数类型：（Int-Int）-Int" class="headerlink" title="1.以下两个函数具有相同的函数类型：（Int,Int）-&gt;Int"></a>1.以下两个函数具有相同的函数类型：（Int,Int）-&gt;Int</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">addTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">multiplyTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">*</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-没有参数也没有返回值的函数类型：-Void"><a href="#2-没有参数也没有返回值的函数类型：-Void" class="headerlink" title="2.没有参数也没有返回值的函数类型：()-&gt;Void"></a>2.没有参数也没有返回值的函数类型：()-&gt;Void</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printHelloWorld</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-使用函数类型"><a href="#3-使用函数类型" class="headerlink" title="3.使用函数类型"></a>3.使用函数类型</h4><h5 id="3-1定义一个函数类型的变量或常量，然后可以使用适当函数为其赋值"><a href="#3-1定义一个函数类型的变量或常量，然后可以使用适当函数为其赋值" class="headerlink" title="3.1定义一个函数类型的变量或常量，然后可以使用适当函数为其赋值"></a>3.1定义一个函数类型的变量或常量，然后可以使用适当函数为其赋值</h5><p>下面的mathFunction变量，经过赋值之后，指向了addTwoInts函数，所以它也可以当做addTwoInts函数使用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunction:(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;<span class="type">Int</span> <span class="operator">=</span> addTwoInts</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值了加法函数：addTwoInts</span></span><br><span class="line"><span class="built_in">print</span>(mathFunction(<span class="number">3</span>,<span class="number">4</span>))         <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值了乘法函数：multiplyTwoInts</span></span><br><span class="line">mathFunction <span class="operator">=</span> multiplyTwoInts;</span><br><span class="line"><span class="built_in">print</span>(mathFunction(<span class="number">3</span>,<span class="number">4</span>))         <span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2函数类型做为参数类型"><a href="#3-2函数类型做为参数类型" class="headerlink" title="3.2函数类型做为参数类型"></a>3.2函数类型做为参数类型</h5><p>函数类型也可以作为另一个函数的参数类型，这样我们就可以将函数的一部分实现留给函数的调用者来提供。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试1：</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">printMathResult</span>(<span class="keyword">_</span> <span class="params">mathFunction</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(a, b))</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)          <span class="comment">//打印 &quot;Result: 8”</span></span><br><span class="line">printMathResult(multiplyTwoInts, <span class="number">3</span>, <span class="number">5</span>)   <span class="comment">//打印：&quot;Result: 15&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试2：</span></span><br><span class="line"><span class="comment">//生成随机数组成的数组</span></span><br><span class="line"><span class="keyword">var</span> array: [<span class="type">Int</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">6</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max<span class="operator">=</span><span class="number">20</span></span><br><span class="line">    <span class="keyword">let</span> randNum0<span class="operator">=</span>arc4random()<span class="operator">%</span><span class="type">UInt32</span>(max)</span><br><span class="line">    <span class="keyword">let</span> randNum1<span class="operator">=</span><span class="type">Int</span>(randNum0)</span><br><span class="line">    <span class="keyword">if</span>(array.contains(randNum1))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array.append(randNum1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(array)       <span class="comment">//[12, 9, 19, 13, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序方法1：从大到小排序</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">biggerNumFirst</span>(<span class="params">num1</span>:<span class="type">Int</span>, <span class="params">num2</span>:<span class="type">Int</span>) -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">&gt;</span> num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义排序方法2：将数字转化为字符串， 按照字符换的字典排序</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">compareByNumberString</span>(<span class="params">num1</span>: <span class="type">Int</span>, <span class="params">num2</span>: <span class="type">Int</span>) -&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(num1) <span class="operator">&gt;</span> <span class="type">String</span>(num2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义排序方法3：距离某个数字最近</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">nearTo10</span>(<span class="params">num1</span>: <span class="type">Int</span>, <span class="params">num2</span>: <span class="type">Int</span>) -&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(num1 <span class="operator">-</span> <span class="number">10</span>) <span class="operator">&lt;</span> <span class="built_in">abs</span>(num2 <span class="operator">-</span> <span class="number">10</span>) <span class="operator">?</span> <span class="literal">true</span> :<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array.sort(by: biggerNumFirst(num1:num2:))</span><br><span class="line">array.sort(by: compareByNumberString)</span><br><span class="line">array.sort(by: nearTo10)</span><br><span class="line"><span class="comment">//测试打印:</span></span><br><span class="line"><span class="comment">//[19, 13, 12, 9, 3]</span></span><br><span class="line"><span class="comment">//[9, 3, 19, 13, 12]</span></span><br><span class="line"><span class="comment">//[9, 12, 13, 3, 19]</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-函数类型作为返回值类型"><a href="#3-3-函数类型作为返回值类型" class="headerlink" title="3.3.函数类型作为返回值类型"></a>3.3.函数类型作为返回值类型</h5><p>你可以用函数类型作为另一个函数的返回类型。你需要做的是在返回箭头（-&gt;）后写一个完整的函数类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getMathFunction</span>(<span class="params">symbol</span>: <span class="type">String</span>)-&gt;(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> symbol <span class="operator">==</span> <span class="string">&quot;*&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> multiplyTwoInts;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addTwoInts</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入不同的字符串参数，会返回不同的函数</span></span><br><span class="line"><span class="keyword">var</span> function <span class="operator">=</span> getMathFunction(symbol: <span class="string">&quot;*&quot;</span>)</span><br><span class="line">function(<span class="number">1</span>,<span class="number">2</span>)    <span class="comment">//2</span></span><br><span class="line">function <span class="operator">=</span> getMathFunction(symbol: <span class="string">&quot;abcdefg&quot;</span>)</span><br><span class="line">function(<span class="number">1</span>,<span class="number">2</span>)    <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<h1 id="八、嵌套函数"><a href="#八、嵌套函数" class="headerlink" title="八、嵌套函数"></a>八、嵌套函数</h1><p>通常，我们见到的都是全局函数，即定义在全局域中的函数。我们也可以把函数定义在别的函数体中，称作嵌套函数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getMathFunction2</span>(<span class="params">symbol</span>: <span class="type">String</span>)-&gt;(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">mathFunc1</span>(<span class="params">a</span>:<span class="type">Int</span>,<span class="params">b</span>:<span class="type">Int</span>)-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a <span class="operator">-</span> b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">mathFunc2</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a <span class="operator">*</span> b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> symbol <span class="operator">==</span> <span class="string">&quot;*&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mathFunc2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mathFunc1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> method <span class="operator">=</span> getMathFunction2(symbol: <span class="string">&quot;*&quot;</span>)</span><br><span class="line">method(<span class="number">5</span>,<span class="number">6</span>)     <span class="comment">//30</span></span><br><span class="line">method <span class="operator">=</span> getMathFunction2(symbol: <span class="string">&quot;123123&quot;</span>)</span><br><span class="line">method(<span class="number">5</span>,<span class="number">6</span>)     <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift学习03-闭包</title>
    <url>/2017/08/03/Swift%E5%AD%A6%E4%B9%A003-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p><strong>闭包</strong>：是自包含的函数代码块，可以在代码中被传递和使用。<code>Swift</code>中的闭包与<code>C</code>和 <code>Objective-C</code>中的代码块(<code>blocks</code>)以及其他一些编程语言中的匿名函数比较相似；</p>
<span id="more"></span>

<p><strong>主要内容：</strong></p>
<ol>
<li>闭包表达式</li>
<li>闭包的使用与优化</li>
<li>值捕获</li>
<li>逃逸闭包</li>
<li>自动闭包</li>
</ol>
<h4 id="一、闭包表达式"><a href="#一、闭包表达式" class="headerlink" title="一、闭包表达式"></a>一、闭包表达式</h4><p><code>Swift</code>闭包的三种存在形式：</p>
<ol>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包 闭包表达式的语法一般有如下的一般形式:</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>闭包的外层是一个大括号，先写的参数和返回值，然后操作部分之前使用<code>in</code>；</li>
<li>闭包就相当于<code>OC</code>中的<code>block</code>, 也可以看做是匿名函数；</li>
<li>闭包表达式参数可以是<code>in-out</code>参数，但不能设定默认值；</li>
<li>闭包的函数体部分由关键字<code>in</code>引入，该关键字表示闭包参数和返回值类型已经完成，闭包函数体开始；</li>
</ol>
<h4 id="二、闭包的使用与优化"><a href="#二、闭包的使用与优化" class="headerlink" title="二、闭包的使用与优化"></a>二、闭包的使用与优化</h4><p>下面，我们使用<code>Swift</code>标准库中的<code>sorted(by:)</code>方法来测试闭包的使用。</p>
<p><code>sorted(by:)</code>方法允许外部传入一个用于排序的闭包函数，将已知类型数组中的值进行排序，完成排序之后，该方法会返回一个与原数组大小相同，包含同类型元素已正确排序的新数组:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个整型数组</span></span><br><span class="line"><span class="keyword">var</span> someInts: [<span class="type">Int</span>] <span class="operator">=</span> [<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//定义一个排序函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">biggerNumFirst</span>(<span class="params">num1</span>:<span class="type">Int</span>, <span class="params">num2</span>:<span class="type">Int</span>) -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">&gt;</span> num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通用法：将biggerNumFirst函数传入sorted函数，实现排序</span></span><br><span class="line"><span class="keyword">var</span> sortInts <span class="operator">=</span> someInts.sorted(by: biggerNumFirst)</span><br><span class="line"><span class="built_in">print</span>(sortInts)     <span class="comment">//[9, 7, 5, 3, 1, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包用法：为sorted函数参数传入一个闭包，实现排序</span></span><br><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by:&#123; (a:<span class="type">Int</span>, b:<span class="type">Int</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">&gt;</span> b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)     <span class="comment">//[9, 7, 5, 3, 1, 0]</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：因为闭包不会在其他地方调用，所以不使用外部参数名</strong></p>
<p>闭包使用起来十分灵活，我们可以在某些特定情况下对齐进行优化，下面是对上述闭包的优化：</p>
<h5 id="2-1-根据上下文推断类型，省略参数类型与括号"><a href="#2-1-根据上下文推断类型，省略参数类型与括号" class="headerlink" title="2.1.根据上下文推断类型，省略参数类型与括号"></a>2.1.根据上下文推断类型，省略参数类型与括号</h5><p>由于排序闭包函数是作为<code>sorted(by:)</code>方法的参数传入的，<code>Swift</code>可以推断其类型和返回值类型。所以<code>sorted(by:)</code>方法被一个<code>Int</code>类型的数组调用，其参数必定是<code>(Int,Int)-&gt;Bool</code>类型的函数。</p>
<p>最后，根据上下文推断类型，我们可以省略参数类型和参数周围的括号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by: &#123;a,b <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">&gt;</span> b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure>

<h5 id="2-2-对于不会发生歧义的闭包，可将其写成一行"><a href="#2-2-对于不会发生歧义的闭包，可将其写成一行" class="headerlink" title="2.2.对于不会发生歧义的闭包，可将其写成一行"></a>2.2.对于不会发生歧义的闭包，可将其写成一行</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by:&#123;a,b <span class="keyword">in</span> <span class="keyword">return</span> a <span class="operator">&gt;</span> b&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure>

<h5 id="2-3-单行闭包表达式，省略return关键字"><a href="#2-3-单行闭包表达式，省略return关键字" class="headerlink" title="2.3.单行闭包表达式，省略return关键字"></a>2.3.单行闭包表达式，省略return关键字</h5><p>省略<code>return</code>关键字的条件：</p>
<ol>
<li><code>sorted(by:)</code>方法的参数类型明确了闭包必须返回一个<code>Bool</code>类型值；</li>
<li>单行闭包表达式中，其返回值类型没有歧义；</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by: &#123;a,b <span class="keyword">in</span> a <span class="operator">&gt;</span> b&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure>

<h5 id="2-4-使用参数名缩写-不推荐使用"><a href="#2-4-使用参数名缩写-不推荐使用" class="headerlink" title="2.4.使用参数名缩写(不推荐使用)"></a>2.4.使用参数名缩写(不推荐使用)</h5><p><code>Swift</code>自动为内联闭包提供了参数名称缩写功能，你可以直接通过<code>$0</code>，<code>$1</code>，<code>$2</code> 来顺序调用闭包的参数，以此类推；</p>
<p>如果我们在闭包表达式中使用参数名称缩写， 我们就可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。<code>in</code>关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by: &#123;<span class="variable">$0</span><span class="operator">&gt;</span><span class="variable">$1</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure>

<h5 id="2-5-使用运算符简化闭包-不推荐使用"><a href="#2-5-使用运算符简化闭包-不推荐使用" class="headerlink" title="2.5.使用运算符简化闭包(不推荐使用)"></a>2.5.使用运算符简化闭包(不推荐使用)</h5><p><code>Swift</code>的<code>Int</code>类型定义了关于大于号（<code>&gt;</code>）的字符串实现，其作为一个函数接受两个<code>Int</code>类型的参数并返回<code>Bool</code>类型的值。而这正好与<code>sorted(by:)</code>方法的参数需要的函数类型相符合。可以使用大于号来代替闭包</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">sortInts <span class="operator">=</span> someInts.sorted(by: <span class="operator">&gt;</span>)</span><br><span class="line"><span class="built_in">print</span>(sortInts)</span><br></pre></td></tr></table></figure>

<h5 id="2-6-尾随闭包，解决长闭包的书写问题"><a href="#2-6-尾随闭包，解决长闭包的书写问题" class="headerlink" title="2.6.尾随闭包，解决长闭包的书写问题"></a>2.6.尾随闭包，解决长闭包的书写问题</h5><p>定义：将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性；</p>
<p>写法：将闭包书写在函数括号之后，函数会支持将其作为最后一个参数调用，使用尾随闭包，不需要写出它的参数标签；</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionThatTakesAClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">//函数体部分</span></span><br><span class="line">    closure(); <span class="comment">//调用闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">    <span class="comment">//闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">//闭包主体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 () 省略掉：</span></span><br><span class="line">someFunctionThatTakesAClosure &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)    <span class="comment">//打印：Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结<code>Swift</code>闭包主要的四种优化方法：</p>
<ol>
<li>利用上下文推断参数和返回值类型，省略参数类型与括号；</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略<code>return</code>关键字；</li>
<li>参数名称缩写；</li>
<li>尾随闭包语法；</li>
</ol>
<h4 id="三、值捕获"><a href="#三、值捕获" class="headerlink" title="三、值捕获"></a>三、值捕获</h4><p>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。<code>Swift</code>会为你管理在捕获过程中涉及到的所有内存操作；</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeIncrementer</span>(<span class="params">forIncrement</span> <span class="params">amount</span>: <span class="type">Int</span>) -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> runningTotal <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">incrementer</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal <span class="operator">+=</span> amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ol>
<li><code>makeIncrementer</code>函数以<code>amount</code>为参数，以<code>()-&gt;Int</code>作为返回值类型，其函数体中还嵌套了另一个函数<code>incrementer</code>；</li>
<li>如果我们把<code>incrementer</code>单独拿出来，会发现其中<code>runingTotal</code>和<code>amount</code>变量都无法使用，因为这两个变量的引用是<code>incrementer</code>从外部捕获的；</li>
<li><code>Swift</code>会负责被捕获变量的所有内存管理工作，包括对捕获的一份值拷贝，也包括释放不再需要的变量；</li>
</ol>
<p>现在再来测试<code>makeIncrementer</code>函数的使用:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementByTen <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">10</span>)</span><br><span class="line">incrementByTen();    <span class="comment">//10</span></span><br><span class="line">incrementByTen();    <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> incrementBySeven <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">7</span>)</span><br><span class="line">incrementBySeven()   <span class="comment">//7</span></span><br><span class="line">incrementBySeven();  <span class="comment">//14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> alsoIncrementByTen <span class="operator">=</span> incrementByTen</span><br><span class="line">alsoIncrementByTen() <span class="comment">//30</span></span><br></pre></td></tr></table></figure>

<p>代码分析:</p>
<ol>
<li><code>incrementByTen</code>与<code>incrementBySeven</code>，是通过<code>makeIncrementer</code>函数传入不同的增量参数<code>amount</code>而创建的；</li>
<li>两个函数都有属于各自的引用，其中的<code>runningTotal</code>变量都是从<code>makeIncrementer</code>中捕获的，但是已经各自没有关系；</li>
<li>函数和闭包都是引用类型，将其赋值给变量或者常量，都只是操作的它们的引用，而不会改变闭包或者函数本身；</li>
</ol>
<h4 id="四、逃逸闭包"><a href="#四、逃逸闭包" class="headerlink" title="四、逃逸闭包"></a>四、逃逸闭包</h4><p>当一个闭包作为参数传到一个函数中，但是这个闭包在<strong>函数返回之后才被执行</strong>，我们称该闭包从函数中逃逸。</p>
<p>逃逸闭包：在定义接受闭包作为参数的函数时，我们需要在参数名之前标注<code>@escaping</code>，以此表明这个闭包是允许”逃逸”出这个函数的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithEscapingClosure</span>(<span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">//代码1：执行闭包，不需要添加@escaping</span></span><br><span class="line">    <span class="comment">//completionHandler();</span></span><br><span class="line">    <span class="comment">//代码2：函数外部对闭包进行了操作</span></span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>代码分析： <code>someFunctionWithEscapingClosure(_:)</code> 函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果不将这个参数标记为<code>@escaping</code>，就会得到一个编译错误。</p>
<h5 id="4-1-逃逸闭包的使用"><a href="#4-1-逃逸闭包的使用" class="headerlink" title="4.1.逃逸闭包的使用"></a>4.1.逃逸闭包的使用</h5><p>逃逸闭包和非逃逸闭包在使用上有所不同。将一个闭包标记为<code>@escaping</code>(即逃逸闭包)后，在调用这个闭包时就必须在闭包中显式地引用 <code>self</code>。一个示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个带有非逃逸闭包参数的函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithNonescapingClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个可以使用闭包的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">doSomething</span>() &#123;</span><br><span class="line">        <span class="comment">//调用逃逸闭包：必须在闭包中显式引用self</span></span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x <span class="operator">=</span> <span class="number">100</span> &#125;</span><br><span class="line">        <span class="comment">//调用非逃逸闭包：可以隐式引用self</span></span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x <span class="operator">=</span> <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance <span class="operator">=</span> <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)         <span class="comment">//打印出 &quot;200”</span></span><br></pre></td></tr></table></figure>

<h4 id="五、自动闭包"><a href="#五、自动闭包" class="headerlink" title="五、自动闭包"></a>五、自动闭包</h4><p>**自动闭包：**一种自动创建的闭包，用与包装传递给函数作为参数的表达式；</p>
<ol>
<li>自动闭包不接受任何参数；</li>
<li>自动闭包被调用的时候，会返回被包装在其中的表达式的值；</li>
<li>自动闭包是用一个普通的表达式来代替显式的闭包，能够省略闭包的花括号；</li>
</ol>
<p>其实，我们经常调用采用自动闭包的函数，但是却少去实现这样的函数，<code>assert</code>函数就是其中之一：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert</span>(condition:, message:)</span><br></pre></td></tr></table></figure>

<p><code>assert</code>函数中：</p>
<ol>
<li><code>condition</code>参数可以接受自动闭包作为值，<code>condition</code>参数仅会在<code>debug</code>模式下被求值；</li>
<li>在<code>condidtion</code>被调用返回值为<code>false</code>时，<code>message</code>参数将被使用。</li>
</ol>
<h5 id="5-1-自动闭包的基本使用"><a href="#5-1-自动闭包的基本使用" class="headerlink" title="5.1.自动闭包的基本使用"></a>5.1.自动闭包的基本使用</h5><p>自动闭包能够实现延迟求值，直到调用这个闭包时，代码才会被执行。这对于有副作用或者高计算成本的代码来说是有益处的;下面的代码展示了自动闭包实现延时求值的具体做法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)    <span class="comment">//打印出 “5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动闭包不接受参数，只是一个表达式</span></span><br><span class="line"><span class="keyword">let</span> customerProvider <span class="operator">=</span> &#123; customersInLine.remove(at: <span class="number">0</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)    <span class="comment">//打印出 “5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用自动闭包</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)   <span class="comment">// Prints &quot;Now serving Chris!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)               <span class="comment">//打印出 &quot;4”</span></span><br></pre></td></tr></table></figure>

<p>代码分析：闭包实现了移除第一元素的功能，但是在闭包被调用之前，这个元素是不会被移除的。这就实现了延迟的作用</p>
<h5 id="5-2-自动闭包在函数中的使用"><a href="#5-2-自动闭包在函数中的使用" class="headerlink" title="5.2.自动闭包在函数中的使用"></a>5.2.自动闭包在函数中的使用</h5><p>现在将闭包作为参数传递给一个函数，同样可以实现延时求值行为。下面的<code>serve</code>函数接受了一个闭包参数(具有删除第一个元素且返回这个元素的功能)；</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以闭包的形式传入参数</span></span><br><span class="line">serve(customer: &#123; customersInLine.remove(at: <span class="number">0</span>) &#125; )  <span class="comment">//打印出&quot;Now serving Alex!”</span></span><br></pre></td></tr></table></figure>

<p>现在使用自动闭包来实现上述函数功能，使用<code>@autoclosure</code>关键字，标明参数使用的是自动闭包，具体示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于标明了自动闭包，这里直接省略了闭包的花括号</span></span><br><span class="line">serve(customer: customersInLine.remove(at: <span class="number">0</span>))  <span class="comment">//打印出&quot;Now serving Ewa!\n&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>过度使用 autoclosures 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。</strong></p>
<h5 id="5-3-可”逃逸”的自动闭包"><a href="#5-3-可”逃逸”的自动闭包" class="headerlink" title="5.3.可”逃逸”的自动闭包"></a>5.3.可”逃逸”的自动闭包</h5><p>一个自动闭包可以“逃逸”，这时候应该同时使用<code>@autoclosure</code> 和 <code>@escaping</code> 属性，下面举例说明：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">collectCustomerProviders</span>(<span class="keyword">_</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> <span class="keyword">@escaping</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用collectCustomerProviders，向数组中追加闭包</span></span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Collected <span class="subst">\(customerProviders.count)</span> closures.&quot;</span>)   <span class="comment">//打印 &quot;Collected 2 closures.&quot;</span></span><br><span class="line"><span class="comment">//循环数组中闭包，并且执行</span></span><br><span class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &quot;Now serving Barry!&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;Now serving Daniella!”</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ol>
<li>作为逃逸闭包：<code>collectCustomerProviders</code>函数中，闭包<code>customerProvider</code>被追加到<code>customerProviders</code>中，而这个数据是定义在函数作用域范围之外的，这意味数组内的闭包能够在函数返回之后被调用，所以<code>customerProvider</code>必须允许”逃逸”出函数作用域；</li>
<li>作为自动闭包：调用<code>collectCustomerProviders</code>函数时，传入的闭包是表达式的形式，自动闭包省略了闭包花括号；</li>
</ol>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift学习04-构造器(上)</title>
    <url>/2017/08/04/Swift%E5%AD%A6%E4%B9%A004-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%8A)/</url>
    <content><![CDATA[<p><strong>主要内容：</strong></p>
<ol>
<li>构造器简介</li>
<li>默认构造器 - 最简单的构造器</li>
<li>逐一成员构造器：类中不存在，适用于结构体</li>
<li>可选型属性在构造器中的使用</li>
<li>构造器代理</li>
</ol>
<span id="more"></span>

<h4 id="一、构造器简介"><a href="#一、构造器简介" class="headerlink" title="一、构造器简介"></a>一、构造器简介</h4><p>Swift赋予自定义类型更加丰富的功能，一个显著地方就是构造过程。Swift可以为自定义类型设置构造器来初始化一个实例。有关Swift构造器的使用特点可以总结如下：</p>
<ol>
<li>构造器适用于类、结构体、枚举。是新的实例可用之前必须执行的一个过程</li>
<li>构造器具体的操作包括：必须保证所有存储型属性有合适初始值，执行其他必须的设置</li>
<li>构造器无需返回值，区别于OC</li>
<li>类的实例可以定义析构器，在实例释放之前执行特定的清除工作</li>
<li>存储型属性设置默认值和构造器中为其设置初始值，这种不会触发任何属性观察器</li>
</ol>
<h4 id="二、默认构造器-最简单的构造器"><a href="#二、默认构造器-最简单的构造器" class="headerlink" title="二、默认构造器 - 最简单的构造器"></a>二、默认构造器 - 最简单的构造器</h4><p>默认构造器原理：返回一个所有属性都使用其原有默认值的一个实例</p>
<p>存在默认构造器的条件:</p>
<ol>
<li>定义变量的时候，就可以保证所有属性都有可用的值。</li>
<li>没有自定义的构造器</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age <span class="operator">=</span> <span class="number">18</span></span><br><span class="line">    <span class="keyword">var</span> gender <span class="operator">=</span> <span class="string">&quot;男&quot;</span></span><br><span class="line">    <span class="comment">//如果存在schoolName，那就必须添加一个构造器来确保没有默认值的schoolName也能赋值</span></span><br><span class="line">    <span class="comment">//let schoolName:String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ps <span class="operator">=</span> <span class="type">Person</span>() <span class="comment">//使用了默认构造器</span></span><br></pre></td></tr></table></figure>

<h4 id="二、逐一成员构造器：类中不存在，适用于结构体"><a href="#二、逐一成员构造器：类中不存在，适用于结构体" class="headerlink" title="二、逐一成员构造器：类中不存在，适用于结构体"></a>二、逐一成员构造器：类中不存在，适用于结构体</h4><p>结构体不会像类一样，对构造器给予限制，必须保证每个属性都可用，因为除了默认构造器，结构体还有逐一成员构造器，可以对每个属性进行设置;</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> height:<span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//let size = Size() //此时不满足默认构造器条件1，不能使用</span></span><br><span class="line"><span class="keyword">let</span> size1 <span class="operator">=</span> <span class="type">Size</span>(width: <span class="number">10</span>, height: <span class="number">10</span>) <span class="comment">//使用逐一成员构造器</span></span><br></pre></td></tr></table></figure>

<h4 id="三、自定义构造器：输入参数的形式构造实例，满足多种情况的需要"><a href="#三、自定义构造器：输入参数的形式构造实例，满足多种情况的需要" class="headerlink" title="三、自定义构造器：输入参数的形式构造实例，满足多种情况的需要"></a>三、自定义构造器：输入参数的形式构造实例，满足多种情况的需要</h4><ol>
<li>常量只能被赋值一次，所有如果定义常量时有默认值，即使是构造函数也不能修改此值</li>
<li>对于类的实例，它的常量属性只能在定义它的类的构造函数中修改，不能在子类中修改</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type <span class="operator">=</span> <span class="string">&quot;学生&quot;</span></span><br><span class="line">    <span class="keyword">let</span> name :<span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span> :<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="comment">//self.type = &quot;教师&quot;  //不能修改已经有默认值的常量属性</span></span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name  <span class="comment">//构造函数必须保证所有值可用，此处赋值操作必须有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、可选型属性在构造器中的使用"><a href="#四、可选型属性在构造器中的使用" class="headerlink" title="四、可选型属性在构造器中的使用"></a>四、可选型属性在构造器中的使用</h4><p>使用可选型是因为在业务逻辑上允许此属性为<code>nil</code>，包括两种情况如下：</p>
<ol>
<li>初始化的时候无法为其赋值,只能默认<code>nil</code>；</li>
<li>在后续使用中需要将其赋值为<code>nil</code>；</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span>?</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="comment">//以为age是可选型，存在默认值nil,所以构造函数不为其设置值也不报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="五、构造器代理"><a href="#五、构造器代理" class="headerlink" title="五、构造器代理"></a>五、构造器代理</h4><p>构造器通过调用其他构造器来完成实例的部分构造，被称为构造器代理,实现减少代码重复，构造器代理分为两种：</p>
<ul>
<li>值类型构造器代理：适用于值类型（结构体&#x2F;枚举），没有继承等复杂过程，较为简单</li>
<li>类构造器代理：因为有涉及到继承，需要保证所有继承属性也能正确的初始化（也即是便利构造器，见下篇）</li>
</ul>
<p>注意：</p>
<ol>
<li>对于值类型，可以在自定义构造器中使用self.init来调用其他构造器</li>
<li>如果值类型定义了自定义构造器将不能使用默认构造器和逐一成员构造器。解决办法：将自定义构造器写在扩展里，而不是值类型的原始定义中</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NewSize</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span> , height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">NewSize</span>()</span><br><span class="line">    <span class="comment">//构造器1：与默认构造函数一样，全部使用默认值</span></span><br><span class="line">    <span class="keyword">init</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器2: 与逐一成员构造器一样</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">origin</span>:<span class="type">Point</span>, <span class="params">size</span>:<span class="type">NewSize</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.origin <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size  <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器3：调用了构造器2方法</span></span><br><span class="line">    <span class="comment">//如果我们不去实现构造器2，将不能调用与其功能相似的逐一成员构造器</span></span><br><span class="line">    <span class="comment">//所以我们可以参考扩展，将自定义方法写在扩展中，就不必这样麻烦了</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">center</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">NewSize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX <span class="operator">=</span> center.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY <span class="operator">=</span> center.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift学习05-构造器(中)</title>
    <url>/2017/08/05/Swift%E5%AD%A6%E4%B9%A005-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%AD)/</url>
    <content><![CDATA[<p><strong>主要内容：</strong></p>
<ol>
<li>构造器简介</li>
<li>指定构造器和便利构造器</li>
<li>类的构造器的使用</li>
</ol>
<span id="more"></span>

<h4 id="一、构造器简介"><a href="#一、构造器简介" class="headerlink" title="一、构造器简介"></a>一、构造器简介</h4><p>本篇继续对<code>Swift</code>中的构造器进行介绍，这里主要说到类的继承和构造。 作为引用类型的类具有的继承特性，这使得类的构造过程较为复杂一些，因为涉及到很多细节性的问题。在使用之前，我们需要了解一些基本的问题：</p>
<ol>
<li>类中所有存储属性，包括继承父类的属性，都要在构造过程中设置初值</li>
<li><code>Swift</code>类的构造器分为指定构造器和便利构造器，确保完成构造过程</li>
</ol>
<h4 id="二、指定构造器和便利构造器"><a href="#二、指定构造器和便利构造器" class="headerlink" title="二、指定构造器和便利构造器"></a>二、指定构造器和便利构造器</h4><h5 id="指定构造器："><a href="#指定构造器：" class="headerlink" title="指定构造器："></a>指定构造器：</h5><ul>
<li>类的主要构造器，负责初始化类中所有属性，在继承关系中可调用父类链中的父类构造器;</li>
<li>每个类至少一个指定构造器。但是某些情况下，许多类是通过继承父类的指定构造器来满足这个条件;</li>
</ul>
<h5 id="便利构造器："><a href="#便利构造器：" class="headerlink" title="便利构造器："></a>便利构造器：</h5><ul>
<li>辅助类型的构造器，调用同一个类中的指定构造器完成类的初始化操作;</li>
<li>便利构造器需要在<code>init</code>关键字之前添加<code>convenience</code>关键字，使用空格分开;</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FatherClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> valueOne: <span class="type">Int</span></span><br><span class="line">    <span class="comment">//指定构造器</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">valueOne</span>: <span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.valueOne <span class="operator">=</span> valueOne</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span>: <span class="title class_ inherited__">FatherClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> valueTwo:<span class="type">Int</span> <span class="comment">//子类的新引入属性</span></span><br><span class="line">    <span class="comment">//指定构造器</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">valueOne</span>: <span class="type">Int</span> , <span class="params">valueTwo</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.valueTwo <span class="operator">=</span> valueTwo</span><br><span class="line">        <span class="comment">//先初始化新引入属性，再初始化超类</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(valueOne: valueOne)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//便利构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">valueOne</span>: <span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(valueOne: valueOne);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、类的构造器的使用"><a href="#三、类的构造器的使用" class="headerlink" title="三、类的构造器的使用"></a>三、类的构造器的使用</h4><p>关于类的构造器的使用在使用的时候，细节方面需要要注意很多，通过查找一些资料，现总结如下：</p>
<h5 id="1-指定构造器和便利构造器的基本使用原则："><a href="#1-指定构造器和便利构造器的基本使用原则：" class="headerlink" title="1. 指定构造器和便利构造器的基本使用原则："></a>1. 指定构造器和便利构造器的基本使用原则：</h5><ul>
<li>  当前类存在父类时，指定构造器器必须调用其直接父类的指定构造器，为保证继承的属性得以初始化;</li>
<li>  便利构造器必须调用同一类中定义的其他构造器。而且最终会导致一个指定构造器被调用;</li>
</ul>
<h5 id="2-Swift两段式构造过程"><a href="#2-Swift两段式构造过程" class="headerlink" title="2. Swift两段式构造过程"></a>2. Swift两段式构造过程</h5><p><code>Swift</code> 中类的构造过程包含两个阶段，被称为是二段式构造:</p>
<ol>
<li>第一阶段：每个存储型的值指定一个初值;</li>
<li>第二阶段：给当前类一个机会，在新实例准备使用之前进一步修改定制存储型的属性;</li>
</ol>
<p><strong>与OC的区别</strong>：<code>Swift</code>与<code>OC</code>的构造过程相似，区别在于阶段一，<code>OC</code>给每个属性赋值为<code>0</code>或者空值，但是<code>Swift</code>更为灵活，允许开发者指定自己所需的初始值(默认值);</p>
<h5 id="3-两段式构造需要注意的事项"><a href="#3-两段式构造需要注意的事项" class="headerlink" title="3. 两段式构造需要注意的事项"></a>3. 两段式构造需要注意的事项</h5><ul>
<li>指定构造器必须保证当前类新引入所有属性初始化完成之后，才能将其构造器任务继续向上代理给父类的构造器。</li>
<li>指定构造器必须先向上代理调用父类构造器，然后再为其继承的属性设置新值，否则，指定构造器赋予的新值将被父类中的构造器所覆盖。</li>
<li>便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。否则，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。</li>
<li>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self 作为一个值，因为此时还没构造有效实例。</li>
</ul>
<h5 id="4-总结两段式构造的详细流程"><a href="#4-总结两段式构造的详细流程" class="headerlink" title="4. 总结两段式构造的详细流程"></a>4. 总结两段式构造的详细流程</h5><p>第一阶段：</p>
<ul>
<li>某个指定构造器或便利构造器被调用。</li>
<li>完成新实例内存的分配，但此时内存还没有被初始化。</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li>
<li>指定构造器将调用父类的构造器，完成父类属性的初始化。这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。</li>
<li>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</li>
</ul>
<p>第二阶段：</p>
<ol>
<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等;</li>
<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用self;</li>
</ol>
<h4 id="四、构造器的继承与重写"><a href="#四、构造器的继承与重写" class="headerlink" title="四、构造器的继承与重写"></a>四、构造器的继承与重写</h4><p>与<code>OC</code>不同，<code>Swift</code>中的子类默认情况不会自动继承父类的构造器，这是因为子类可能有更多新增属性，直接调用父类的构造器，可能会有一些属性无法初始化为出现错误;         如果我们希望子类拥有一个或多个与父类相同的构造器，那么这相当于子类重写了父类的构造器，需要在重写方法前添加override修饰符。（override的作用是提示编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确）</p>
<p>注意：</p>
<ol>
<li>重写系统自带的默认构造器（虽然不是显式的），也要带上override修饰符;</li>
<li>重写父类指定构造器必须带上override，即使你的子类将父类的指定构造器重写成了便利构造器;</li>
<li>子类编写和父类便利构造器相匹配的子类构造器时，由于子类不能直接调用父类的便利构造器，并不能看做是对父类构造器的重写。所以子类中“重写”父类便利构造器时，不需要加override修饰符;</li>
</ol>
<h4 id="五、构造器的自动继承"><a href="#五、构造器的自动继承" class="headerlink" title="五、构造器的自动继承"></a>五、构造器的自动继承</h4><p>子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器还是是可以被自动继承的;</p>
<p>构造器的自动继承需要满足前提条件是：子类中引入的所有新属性都提供了默认值。</p>
<p>然后可分为两种情况：</p>
<h5 id="情况1-子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。"><a href="#情况1-子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。" class="headerlink" title="情况1:子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。"></a>情况1:子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> valueOne: <span class="type">Int</span></span><br><span class="line">    <span class="comment">//指定构造器</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">valueOne</span>: <span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.valueOne <span class="operator">=</span> valueOne</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="title class_ inherited__">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> valueTwo:<span class="type">Int</span>  <span class="operator">=</span> <span class="number">100</span> <span class="comment">//子类的新引入属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动继承了父类的构造器,这里被使用创建子类，子类新属性使用默认值</span></span><br><span class="line"><span class="keyword">let</span> subClass <span class="operator">=</span> <span class="type">SubClass</span>(valueOne: <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;subClass：(<span class="subst">\(subClass.valueOne)</span>) valueTwo(<span class="subst">\(subClass.valueTwo)</span>)&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="情况2：子类提供了所有父类指定构造器的实现-通过情况1继承过来的或者子类自定义实现-，此时子类将自动继承所有父类的便利构造器。"><a href="#情况2：子类提供了所有父类指定构造器的实现-通过情况1继承过来的或者子类自定义实现-，此时子类将自动继承所有父类的便利构造器。" class="headerlink" title="情况2：子类提供了所有父类指定构造器的实现(通过情况1继承过来的或者子类自定义实现)，此时子类将自动继承所有父类的便利构造器。"></a>情况2：子类提供了所有父类指定构造器的实现(通过情况1继承过来的或者子类自定义实现)，此时子类将自动继承所有父类的便利构造器。</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>:<span class="type">String</span>, <span class="params">age</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类的便利构造器</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">name</span>:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name:name, age:<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>: <span class="title class_ inherited__">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nickName:<span class="type">String</span>!</span><br><span class="line">    <span class="comment">//实现了父类中的指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(<span class="params">name</span>:<span class="type">String</span>, <span class="params">age</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name:name, age:age)</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age <span class="operator">+</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ps <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;zs&quot;</span>, age: <span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>自动继承注意：</p>
<ol>
<li>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。</li>
<li>对于情况 2，子类可以将父类的指定构造器实现为便利构造器。</li>
</ol>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift学习06-构造器(下)</title>
    <url>/2017/08/06/Swift%E5%AD%A6%E4%B9%A006-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%8B)/</url>
    <content><![CDATA[<p><strong>主要内容：</strong></p>
<ol>
<li>可失败的构造器</li>
<li>枚举类型可失败的构造器</li>
<li>构造失败的传递</li>
<li>重写一个可失败的构造器<span id="more"></span></li>
<li>可失败构造器<code>init!</code></li>
<li>必要构造器</li>
<li>通过闭包或函数设置属性的默认值</li>
</ol>
<h4 id="一、可失败的构造器"><a href="#一、可失败的构造器" class="headerlink" title="一、可失败的构造器"></a>一、可失败的构造器</h4><p>顾名思义，这是用于我们构造过程可能失败情况的构造器。失败的原因可能是给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。一个可失败构造器示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可失败构造器语法是init关键字后面添加问号即(init?) </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name :<span class="type">String</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">            <span class="comment">//其实Swift构造器并不支持返回值，因为构造器本来就是要确保对象能被正确构造。</span></span><br><span class="line">            <span class="comment">//所以这里使用return nil只是为了表明可失败构造器构造失败。          </span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//参数不为空，继续构造器得到可用的实例</span></span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>： </p>
<ol>
<li>可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同;</li>
<li>可失败构造器其实是在构造失败时创建一个类型为自身类型的可选类型的对象;</li>
</ol>
<h4 id="二、枚举类型可失败的构造器"><a href="#二、枚举类型可失败的构造器" class="headerlink" title="二、枚举类型可失败的构造器"></a>二、枚举类型可失败的构造器</h4><p>通过枚举类型可失败构造器获取枚举类型中特定的枚举成员，完成构造任务。如果提供的参数无法匹配任何枚举成员则构造失败。使用示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TestNum</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">First</span>, <span class="type">Second</span>, <span class="type">Third</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">number</span> : <span class="type">Character</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span> number&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">First</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Second</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Third</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同于以上的写法，swift中还可以使用带原始值的枚举类型可失败构造器。带原始值的枚举类型会自带一个可失败构造器init?(rawValue:)，这里名为rawValue的参数，其类型和枚举类型的原始值类型一致， 如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TestNum2</span>:<span class="title class_ inherited__">Character</span>&#123;</span><br><span class="line">    <span class="comment">//枚举值自带原始值</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">First</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>, <span class="type">Second</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>, <span class="type">Third</span> <span class="operator">=</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> number <span class="operator">=</span> <span class="type">TestNum2</span>(rawValue: <span class="string">&quot;6&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> number <span class="operator">==</span> <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;枚举类型构造失败&quot;</span>)<span class="comment">//此句被打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、构造失败的传递"><a href="#三、构造失败的传递" class="headerlink" title="三、构造失败的传递"></a>三、构造失败的传递</h4><p>与普通的构造器相似，可失败构造器也是可以代理的。这里包括类、结构体、枚举中的横向代理，也包括子类和父类之间的向上代理。</p>
<ol>
<li>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。</li>
<li>可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中；</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>!</span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CartItem</span>: <span class="title class_ inherited__">Product</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span>!</span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">quantity</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (quantity <span class="operator">&lt;</span> <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//验证quantity不符合要求，就立刻终止构造器，返回nil对象，剩余代码也不再执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        <span class="keyword">self</span>.quantity <span class="operator">=</span> quantity</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、重写一个可失败的构造器"><a href="#四、重写一个可失败的构造器" class="headerlink" title="四、重写一个可失败的构造器"></a>四、重写一个可失败的构造器</h4><p>既然是重写，这里主要是应用于类中。这里包括两种情况:</p>
<ol>
<li>用子类的可失败构造器重写父类的可失败构造器（这种情况针对于可能子类增加了更多的可失败处理）</li>
<li>用子类的非可失败构造器重写一个父类的可失败构造器。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重写一个可失败的构造器一个示例如下：</span></span><br><span class="line"><span class="comment">//父类Person:要求其name属性必须是非空字符串或者nil</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>?</span><br><span class="line">    <span class="comment">//该构造器可创建name属性是nil的Person实例</span></span><br><span class="line">    <span class="keyword">init</span>()&#123;&#125;</span><br><span class="line">    <span class="comment">//父类的可失败构造器，当传入参数为空的时候，不能创建有效实例</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span> :<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类Student:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;匿名&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子类的非可失败构造器init(name:)重写了父类的可失败构造器init?(name:)。</span></span><br><span class="line">    <span class="comment">//因为这里很好的处理了空字符串的情况，无论传入参数是否是空字符串，都将创建有效实例</span></span><br><span class="line">    <span class="comment">//注意：可以用非可失败构造器重写可失败构造器，但反过来却不行。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty&#123;</span><br><span class="line">            <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;匿名&quot;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类：Teacher:</span></span><br><span class="line"><span class="comment">//我们也可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器，具体使用如下:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>:<span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">&quot;匿名&quot;</span>)<span class="operator">!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里子类的非可失败构造器重写父类的可失败构造器</span></span><br><span class="line">    <span class="comment">//向上代理到父类的可失败构造器，并对父类的可失败构造器的返回值进行强制解包</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty&#123;</span><br><span class="line">            <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">&quot;匿名&quot;</span>)<span class="operator">!</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)<span class="operator">!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="五、可失败构造器init"><a href="#五、可失败构造器init" class="headerlink" title="五、可失败构造器init!"></a>五、可失败构造器init!</h4><p>区别于init?方式的可失败构造器，init!形式的可失败构造器器将创建一个对应类型的隐式解包可选型对象 init?和init!可以相互代理，也可以相互重写。我们也可以用init代理到init!,但是一旦init!构造失败，将触发断言</p>
<h4 id="六、必要构造器"><a href="#六、必要构造器" class="headerlink" title="六、必要构造器"></a>六、必要构造器</h4><p>在类的构造器前添加required修饰符表明所有该类的子类都必须实现该构造器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="title class_ inherited__">SuperClass</span> &#123;</span><br><span class="line">    <span class="comment">//1.子类重写父类的必要构造器，构造器前也必须添加required修饰符，表明该构造器要求也应用于继承链后面的子类。</span></span><br><span class="line">    <span class="comment">//2.但是这里虽然重写父类中必要的指定构造器时，却不需要添加override修饰符：</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">//构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="七、通过闭包或函数设置属性的默认值"><a href="#七、通过闭包或函数设置属性的默认值" class="headerlink" title="七、通过闭包或函数设置属性的默认值"></a>七、通过闭包或函数设置属性的默认值</h4><p>在构造过程中，我们可以使用闭包或全局函数为某个存储型属性提供定制的默认值。 在新实例被创建时，对应的闭包或函数会被调用，其返回值会当做默认值赋值给这个属性, 具体的时候用如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Weather</span> &#123;</span><br><span class="line">    <span class="comment">//常见的一些天气</span></span><br><span class="line">    <span class="keyword">let</span> commonWeather: [<span class="type">String</span>] <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> weather <span class="operator">=</span> [<span class="string">&quot;sunny&quot;</span>, <span class="string">&quot;cloud&quot;</span>,<span class="string">&quot;rain&quot;</span>,<span class="string">&quot;snow&quot;</span>];</span><br><span class="line">        <span class="keyword">return</span> weather</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printCommonWeather</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> commonWeather.count &#123;</span><br><span class="line">            <span class="built_in">print</span>(commonWeather[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weather <span class="operator">=</span> <span class="type">Weather</span>()<span class="comment">//同时初始化了默认属性</span></span><br><span class="line">weather.printCommonWeather()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift学习07-可选型</title>
    <url>/2017/08/07/Swift%E5%AD%A6%E4%B9%A007-%E5%8F%AF%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>顾名思义，可选类型表示一个变量可能有值，也可能没有值（nil），但是它的用法却与OC中的nil完全不同</strong></p>
<p>主要内容：</p>
<ol>
<li>可选型使用要点</li>
<li>可选型解包</li>
<li>可选链 <code>Option chaining</code><span id="more"></span></li>
<li>空合并运算符<code>nil coalesce</code></li>
<li>隐式可选型</li>
<li>可选型使用的其他示例</li>
<li>最后小结</li>
</ol>
<h4 id="一、可选型使用要点"><a href="#一、可选型使用要点" class="headerlink" title="一、可选型使用要点"></a>一、可选型使用要点</h4><ol>
<li>可选类型类似于<code>OC</code>指针的<code>nil</code>值，但是<code>OC</code>中的<code>nil</code>只对类有用，而可选择型中<code>nil</code>对所有类型都可用，更安全</li>
<li>可选型的声明的方式是<code>“数据类型+问号”</code>。如：<code>var errorCode :Int? = 404</code></li>
<li>当要使用一个可选类型的变量时，要在后面加感叹号<code>“!”</code>或者<code>“?”</code>。</li>
<li>不能把一个可选型便量赋值给非可选型的变量, 如：<code>let tempValue = nil</code>，这样会报错；</li>
<li>可选型数据一般都是可变的，所以可选型的数据也通常是变量；</li>
<li>声明一个可选型的时候，必须是添加？,swift不能隐式的自动推断可选型；</li>
</ol>
<p><code>swift</code>不能用同类中的一个特殊值代表无或者没有，在<code>Swift</code>中，<code>nil</code>代表着没有，但是它却不能直接使用，示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> errorCode :<span class="type">Int</span> <span class="operator">=</span> <span class="number">404</span></span><br><span class="line">errorCode <span class="operator">=</span> <span class="literal">nil</span> <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改：使用Int?  声明一个整型可选型</span></span><br><span class="line"><span class="keyword">var</span> errorCode :<span class="type">Int</span>? <span class="operator">=</span> <span class="number">404</span></span><br><span class="line">errorCode <span class="operator">=</span> <span class="literal">nil</span> <span class="comment">//将其声明为为可选型变量才能赋值为nil</span></span><br></pre></td></tr></table></figure>

<h4 id="二、可选型解包"><a href="#二、可选型解包" class="headerlink" title="二、可选型解包"></a>二、可选型解包</h4><p>一个可选型数据，就意味着其值是可以为<code>nil</code>的，这样的数据不可以直接使用，所以将可选型解包后再使用是十分重要的操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接使用</span></span><br><span class="line"><span class="keyword">var</span> errorCode: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;404&quot;</span></span><br><span class="line"><span class="built_in">print</span>(errorCode)</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;The errorCode is&quot; +errorCode //直接使用显式可选型会编译不通过，报错</span></span><br></pre></td></tr></table></figure>

<h5 id="1-解包方法1：普通的if判断，但不方便"><a href="#1-解包方法1：普通的if判断，但不方便" class="headerlink" title="1.解包方法1：普通的if判断，但不方便"></a>1.解包方法1：普通的if判断，但不方便</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(errorCode <span class="operator">!=</span> <span class="literal">nil</span>)&#123;</span><br><span class="line">    <span class="string">&quot;The errorCode is &quot;</span> <span class="operator">+</span> errorCode<span class="operator">!</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="string">&quot;No error&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-解包方法2：强制解包，使用感叹号“-”，存在错误风险"><a href="#2-解包方法2：强制解包，使用感叹号“-”，存在错误风险" class="headerlink" title="2.解包方法2：强制解包，使用感叹号“!”，存在错误风险"></a>2.解包方法2：强制解包，使用感叹号“!”，存在错误风险</h5><p>一般情况下，我们在确定使用的可选型变量不会是nil，才通过!强制解包并使用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> errorCode: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;404&quot;</span></span><br><span class="line"><span class="string">&quot;The errorCode is &quot;</span> <span class="operator">+</span> errorCode<span class="operator">!</span></span><br></pre></td></tr></table></figure>

<h5 id="3-解包方法3：尝试解包，使用问号“？”，较为安全"><a href="#3-解包方法3：尝试解包，使用问号“？”，较为安全" class="headerlink" title="3.解包方法3：尝试解包，使用问号“？”，较为安全"></a>3.解包方法3：尝试解包，使用问号“？”，较为安全</h5><p>当不确定使用的可选型变量是否是nil,通过?执行调用方法等操作，意味着不为nil时才可以执行成功</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> errorCode: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;404&quot;</span></span><br><span class="line"><span class="string">&quot;The errorCode is &quot;</span> <span class="operator">+</span> errorCode？</span><br></pre></td></tr></table></figure>

<h5 id="4-解包方法4：if-let解包-当我们希望在可选型为nil时候，执行别的代码，此时更适合使用if-let方式解包"><a href="#4-解包方法4：if-let解包-当我们希望在可选型为nil时候，执行别的代码，此时更适合使用if-let方式解包" class="headerlink" title="4.解包方法4：if-let解包, 当我们希望在可选型为nil时候，执行别的代码，此时更适合使用if-let方式解包"></a>4.解包方法4：if-let解包, 当我们希望在可选型为nil时候，执行别的代码，此时更适合使用if-let方式解包</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> unwrappedErrorCode <span class="operator">=</span> errorCode&#123;</span><br><span class="line">    <span class="comment">//unwrappedErrorCode 是经过解包的数据，得到非nil值</span></span><br><span class="line">    <span class="string">&quot;The errorCode is&quot;</span> <span class="operator">+</span> unwrappedErrorCode</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">------------</span>优美的分割线<span class="operator">-----------------</span></span><br><span class="line"> <span class="comment">//if-let解包方法的改进：可以使用原来的变量名</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorCode <span class="operator">=</span> errorCode&#123;</span><br><span class="line">    <span class="comment">//errorCode 是经过解包的数据，得到非nil值</span></span><br><span class="line">    <span class="comment">//括号内的errorCode 只在此括号内使用</span></span><br><span class="line">    <span class="string">&quot;The errorCode is&quot;</span> <span class="operator">+</span> errorCode</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//处理nil情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-解包时注意事项："><a href="#5-解包时注意事项：" class="headerlink" title="5.解包时注意事项："></a>5.解包时注意事项：</h5><p>隐式声明的可选型不需要解包，但是这样可能因为nil报错（详情请看第五部分）</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> blog:<span class="type">String</span>! <span class="operator">=</span> <span class="string">&quot;helloWord&quot;</span></span><br><span class="line"><span class="comment">//blog = nil </span></span><br><span class="line"><span class="string">&quot;My blog is&quot;</span> <span class="operator">+</span> blog</span><br></pre></td></tr></table></figure>

<p>if-let可以同时解包多个变量，而且因为使用了if，也可以增加判断逻辑</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorCode <span class="operator">=</span> errorCode, errorMessage <span class="operator">=</span> </span><br><span class="line">                  errorMessage <span class="keyword">where</span> errorCode <span class="operator">==</span> <span class="string">&quot;404&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Page not found&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、可选链-Option-chaining"><a href="#三、可选链-Option-chaining" class="headerlink" title="三、可选链 Option chaining"></a>三、可选链 Option chaining</h4><p>可选链的使用简化了可选型的使用。在某些情况下可以避免<code>if-let</code> 解包的使用，而是通过尝试解包（使用问号<code>？</code>）或者强制解包（感叹号<code>!</code>）来使用操作对象 示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> errorCodeStr: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;Hello, playground&quot;</span></span><br><span class="line"><span class="comment">//errorCodeStr.uppercaseString ; errorCodeStr是可选型不能直接使用，需要解包如下：</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorCodeStr <span class="operator">=</span> errorCodeStr&#123;</span><br><span class="line">    errorCodeStr.uppercaseString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码使用可选链简化，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法:使用？尝试解包，如果成功就会将字符串大写</span></span><br><span class="line">errorCodeStr<span class="operator">?</span>.uppercaseString</span><br><span class="line"><span class="comment">//不安全写法，当errorCode为nil时报错，除非我们确保errorCodeStr不为nil才能这样写</span></span><br><span class="line">errorCodeStr<span class="operator">!</span>.uppercaseString</span><br></pre></td></tr></table></figure>

<p>基于这样的使用，可能会出现类似 <code>Person?.address?.addressName</code> 的使用，这就构成了可选链,调用链中任何一个节点为<code>nil</code>,整个调用都会失败，返回<code>nil</code>，使用<code>？</code>是安全的;</p>
<h4 id="四、空合并运算符nil-coalesce"><a href="#四、空合并运算符nil-coalesce" class="headerlink" title="四、空合并运算符nil coalesce"></a>四、空合并运算符nil coalesce</h4><p>使用空合并运算符，可以解决解包之后的存值问题</p>
<h5 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uppperCaseErrorStr <span class="operator">=</span> errorCodeStr<span class="operator">?</span>.uppercaseString</span><br><span class="line"><span class="comment">//uppperCaseErrorStr此时是一个可选型变量，不需要显示声明，因为后面的表达式是可选型</span></span><br><span class="line"><span class="comment">//实现解包同时实现了大写</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorCodeStr  <span class="operator">=</span> errorCodeStr<span class="operator">?</span>.uppercaseString&#123;</span><br><span class="line">    errorCodeStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> errorMessage <span class="operator">=</span> errorMessage&#123;</span><br><span class="line">    message <span class="operator">=</span> errorMessage</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    message <span class="operator">=</span> <span class="string">&quot;no error&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="改进示例2：使用三目运算符"><a href="#改进示例2：使用三目运算符" class="headerlink" title="改进示例2：使用三目运算符"></a>改进示例2：使用三目运算符</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message2 <span class="operator">=</span> errorMessage <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> <span class="string">&quot;no errror&quot;</span> :errorMessage;</span><br></pre></td></tr></table></figure>

<p>改进示例2:使用空合并运算符??，如果errorMessage有值，使用errorMessage!赋值</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//？？是空和并运算符</span></span><br><span class="line"><span class="keyword">let</span> message3 <span class="operator">=</span> errorMessage <span class="operator">??</span> <span class="string">&quot;no error&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="五、隐式可选型"><a href="#五、隐式可选型" class="headerlink" title="五、隐式可选型"></a>五、隐式可选型</h4><ol>
<li>区别于显式可选型的创建：类型+<code>？</code>，创建隐式可选型使用：类型+<code>！</code></li>
<li>隐式可选型变量使用时，相当于其后面自带了一个感叹号，可以直接赋值给一个非可选型变量，但是隐式可选型依然保持可选型的特性，可以被赋值为<code>nil</code>，这就体现出来隐式可选类型的优点,即可用被赋值为<code>nil</code>，也可以不用每次显式的解包</li>
<li>隐式解析可选类型还可以在类中做属性，解决循环引用问题</li>
</ol>
<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage: <span class="type">String</span>! <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">errorMessage <span class="operator">=</span> <span class="string">&quot;not found&quot;</span></span><br><span class="line"><span class="comment">//这里errorMessage是隐式可选型，使用时候不需要显式的解包，但是如果errorMessage为nil就会报错</span></span><br><span class="line"><span class="string">&quot;The error is &quot;</span> <span class="operator">+</span> errorMessage</span><br></pre></td></tr></table></figure>

<h4 id="六、可选型使用的其他示例"><a href="#六、可选型使用的其他示例" class="headerlink" title="六、可选型使用的其他示例"></a>六、可选型使用的其他示例</h4><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1."></a>示例1.</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> error1:(errorCode: <span class="type">Int</span>, errorMessage: <span class="type">String</span>?) <span class="operator">=</span> (<span class="number">404</span> , <span class="string">&quot;page not found&quot;</span>)</span><br><span class="line">error1.errorMessage <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">//error1 = nil 整个元组并非可选型，不能使用nil赋值</span></span><br></pre></td></tr></table></figure>

<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2."></a>示例2.</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ageInt: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;xyz&quot;</span></span><br><span class="line"><span class="comment">//使用强制转换之后，age是可选型，需要按照可选型的规则去使用</span></span><br><span class="line"><span class="keyword">var</span> age <span class="operator">=</span> <span class="type">Int</span>(ageInt)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> age <span class="operator">=</span> age <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">20</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;you are a tennager!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3."></a>示例3.</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">//rangeString 返回一个可选型，需要按照可选型的规则去使用</span></span><br><span class="line">greeting.rangeOfString(<span class="string">&quot;ll&quot;</span>) <span class="comment">//2..&lt;4</span></span><br><span class="line">greeting.rangeOf3String(<span class="string">&quot;oo&quot;</span>)<span class="comment">//nil</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="七、最后小结"><a href="#七、最后小结" class="headerlink" title="七、最后小结"></a>七、最后小结</h4><ol>
<li>有了可选型，你在声明隐式可选变量或特性的时候就不用指定初始值，因为它有缺省值nil。尤其是在一个创建一个类的属性的时候。</li>
<li>由于隐式解析可选的值会在使用时自动解析，所以没必要使用操作符!来解析它。但是有可能运行时报错。</li>
<li>使用可选链会选择性的执行隐式解析可选表达式上的某一个操作。如果值为nil，就不会执行任何操作，因此也不会产生运行错误。</li>
<li>非可选型的变量或者常量不可能赋值为nil，所以不能使用：notOptioalValue !&#x3D; nil,判断是否nil。这是可选型和非可选型数据的一个明显区别</li>
</ol>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift学习08-泛型</title>
    <url>/2017/08/08/Swift%E5%AD%A6%E4%B9%A008-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>Swift泛型</strong>：允许根据自定义的需求，编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图；</p>
<p><strong>主要内容：</strong></p>
<ol>
<li>泛型解决的问题</li>
<li>泛型函数</li>
<li>泛型类型<span id="more"></span></li>
<li>扩展一个泛型类型</li>
<li>泛型的类型约束</li>
<li>关联类型</li>
</ol>
<h4 id="一、泛型解决的问题"><a href="#一、泛型解决的问题" class="headerlink" title="一、泛型解决的问题"></a>一、泛型解决的问题</h4><p><code>Swift</code>泛型代码让你能够根据自定义的需求，编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图。这种说法很模糊，下面我们结合一个示例来说明泛型的作用。</p>
<p>需求描述：使用函数来交换两个变量的值</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//互换两个整型</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInt</span>(<span class="params">a</span>:<span class="keyword">inout</span> <span class="type">Int</span> , <span class="params">b</span>:<span class="keyword">inout</span> <span class="type">Int</span>)&#123;</span><br><span class="line">    (a, b) <span class="operator">=</span> (b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换两个Double</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoDouble</span>(<span class="params">a</span>:<span class="keyword">inout</span> <span class="type">Double</span>, <span class="params">b</span>:<span class="keyword">inout</span> <span class="type">Double</span>)&#123;</span><br><span class="line">    (a,b) <span class="operator">=</span> (b,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析： <code>swapTwoInt</code>与<code>swapTwoDouble</code>两个函数功能相同，唯一的区别就是传入的变量类型不同。这样的代码看起来重复又累赘。在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。</p>
<h4 id="二、泛型函数"><a href="#二、泛型函数" class="headerlink" title="二、泛型函数"></a>二、泛型函数</h4><p>泛型函数可以适用于任何类型，下面的<code>swapTwoValues(_:_:)</code>函数是上面两个函数的泛型版本,可以交换任意类型的两个变量。</p>
<p>尖括号里声明一种通用类型T，参数列表里可以使用这种类型名表示通用类型</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">SwapTwoThing</span>&lt;<span class="type">T</span>&gt;(<span class="params">a</span>:<span class="keyword">inout</span> <span class="type">T</span>, <span class="params">b</span>:<span class="keyword">inout</span> <span class="type">T</span>)&#123;</span><br><span class="line">    (a, b) <span class="operator">=</span> (b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="operator">=</span> <span class="number">200</span></span><br><span class="line">swapTwoInt(a: <span class="operator">&amp;</span>a , b: <span class="operator">&amp;</span>b)</span><br><span class="line">a  <span class="comment">//200</span></span><br><span class="line">b  <span class="comment">//100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> string1 <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> string2 <span class="operator">=</span> <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="type">SwapTwoThing</span>(a: <span class="operator">&amp;</span>string1, b: <span class="operator">&amp;</span>string2)</span><br><span class="line">string1  <span class="comment">//world</span></span><br><span class="line">string2  <span class="comment">//hello</span></span><br></pre></td></tr></table></figure>

<p>总结泛型函数的使用：</p>
<ol>
<li>使用了占位类型名(<code>T</code>)，来替换实际类型名<code>(Int，Double)</code>；</li>
<li>占位类型符并不指定<code>T</code>必须是什么类型，但是却限制了参数<code>a</code>和<code>b</code>必须是同一种类型T；</li>
<li>只有<code>SwapTwoValues&lt;T&gt;(_:_)</code>函数在调用时，才能根据所传入的实际类型决定<code>T</code>所代表的类型；</li>
<li><code>T</code>只是一个符号，可以使用大写字母开头的驼峰命名法（例如<code>T</code>和<code>MyTypeParameter</code>)来为类型参数命名，以表明它们是占位类型，而不是一个值。</li>
</ol>
<h4 id="三、泛型类型"><a href="#三、泛型类型" class="headerlink" title="三、泛型类型"></a>三、泛型类型</h4><h5 id="3-1-系统类型使用到的泛型"><a href="#3-1-系统类型使用到的泛型" class="headerlink" title="3.1.系统类型使用到的泛型"></a>3.1.系统类型使用到的泛型</h5><p>事实上，泛型类型的使用贯穿了<code>Swift</code>语言。例如，<code>Swift</code>的<code>Array</code>和<code>Dictionary</code>都是泛型集合。你可以创建一个<code>Int</code>数组，也可创建一个<code>String</code>数组。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> dict <span class="operator">=</span> <span class="type">Dictionary</span>&lt;<span class="type">String</span>,<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span>  <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">Float</span>&gt;()</span><br></pre></td></tr></table></figure>

<h5 id="3-2-自定义泛型类型：实现一个栈结构体"><a href="#3-2-自定义泛型类型：实现一个栈结构体" class="headerlink" title="3.2.自定义泛型类型：实现一个栈结构体"></a>3.2.自定义泛型类型：实现一个栈结构体</h5><p>除了泛型函数，Swift还允许你定义泛型类型；这些自定义类、结构体和枚举可以适用于任何类型，类似于Array和 Dictionary。下面的示例就是创建一个具有栈功能的结构体，适用于各种类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="type">Element</span>&gt;&#123;</span><br><span class="line">    <span class="comment">//存放栈中变量的数组</span></span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">Element</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈：向栈中添加一个新元素</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="params">item</span>:<span class="type">Element</span>)&#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈：删除栈顶元素,并返回此元素</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt;<span class="type">Element</span>?&#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">stack.push(item: <span class="number">11</span>)</span><br><span class="line">stack.push(item: <span class="number">22</span>)</span><br><span class="line">stack.pop()   <span class="comment">//22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stack1 <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stack1.push(item:<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">stack1.push(item:<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">stack1.pop()  <span class="comment">//“bbb&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-自定义泛型类型：多个占位符"><a href="#3-3-自定义泛型类型：多个占位符" class="headerlink" title="3.3.自定义泛型类型：多个占位符"></a>3.3.自定义泛型类型：多个占位符</h5><p>自定义泛型类型可以设置多个类型占位符，下面就是自定义了一个泛型类型Pair，它具有两个占位类型符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;<span class="type">T1</span>, <span class="type">T2</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">var</span> t1:<span class="type">T1</span></span><br><span class="line">    <span class="keyword">var</span> t2:<span class="type">T2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pair1 <span class="operator">=</span> <span class="type">Pair</span>(t1: <span class="string">&quot;hello&quot;</span>, t2: <span class="string">&quot;hi&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(pair1)   <span class="comment">//Pair&lt;String, String&gt;(t1: &quot;hello&quot;, t2: &quot;hi&quot;)</span></span><br><span class="line"><span class="keyword">var</span> pair2:<span class="type">Pair</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">Pair</span>(t1:<span class="string">&quot;hello&quot;</span>,t2: <span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(pair2)   <span class="comment">//Pair&lt;String, Int&gt;(t1: &quot;hello&quot;, t2: 123)</span></span><br></pre></td></tr></table></figure>

<h4 id="四、扩展一个泛型类型"><a href="#四、扩展一个泛型类型" class="headerlink" title="四、扩展一个泛型类型"></a>四、扩展一个泛型类型</h4><p>扩展一个泛型类型，可以直接使用原始类型定义中声明的类型参数列表，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。 比如，我们现在扩展泛型类型Stack，为其添加计算型属性topItem，用于获取栈顶元素，代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="comment">//返回当前栈顶元素而不会将其从栈中移除</span></span><br><span class="line">    <span class="keyword">var</span> topItem: <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> items.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : items[items.count <span class="operator">-</span> <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stack3 <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">stack3.push(item:<span class="number">1</span>)</span><br><span class="line">stack3.push(item:<span class="number">2</span>)</span><br><span class="line">stack3.push(item: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> topItem <span class="operator">=</span> stack3.topItem&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;栈顶元素:<span class="subst">\(topItem)</span>&quot;</span>)   <span class="comment">//栈顶元素:3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：扩展中的占位类型符需要与原始类保持一致，所以这里用的还是Element。</p>
<h4 id="五、泛型的类型约束"><a href="#五、泛型的类型约束" class="headerlink" title="五、泛型的类型约束"></a>五、泛型的类型约束</h4><p><code>swapTwoValues(_:_:)</code>函数和<code>Stack</code>类型可以作用于任何类型。但如果可以为泛型函数和泛型类型的类型添加一个特定的类型约束，将会是非常有用的。 通常情况下，我们设置泛型类型约束的时候，会指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。</p>
<h5 id="5-1-类型约束语法"><a href="#5-1-类型约束语法" class="headerlink" title="5.1.类型约束语法"></a>5.1.类型约束语法</h5><p>对泛型函数添加类型约束的基本语法如下所示(作用于泛型类型时的语法与之相同)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>&lt;<span class="type">T</span>: <span class="type">SomeClass</span>, <span class="type">U</span>: <span class="type">SomeProtocol</span>&gt;(<span class="params">someT</span>: <span class="type">T</span>, <span class="params">someU</span>: <span class="type">U</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里是泛型函数的函数体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-泛型类型约束实践"><a href="#5-2-泛型类型约束实践" class="headerlink" title="5.2.泛型类型约束实践"></a>5.2.泛型类型约束实践</h5><p>下面的泛型函数用于查找数组中某个元素的索引位置；但由于for循环里用到了对象比较”&#x3D;&#x3D;”，要确保所有的类型都适用，所以在泛型函数的中添加了类型约束，使用此泛型函数的参数必须遵循<code>Equatable</code>协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>: <span class="type">Equatable</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> doubleIndex <span class="operator">=</span> findIndex(of: <span class="number">9.3</span>, in: [<span class="number">3.14159</span>, <span class="number">0.1</span>, <span class="number">0.25</span>])  <span class="comment">//nil</span></span><br><span class="line"><span class="keyword">let</span> stringIndex <span class="operator">=</span> findIndex(of: <span class="string">&quot;Andrea&quot;</span>, in: [<span class="string">&quot;Mike&quot;</span>, <span class="string">&quot;Malcolm&quot;</span>, <span class="string">&quot;Andrea&quot;</span>]) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>注意：Swift标准库定义了Equatable协议，该协议要求任何遵循该协议的类型必须实现等式符（&#x3D;&#x3D;）及不等符(!&#x3D;)。从而能对该类型的任意两个值进行比较。所有的Swift标准类型自动支持 Equatable 协议</p>
<h4 id="六、关联类型"><a href="#六、关联类型" class="headerlink" title="六、关联类型"></a>六、关联类型</h4><p>关联类型是在为协议中的某个类型提供一个占位名，其所代表的实际类型会在协议被采纳时才会被指定。这里涉及到两个关键字，其作用就是给一个类型起一个别名，首先来说明一下：</p>
<ul>
<li><strong>associatedtype</strong>：协议声明中使用</li>
<li><strong>typealias</strong>：协议实现中使用</li>
</ul>
<p>下面通过一个示例来理解关联类型的作用：定义一个可称重的协议，其中使用了泛型关联类型。这种方式可以更大程度的使用协议，具体实现协议的时候再决定类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">WeightCaclulable</span>&#123;</span><br><span class="line">    <span class="comment">//associatedtype设置别名，即关联类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">WeightType</span></span><br><span class="line">    <span class="keyword">var</span> weight:<span class="type">WeightType</span>&#123;<span class="keyword">get</span>&#125; <span class="comment">//返回重量属性，其类型是WeightType</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//iphone7:手机较轻，表示重量时会有小数点，所以使用Double描述</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iphone7</span>:<span class="title class_ inherited__">WeightCaclulable</span>&#123;</span><br><span class="line">    <span class="comment">//实现的时候用的是typealias</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">WeightType</span>  <span class="operator">=</span> <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.114</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Ship:轮船较重,表示重量可以忽略小数，所以使用Int描述</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ship</span>:<span class="title class_ inherited__">WeightCaclulable</span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">WeightType</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">WeightType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">weight</span>:<span class="type">WeightType</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.weight <span class="operator">=</span> weight</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iphone7 <span class="operator">=</span> <span class="type">Iphone7</span>()</span><br><span class="line"><span class="built_in">print</span>(iphone7.weight)  <span class="comment">//0.114</span></span><br><span class="line"><span class="keyword">let</span> ship <span class="operator">=</span> <span class="type">Ship</span>(weight: <span class="number">100000</span>)</span><br><span class="line"><span class="built_in">print</span>(ship.weight)     <span class="comment">//100000</span></span><br></pre></td></tr></table></figure>

<h5 id="6-1-关联类型添加约束"><a href="#6-1-关联类型添加约束" class="headerlink" title="6.1.关联类型添加约束"></a>6.1.关联类型添加约束</h5><p>协议中存在关联类型，我们也可以为其添加约束，下面是一个<code>Container</code>协议，我们设置其关联类型<code>Item</code>遵循了协议<code>Equatable</code>，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span>: <span class="type">Equatable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift学习09-扩展</title>
    <url>/2017/08/09/Swift%E5%AD%A6%E4%B9%A009-%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p><strong>扩展</strong>：就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力(即逆向建模 )</p>
<p><strong>主要内容：</strong></p>
<ol>
<li>理解扩展</li>
<li>扩展的基本使用</li>
<li>嵌套类型</li>
<li>扩展系统类库</li>
</ol>
<span id="more"></span>

<h4 id="一、理解扩展"><a href="#一、理解扩展" class="headerlink" title="一、理解扩展"></a>一、理解扩展</h4><h5 id="1-1-扩展特点："><a href="#1-1-扩展特点：" class="headerlink" title="1.1.扩展特点："></a>1.1.扩展特点：</h5><ol>
<li>扩展和 <code>Objective-C</code> 中的分类类似，但与之不同的是，<code>Swift</code> 的扩展没有名字；</li>
<li>扩展可以为一个类型添加新的功能，但是不能重写已有的功能；</li>
</ol>
<h5 id="1-2-扩展功能："><a href="#1-2-扩展功能：" class="headerlink" title="1.2.扩展功能："></a>1.2.扩展功能：</h5><ol>
<li>添加计算型实例属性和计算型类型属性。</li>
<li>定义实例方法和类型方法</li>
<li>提供新便利构造器和便利析构器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议”</li>
</ol>
<h5 id="1-3-使用注意："><a href="#1-3-使用注意：" class="headerlink" title="1.3.使用注意："></a>1.3.使用注意：</h5><ol>
<li>不可以添加存储属性，也不可以为已有属性添加属性观察器</li>
<li>扩展中不能为类添加新的指定构造器，因为指定构造器和析构器必须由原始的类来实现</li>
<li>扩展可以为一个类型添加新的功能，但是不能重写已有的功能。</li>
<li>通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。</li>
</ol>
<h4 id="二、扩展的基本使用"><a href="#二、扩展的基本使用" class="headerlink" title="二、扩展的基本使用"></a>二、扩展的基本使用</h4><p>定义如下的<code>Point</code> 、<code>Size</code>、<code>Rectangle</code>，并对其进行扩展。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span>  <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin:<span class="type">Point</span> <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">init</span> (<span class="params">origin</span>:<span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.origin <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-扩展属性"><a href="#2-1-扩展属性" class="headerlink" title="2.1.扩展属性"></a>2.1.扩展属性</h5><p>扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="comment">//注意：扩展不能扩展存储型属性</span></span><br><span class="line">    <span class="comment">//var center:Point = Point() //报错</span></span><br><span class="line">    <span class="comment">//只能扩展计算型属性</span></span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> center_x <span class="operator">=</span> origin.x <span class="operator">+</span> size.width<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            <span class="keyword">let</span> center_y <span class="operator">=</span> origin.y <span class="operator">+</span> size.height<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: center_x, y: center_y)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newValue.x <span class="operator">-</span> size.width<span class="operator">/</span><span class="number">2</span></span><br><span class="line">            origin.y <span class="operator">=</span> newValue.y <span class="operator">-</span> size.height<span class="operator">/</span><span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rect1 <span class="operator">=</span> <span class="type">Rectangle</span>(origin: <span class="type">Point</span>(x:<span class="number">0</span>,y:<span class="number">0</span>), size: <span class="type">Size</span>(width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line"><span class="built_in">print</span>(rect1.center)              <span class="comment">//Point(x: 50.0, y: 50.0)</span></span><br><span class="line">rect1.center <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(rect1.center)              <span class="comment">//Point(x: 0.0, y: 0.0)</span></span><br></pre></td></tr></table></figure>

<h5 id="2-2-扩展方法"><a href="#2-2-扩展方法" class="headerlink" title="2.2.扩展方法"></a>2.2.扩展方法</h5><p>扩展可以为已有类型添加新的实例方法和类型方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="comment">//注意：这里直接修改了属性，如果是结构体Struct，不能直接这样修改</span></span><br><span class="line">    <span class="comment">//func之前需要使用 mutating</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">translate</span>(<span class="params">x</span>:<span class="type">Double</span> , <span class="params">y</span>:<span class="type">Double</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.origin.x <span class="operator">+=</span> x</span><br><span class="line">        <span class="keyword">self</span>.origin.y <span class="operator">+=</span> y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rect2  <span class="operator">=</span> <span class="type">Rectangle</span>(origin: <span class="type">Point</span>(x:<span class="number">0</span>,y:<span class="number">0</span>), size: <span class="type">Size</span>(width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">rect2.translate(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(rect2.center)     <span class="comment">//Point(x: 150.0, y: 150.0)</span></span><br></pre></td></tr></table></figure>

<h5 id="2-3-扩展构造器"><a href="#2-3-扩展构造器" class="headerlink" title="2.3.扩展构造器"></a>2.3.扩展构造器</h5><p>扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现提供.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="comment">//注意：在扩展中添加了构造函数，必须是便利构造函数，其中调用指定构造函数</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">center</span>:<span class="type">Point</span>, <span class="params">size</span>:<span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> origin_x <span class="operator">=</span> center.x <span class="operator">-</span> size.width<span class="operator">/</span><span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> origin_y <span class="operator">=</span> center.y <span class="operator">-</span> size.height<span class="operator">/</span><span class="number">2</span></span><br><span class="line">        <span class="comment">//便利构造函数必须调用指定构造函数</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin:<span class="type">Point</span>(x: origin_x, y: origin_y),size:size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rect3 <span class="operator">=</span> <span class="type">Rectangle</span>(center: <span class="type">Point</span>(x:<span class="number">200</span>, y:<span class="number">200</span>), size: <span class="type">Size</span>(width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p>**注意1：**如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。</p>
<p>**注意2：**如果你使用扩展为一个值类型添加构造器，同时该值类型的原始实现中未定义任何定制的构造器且所有存储属性提供了默认值，那么我们就可以在扩展中的构造器里调用默认构造器和逐一成员构造器。</p>
<h5 id="2-4-扩展下标"><a href="#2-4-扩展下标" class="headerlink" title="2.4.扩展下标"></a>2.4.扩展下标</h5><p>扩展可以为已有类型添加新下标。下面的例子为Swift内建类型Int添加了一个整型下标。该下标 [n] 返回十进制数字从右向左数的第n个数字：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">digitIndex</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> decimalBase <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>digitIndex &#123;</span><br><span class="line">            decimalBase <span class="operator">*=</span> <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span> <span class="operator">/</span> decimalBase) <span class="operator">%</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//测试代码：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">746381295</span>[<span class="number">3</span>]) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">746381295</span>[<span class="number">6</span>]) <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<h4 id="三、嵌套类型"><a href="#三、嵌套类型" class="headerlink" title="三、嵌套类型"></a>三、嵌套类型</h4><p>扩展可以为已有的类、结构体和枚举添加新的嵌套类型。在下面的示例中，<code>Rectangle</code>中就嵌套一个枚举类型，用以获取矩形的各个定点坐标。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Vertex</span>:<span class="title class_ inherited__">Int</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">TopLeft</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">TopRight</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">BottomLeft</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">BottomRight</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展出一个方法来获取各个顶点坐标</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">pointAtVertex</span>(<span class="params">v</span>:<span class="type">Vertex</span>) -&gt; <span class="type">Point</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> v &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">TopLeft</span>:</span><br><span class="line">            <span class="keyword">return</span> origin</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">TopRight</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: origin.x <span class="operator">+</span> size.width, y: origin.y)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">BottomLeft</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: origin.x, y: origin.y <span class="operator">+</span> size.height)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">BottomRight</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: origin.x <span class="operator">+</span> size.width, y: origin.y <span class="operator">+</span> size.height)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展下标</span></span><br><span class="line">    <span class="keyword">subscript</span> (<span class="params">index</span>:<span class="type">Int</span>) -&gt;<span class="type">Point</span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(index <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> index<span class="operator">&lt;</span><span class="number">4</span>,<span class="string">&quot;out of range&quot;</span>)</span><br><span class="line">        <span class="comment">//修改枚举的原始值是Int类型，而这里🈶使用rowValue方法构建了枚举型</span></span><br><span class="line">        <span class="keyword">return</span> pointAtVertex(v: <span class="type">Vertex</span>(rawValue: index)<span class="operator">!</span>)  <span class="comment">//已经使用了断言，这里使用强制解包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码：</span></span><br><span class="line"><span class="keyword">let</span> rect4  <span class="operator">=</span> <span class="type">Rectangle</span>(origin: <span class="type">Point</span>(x:<span class="number">0</span>,y:<span class="number">0</span>), size: <span class="type">Size</span>(width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line"><span class="keyword">let</span> point1 <span class="operator">=</span> rect4.pointAtVertex(v: .<span class="type">TopRight</span>)</span><br><span class="line"><span class="built_in">print</span>(point1)    <span class="comment">//Point(x: 100.0, y: 0.0)</span></span><br><span class="line"><span class="keyword">let</span> point2 <span class="operator">=</span> rect4.pointAtVertex(v: <span class="type">Rectangle</span>.<span class="type">Vertex</span>.<span class="type">BottomRight</span>)</span><br><span class="line"><span class="built_in">print</span>(point2)    <span class="comment">//Point(x: 100.0, y: 0.0)</span></span><br><span class="line"><span class="keyword">let</span> point3 <span class="operator">=</span> rect4[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(point3)    <span class="comment">//Po</span></span><br></pre></td></tr></table></figure>

<h4 id="四、扩展系统类库"><a href="#四、扩展系统类库" class="headerlink" title="四、扩展系统类库"></a>四、扩展系统类库</h4><h5 id="4-1-扩展Double"><a href="#4-1-扩展Double" class="headerlink" title="4.1.扩展Double"></a>4.1.扩展Double</h5><p>扩展<code>Double</code>，为其添加计算型属性，提供与距离单位协作的基本支持。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> m : <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">100.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">3.28084</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//测试代码：</span></span><br><span class="line"><span class="keyword">let</span> distance1 <span class="operator">=</span> <span class="number">25.4</span>.mm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;distance1 is <span class="subst">\(distance1)</span> meters&quot;</span>)    <span class="comment">//distance1 is 0.0254 meters</span></span><br><span class="line"><span class="keyword">let</span> distance2 <span class="operator">=</span> <span class="number">42</span>.mm <span class="operator">+</span> <span class="number">1</span>.km</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;disatance2 is <span class="subst">\( distance2)</span> meters&quot;</span>)  <span class="comment">//disatance2 is 1000.042 meters</span></span><br></pre></td></tr></table></figure>

<h5 id="4-2-扩展Int类"><a href="#4-2-扩展Int类" class="headerlink" title="4.2.扩展Int类"></a>4.2.扩展Int类</h5><p>扩展Int，为其添加平方、立方、范围判断等方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span>&#123;</span><br><span class="line">    <span class="comment">//平方运算</span></span><br><span class="line">    <span class="keyword">var</span> square:<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//立方运算</span></span><br><span class="line">    <span class="keyword">var</span> cube:<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断整型是否在某个范围内</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">inRange</span>(<span class="params">closedLeft</span>:<span class="type">Int</span>, <span class="params">opendRight</span>:<span class="type">Int</span>) -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">&gt;=</span> closedLeft <span class="operator">&amp;&amp;</span> <span class="keyword">self</span> <span class="operator">&lt;</span> opendRight</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过传入一个闭包参数，简单的实现循环操作</span></span><br><span class="line">   <span class="keyword">func</span>  <span class="title function_">repetitions</span>(<span class="params">task</span>: () -&gt; <span class="type">Void</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span>&#123;</span><br><span class="line">        <span class="comment">//执行闭包</span></span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//测试代码：</span></span><br><span class="line"><span class="keyword">var</span> tempNum <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">tempNum.square()        <span class="comment">//100</span></span><br><span class="line">tempNum.inRange(closedLeft: <span class="number">10</span>, opendRight: <span class="number">100</span>)   <span class="comment">//false</span></span><br><span class="line">tempNum.repetitions &#123;</span><br><span class="line">    <span class="built_in">print</span>(tempNum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift学习10-协议</title>
    <url>/2017/08/10/Swift%E5%AD%A6%E4%B9%A010-%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p><strong>协议</strong>：是定义一些规范(属性、功能方法)，然后由类、结构体或者枚举遵循并实现这些规范，这一过程被称为遵循了协议；</p>
<p><strong>主要内容：</strong></p>
<ol>
<li>协议的基本语法</li>
<li>定义协议与实现协议</li>
<li>协议与构造器</li>
<li>协议作为类型<span id="more"></span></li>
<li>协议实现委托代理模式</li>
<li>通过扩展遵循协议</li>
<li>协议类型的集合</li>
<li>协议继承协议</li>
<li>类类型专属协议</li>
<li>协议合成</li>
<li>检查协议的一致性</li>
<li>协议的可选性</li>
<li>协议扩展</li>
</ol>
<h4 id="一、协议的基本语法"><a href="#一、协议的基本语法" class="headerlink" title="一、协议的基本语法"></a>一、协议的基本语法</h4><p>下面是协议的一些基本语法：</p>
<h5 id="1-定义一个协议"><a href="#1-定义一个协议" class="headerlink" title="1.定义一个协议"></a>1.定义一个协议</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="comment">//这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AnotherProtocol</span>&#123;</span><br><span class="line">    <span class="comment">//这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-自定义类型遵循协议使用冒号，遵循多个协议时，各协议间使用逗号分隔"><a href="#2-自定义类型遵循协议使用冒号，遵循多个协议时，各协议间使用逗号分隔" class="headerlink" title="2.自定义类型遵循协议使用冒号，遵循多个协议时，各协议间使用逗号分隔"></a>2.自定义类型遵循协议使用冒号，遵循多个协议时，各协议间使用逗号分隔</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStructure</span>: <span class="title class_ inherited__">SomeProtocol</span>, <span class="title class_ inherited__">AnotherProtocol</span> &#123;</span><br><span class="line">    <span class="comment">//这里是结构体的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-拥有父类的类在遵循协议时，需要将父类名放在协议名之前，以逗号分隔"><a href="#3-拥有父类的类在遵循协议时，需要将父类名放在协议名之前，以逗号分隔" class="headerlink" title="3.拥有父类的类在遵循协议时，需要将父类名放在协议名之前，以逗号分隔"></a>3.拥有父类的类在遵循协议时，需要将父类名放在协议名之前，以逗号分隔</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>: <span class="title class_ inherited__">SomeSuperClass</span>, <span class="title class_ inherited__">SomeProtocol</span>, <span class="title class_ inherited__">AnotherProtocol</span> &#123;</span><br><span class="line">    <span class="comment">//这里是类的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、定义协议与实现协议"><a href="#二、定义协议与实现协议" class="headerlink" title="二、定义协议与实现协议"></a>二、定义协议与实现协议</h4><p>协议可以要求遵循协议的类型提供特定的<strong>属性</strong>、<strong>方法</strong>，<strong>构造器</strong>。如果协议中的属性和方法没有实现，就会报错；除此之外，我们还需要注意一些具体的使用规则如下： <strong>属性要求：</strong></p>
<ol>
<li>协议可以定义实例属性和类型属性(使用static);</li>
<li>协议不指定属性是存储属性还是计算型属性，只指定属性名称和类型以及读写性;</li>
<li>协议指定属性的读取类型，使用的get和set，中间不能使用逗号；</li>
<li>协议总是使用var关键字来声明变量属性;</li>
<li>不能给协议属性设置默认值，因为默认值被看做是一种实现;</li>
</ol>
<p><strong>方法要求：</strong></p>
<ol>
<li>协议可以定义实例方法和类方法(使用static);</li>
<li>协议定义函数时不能添加函数的实现，同时，传入的参数也不能使用默认参数；</li>
<li>如果协议定义的实例方法会改变实例本身，需要在定义的方法名前使用mutating；这使得结构体和枚举能够遵循此协议并满足此方法要求。</li>
</ol>
<p>下面具体演示一个协议的使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span>  <span class="title class_">PersonProtocol</span>&#123;</span><br><span class="line">    <span class="comment">//1.定义属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> personCount: <span class="type">Int</span> &#123;<span class="keyword">get</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> nickName:<span class="type">String</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125; <span class="comment">//要求可读可写，则该属性不能是常量属性或者只读的计算型属性</span></span><br><span class="line">    <span class="keyword">var</span> birthPlace:<span class="type">String</span>&#123;<span class="keyword">get</span>&#125;   <span class="comment">//只要求可读，若代码需要，实现时也是可写的</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.定义函数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">play</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">eat</span>(<span class="params">food</span>:<span class="type">String</span>)</span><br><span class="line">    <span class="comment">//func fed(food:string = &quot;defaultfood”) 错误，不能使用默认参数</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">changeNickName</span>(<span class="params">newName</span>:<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>:<span class="title class_ inherited__">PersonProtocol</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> personCount <span class="operator">=</span> <span class="number">0</span>        <span class="comment">//类属性</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> nickName: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>          <span class="comment">//这种形式的声明就代表可读可写</span></span><br><span class="line">    <span class="keyword">let</span> birthPlace: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;beijing&quot;</span> <span class="comment">//将只读属性设置为let，在合适位置给其设置默认值就好了</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="comment">//其实，只读类型的属性也可以设置为var,这相当于是对其进行扩展，不仅遵循了原来的get，还增加了set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">play</span>() &#123;</span><br><span class="line">        <span class="comment">//类方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">eat</span>(<span class="params">food</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="comment">//普通实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">changeNickName</span>(<span class="params">newName</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="comment">//实例方法中修改了实例属性</span></span><br><span class="line">        <span class="keyword">self</span>.nickName <span class="operator">=</span> newName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码：</span></span><br><span class="line"><span class="keyword">var</span> student:<span class="type">Student</span> <span class="operator">=</span> <span class="type">Student</span>()</span><br><span class="line">student.age <span class="operator">=</span> <span class="number">18</span></span><br><span class="line"><span class="keyword">var</span> stu:<span class="type">PersonProtocol</span> <span class="operator">=</span> student <span class="comment">//这里协议也当做了一种类型来使用，但是具体的实现还是是Dog完成的</span></span><br><span class="line"><span class="comment">//stu.age = 10 //这里报错，因为协议中的age是只读的</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。</strong></p>
<h4 id="三、协议与构造器"><a href="#三、协议与构造器" class="headerlink" title="三、协议与构造器"></a>三、协议与构造器</h4><p>这里主要总结协议在定义构造器时候的一些要求，主要有如下几个方面：</p>
<ol>
<li>协议中可设置指定或者便利构造器,实现时都需要添加<code>required</code>修饰符,因为这样可以确保所有子类也必须提供此构造器，从而符合协议，但是如果为<code>final</code>类，就不需要；</li>
<li>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符；</li>
<li>协议中可定义可失败构造器(<code>init?</code>)、非可失败构造器(<code>init</code>)、隐式解包可失败构造器(<code>init!</code>)；</li>
</ol>
<p>下面是协议与构造器使用的相关示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Protocol</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSubClass</span>: <span class="title class_ inherited__">SomeSuperClass</span>, <span class="title class_ inherited__">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 因为遵循协议，需要加上 required</span></span><br><span class="line">    <span class="comment">// 因为继承自父类，需要加上 override</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、协议作为类型"><a href="#四、协议作为类型" class="headerlink" title="四、协议作为类型"></a>四、协议作为类型</h4><p>协议虽本身并未实现任何功能，但是仍然可以像其他普通类型一样使用,如<code>Int</code>、<code>Double</code>等。协议作为类型使用的场景如下：</p>
<ol>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ol>
<p>下面演示协议类型的使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//协议：定义了生成随机数方法</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">RandomNumberGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>() -&gt; <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现了RandomNumberGenerator协议的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinearCongruentialGenerator</span>: <span class="title class_ inherited__">RandomNumberGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lastRandom <span class="operator">=</span> <span class="number">42.0</span></span><br><span class="line">    <span class="keyword">let</span> m <span class="operator">=</span> <span class="number">139968.0</span></span><br><span class="line">    <span class="keyword">let</span> a <span class="operator">=</span> <span class="number">3877.0</span></span><br><span class="line">    <span class="keyword">let</span> c <span class="operator">=</span> <span class="number">29573.0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>() -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="comment">//使用truncatingRemainder方法进行浮点数取余</span></span><br><span class="line">        lastRandom <span class="operator">=</span> (lastRandom <span class="operator">*</span> a <span class="operator">+</span> c).truncatingRemainder(dividingBy: m)</span><br><span class="line">        <span class="keyword">return</span> lastRandom <span class="operator">/</span> m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Dice的generator属性，其类型是RandomNumberGenerator协议类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dice</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sides: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> generator: <span class="type">RandomNumberGenerator</span>    <span class="comment">//协议作为属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//协议作为参数类型</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">sides</span>: <span class="type">Int</span>, <span class="params">generator</span>: <span class="type">RandomNumberGenerator</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sides <span class="operator">=</span> sides</span><br><span class="line">        <span class="keyword">self</span>.generator <span class="operator">=</span> generator</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">roll</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(generator.random() <span class="operator">*</span> <span class="type">Double</span>(sides)) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d6 <span class="operator">=</span> <span class="type">Dice</span>(sides: <span class="number">6</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Random dice roll is <span class="subst">\(d6.roll())</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Random dice roll is 3</span></span><br><span class="line"><span class="comment">//Random dice roll is 5</span></span><br><span class="line"><span class="comment">//Random dice roll is 4</span></span><br><span class="line"><span class="comment">//Random dice roll is 5</span></span><br><span class="line"><span class="comment">//Random dice roll is 4</span></span><br></pre></td></tr></table></figure>

<h4 id="五、协议实现委托代理模式"><a href="#五、协议实现委托代理模式" class="headerlink" title="五、协议实现委托代理模式"></a>五、协议实现委托代理模式</h4><p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。</p>
<p>委托模式：</p>
<ul>
<li>作用：用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型；</li>
<li>原理：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能；</li>
</ul>
<p>下面例子演示了通过协议实现代理模式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//播放音乐的协议</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">PlayMusicTools</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">playMusic</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现协议的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QQMusisApp</span>:<span class="title class_ inherited__">PlayMusicTools</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">playMusic</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(“播放一首美妙的音乐<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Person&#123;</span></span><br><span class="line"><span class="string">    var delegate:PlayMusicTools?</span></span><br><span class="line"><span class="string">    func listenMusic()&#123;</span></span><br><span class="line"><span class="string">        self.delegate?.playMusic()</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//人想听音乐但是又不能自己播放，就调用了代理的方法</span></span><br><span class="line"><span class="string">let person:Person = Person()</span></span><br><span class="line"><span class="string">person.delegate = QQMusisApp()</span></span><br><span class="line"><span class="string">person.listenMusic()</span></span><br></pre></td></tr></table></figure>

<h4 id="六、通过扩展遵循协议"><a href="#六、通过扩展遵循协议" class="headerlink" title="六、通过扩展遵循协议"></a>六、通过扩展遵循协议</h4><p>我们知道，扩展可以为已有类型添加属性、方法、下标以及构造器。同样道理，我们也可以通过扩展为已有类型实现需要遵循的协议，通过这种方法与在原始定义中遵循并实现协议效果完全相同。</p>
<h5 id="6-1-通过扩展实现协议"><a href="#6-1-通过扩展实现协议" class="headerlink" title="6.1.通过扩展实现协议"></a>6.1.通过扩展实现协议</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//协议：定义一个可以打印UIView属性fame的方法</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">ViewProperty</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printFrame</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过扩展为UIView实现了ViewProperty协议</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">UIView</span>:<span class="title class_ inherited__">ViewProperty</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printFrame</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">self</span>.frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">view.printFrame()</span><br></pre></td></tr></table></figure>

<h5 id="6-2-已经符合协议的类"><a href="#6-2-已经符合协议的类" class="headerlink" title="6.2.已经符合协议的类"></a>6.2.已经符合协议的类</h5><p>如果一个类型已经符合了某个协议的所有要求，却还没有声明遵循这个协议，那么可以通过空扩展来遵循协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomObject</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printFrame</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is not a view，cant print frame&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空扩展表示遵循协议</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">CustomObject</span>:<span class="title class_ inherited__">ViewProperty</span>&#123;&#125;</span><br><span class="line"><span class="comment">//遵循了协议之后，就可以使用协议作为类型</span></span><br><span class="line"><span class="keyword">let</span> customOject:<span class="type">ViewProperty</span> <span class="operator">=</span> <span class="type">CustomObject</span>()</span><br><span class="line">customOject.printFrame()</span><br></pre></td></tr></table></figure>

<h4 id="七、协议类型的集合"><a href="#七、协议类型的集合" class="headerlink" title="七、协议类型的集合"></a>七、协议类型的集合</h4><p>协议类型可以在数组或者字典这样的集合中使用；如下，等号左边的数组表示遵循了<code>ViewProperty</code>协议的对象构成的数组。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> things:[<span class="type">ViewProperty</span>] <span class="operator">=</span> [view,customOject]</span><br><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things&#123;</span><br><span class="line">    thing.printFrame()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//(0.0, 0.0, 100.0, 100.0)</span></span><br><span class="line"><span class="comment">//this is not a view，cant print frame</span></span><br></pre></td></tr></table></figure>

<h4 id="八、协议继承协议"><a href="#八、协议继承协议" class="headerlink" title="八、协议继承协议"></a>八、协议继承协议</h4><p>协议继承协议具有以下特点：</p>
<ol>
<li>协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。</li>
<li>协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：</li>
<li>所有遵循新协议的类型，也同时满足新协议所继承的父协议</li>
</ol>
<p>协议继承协议的格式如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">InheritingProtocol</span>: <span class="title class_ inherited__">SomeProtocol</span>, <span class="title class_ inherited__">AnotherProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="九、类类型专属协议"><a href="#九、类类型专属协议" class="headerlink" title="九、类类型专属协议"></a>九、类类型专属协议</h4><p>协议的继承列表中，通过添加 <code>class</code> 关键字来限制协议只能被类类型遵循，而结构体或枚举不能遵循该协议。<code>class</code> 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeClassOnlyProtocol</span>: <span class="keyword">class</span>, <span class="title class_ inherited__">SomeInheritedProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是类类型专属协议的定义部分</span></span><br><span class="line">    <span class="comment">//class 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="十、协议合成"><a href="#十、协议合成" class="headerlink" title="十、协议合成"></a>十、协议合成</h4><p>有时候需要同时遵循多个协议，你可以将多个协议采用<code>SomeProtocol &amp; AnotherProtocol</code>这样的格式进行组合，称为协议合成(<code>protocol composition</code>)；你可以罗列任意多个你想要遵循的协议，以与符号(<code>&amp;</code>)分隔。</p>
<p>下面的例子中，将 <code>Named</code> 和 <code>Aged</code> 两个协议按照上述语法组合成一个协议，作为函数参数的类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Named</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Aged</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person遵循两个协议</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>: <span class="title class_ inherited__">Named</span>, <span class="title class_ inherited__">Aged</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数参数celebrator的类型为 Name &amp; Aged；</span></span><br><span class="line"><span class="comment">//这意味着它不关心参数的具体类型，只要参数符合这两个协议即可；</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">wishHappyBirthday</span>(<span class="params">to</span> <span class="params">celebrator</span>: <span class="type">Named</span> &amp; <span class="type">Aged</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Happy birthday, <span class="subst">\(celebrator.name)</span>, you&#x27;re <span class="subst">\(celebrator.age)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> birthdayPerson <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Malcolm&quot;</span>, age: <span class="number">21</span>)</span><br><span class="line">wishHappyBirthday(to: birthdayPerson)      <span class="comment">//打印 “Happy birthday Malcolm - you&#x27;re 21!”</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个只在局部作用域有效的临时协议中</strong></p>
<h4 id="十一、检查协议的一致性"><a href="#十一、检查协议的一致性" class="headerlink" title="十一、检查协议的一致性"></a>十一、检查协议的一致性</h4><p>类型转换中描述的is和as操作符同样可以用来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同：</p>
<ul>
<li><strong>is</strong>：用来检查实例是否符合某个协议，若符合则返回 true，否则返回 false。</li>
<li><strong>as?</strong>： 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil。</li>
<li><strong>as!</strong>：将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义协议：定义一个Double类型的可读属性area</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">HasArea</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Circle类和Country类遵循协议HasArea</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="title class_ inherited__">HasArea</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pi <span class="operator">=</span> <span class="number">3.1415927</span></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">return</span> pi <span class="operator">*</span> radius <span class="operator">*</span> radius &#125; <span class="comment">//计算型</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">radius</span>: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.radius <span class="operator">=</span> radius &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Country</span>: <span class="title class_ inherited__">HasArea</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> <span class="comment">//存储型</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">area</span>: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.area <span class="operator">=</span> area &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Animal未遵循协议</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> legs: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">legs</span>: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.legs <span class="operator">=</span> legs &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objects: [<span class="type">AnyObject</span>] <span class="operator">=</span> [</span><br><span class="line">    <span class="type">Circle</span>(radius: <span class="number">2.0</span>),</span><br><span class="line">    <span class="type">Country</span>(area: <span class="number">243_610</span>),</span><br><span class="line">    <span class="type">Animal</span>(legs: <span class="number">4</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代测试，并检测协议</span></span><br><span class="line"><span class="keyword">for</span> object <span class="keyword">in</span> objects &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> objectWithArea <span class="operator">=</span> object <span class="keyword">as?</span> <span class="type">HasArea</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Area is <span class="subst">\(objectWithArea.area)</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something that doesn&#x27;t have an area&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Area is 12.5663708</span></span><br><span class="line"><span class="comment">// Area is 243610.0</span></span><br><span class="line"><span class="comment">// Something that doesn&#x27;t have an area”</span></span><br></pre></td></tr></table></figure>

<h4 id="十二、协议的可选性"><a href="#十二、协议的可选性" class="headerlink" title="十二、协议的可选性"></a>十二、协议的可选性</h4><p><strong>协议可以定义可选要求，即遵循协议的类型可以选择是否实现这些要求。</strong></p>
<ol>
<li>在协议中使用<code>optional</code>关键字作为前缀来定义可选要求。</li>
<li>可选要求用在你需要和<code>Objective-C</code>打交道的代码中。协议和可选要求都必须带上<code>@objc</code>属性。</li>
<li>标记<code>@objc</code>特性的协议只能被继承自<code>Objective-C</code>类的类或者<code>@objc</code>类遵循，其他类以及结构体和枚举均不能遵循这种协议；</li>
<li>协议中的可选要求可通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求；</li>
</ol>
<p>下面的例子定义了一个名为<code>Counter</code>的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由<code>CounterDataSource</code>协议定义，包含两个可选要求：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.协议CounterDataSource包含两个可选要求</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">protocol</span> <span class="title class_">CounterDataSource</span> &#123;</span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">optional</span> <span class="keyword">func</span> <span class="title function_">incrementForCount</span>(<span class="params">count</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">optional</span> <span class="keyword">var</span> fixedIncrement: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Counter类含有CounterDataSource?类型的可选属性dataSource</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> dataSource: <span class="type">CounterDataSource</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">increment</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> amount <span class="operator">=</span> dataSource<span class="operator">?</span>.incrementForCount<span class="operator">?</span>(count: count) &#123;</span><br><span class="line">            count <span class="operator">+=</span> amount</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> amount <span class="operator">=</span> dataSource<span class="operator">?</span>.fixedIncrement &#123;</span><br><span class="line">             <span class="comment">//通过可选链调用，每次使用的是fixedIncrement的3</span></span><br><span class="line">            count <span class="operator">+=</span> amount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.ThreeSource类遵循了CounterDataSource协议</span></span><br><span class="line"><span class="comment">//它实现了可选属性fixedIncrement，而并未实现incrementForCount方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreeSource</span>: <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">CounterDataSource</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fixedIncrement <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.使用ThreeSource实例作为Counter实例的数据源对象</span></span><br><span class="line"><span class="keyword">var</span> counter <span class="operator">=</span> <span class="type">Counter</span>()</span><br><span class="line">counter.dataSource <span class="operator">=</span> <span class="type">ThreeSource</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">4</span> &#123;</span><br><span class="line">    counter.increment()</span><br><span class="line">    <span class="built_in">print</span>(counter.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试结果：</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//9</span></span><br><span class="line"><span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<p>注意：严格来讲，<code>CounterDataSource</code>协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要求，尽管技术上允许这样做，不过最好不要这样写；</p>
<h4 id="十三、协议扩展"><a href="#十三、协议扩展" class="headerlink" title="十三、协议扩展"></a>十三、协议扩展</h4><p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。</p>
<p>下面的代码演示了协议扩展的用法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//协议：定义random函数生成随机数方法</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">RandomNumProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>() -&gt; <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展RandomNumProtocol协议，增加了randomBool方法</span></span><br><span class="line"><span class="comment">//注意：通过协议扩展，所有遵循协议的类型都能自动获得这个扩展所增加的方法实现，无需任何额外修改</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">RandomNumProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">randomBool</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random() <span class="operator">&gt;</span> <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遵循协议的类：一个实现了RandomNumProtocol协议的类</span></span><br><span class="line"><span class="comment">//RandomNum类只实现了协议方法random()，但是同样可以使用协议扩展里的方法randomBool()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomNum</span>: <span class="title class_ inherited__">RandomNumProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lastRandom <span class="operator">=</span> <span class="number">42.0</span></span><br><span class="line">    <span class="keyword">let</span> m <span class="operator">=</span> <span class="number">139968.0</span></span><br><span class="line">    <span class="keyword">let</span> a <span class="operator">=</span> <span class="number">3877.0</span></span><br><span class="line">    <span class="keyword">let</span> c <span class="operator">=</span> <span class="number">29573.0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>() -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="comment">//使用truncatingRemainder方法进行浮点数取余</span></span><br><span class="line">        lastRandom <span class="operator">=</span> (lastRandom <span class="operator">*</span> a <span class="operator">+</span> c).truncatingRemainder(dividingBy: m)</span><br><span class="line">        <span class="keyword">return</span> lastRandom <span class="operator">/</span> m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试代码：</span></span><br><span class="line"><span class="keyword">let</span> generator <span class="operator">=</span> <span class="type">RandomNum</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here&#x27;s a random number: <span class="subst">\(generator.random())</span>&quot;</span>)</span><br><span class="line"><span class="comment">//打印：Here&#x27;s a random number: 0.37464991998171</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;And here&#x27;s a random Boolean: <span class="subst">\(generator.randomBool())</span>&quot;</span>)</span><br><span class="line"><span class="comment">//打印：And here&#x27;s a random Boolean: true</span></span><br></pre></td></tr></table></figure>

<h5 id="13-1-提供默认实现"><a href="#13-1-提供默认实现" class="headerlink" title="13.1.提供默认实现"></a>13.1.提供默认实现</h5><p>可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。但是，如果遵循协议的类型也为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。</p>
<p>注意：通过协议扩展为协议要求提供的默认实现，这和可选的协议要求不同；虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//协议：一个宠物协议，定义发出声音的方法makeSound</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">PetProtocol</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeSound</span>()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展协议：提供默认方法实现</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">PetProtocol</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeSound</span>()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;aaaaaa。。。。&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="title class_ inherited__">PetProtocol</span>&#123;</span><br><span class="line">     <span class="comment">//因为有协议扩展，已经提供了默认的方法实现；所以这里只遵循了协议</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:<span class="title class_ inherited__">PetProtocol</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeSound</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;汪汪汪。。。。&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试代码：</span></span><br><span class="line"><span class="keyword">let</span> cat <span class="operator">=</span> <span class="type">Cat</span>();</span><br><span class="line">cat.makeSound();  <span class="comment">//打印：aaaaaa。。。。</span></span><br><span class="line"><span class="keyword">let</span> dog <span class="operator">=</span> <span class="type">Dog</span>();</span><br><span class="line">dog.makeSound()   <span class="comment">//打印：汪汪汪。。。。</span></span><br></pre></td></tr></table></figure>

<h5 id="13-2-为协议扩展添加限制条件"><a href="#13-2-为协议扩展添加限制条件" class="headerlink" title="13.2.为协议扩展添加限制条件"></a>13.2.为协议扩展添加限制条件</h5><p>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 <code>where</code>子句来描述 例如:你可以扩展<code>Collection</code>协议，通过限制集合元素遵循<code>Equatable</code> 协议， 作为标准库的一部分，你可以使用&#x3D;&#x3D;和!&#x3D;操作符来检查两个元素的等价性和非等价性；</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Collection</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">allEqual</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> element <span class="operator">!=</span> <span class="keyword">self</span>.first &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果集合中的所有元素都一致，allEqual()方法才返回 true</span></span><br><span class="line"><span class="keyword">let</span> equalNumbers <span class="operator">=</span> [<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>]</span><br><span class="line"><span class="built_in">print</span>(equalNumbers.allEqual())      <span class="comment">//打印 &quot;true&quot;</span></span><br><span class="line"><span class="keyword">let</span> differentNumbers <span class="operator">=</span> [<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line"><span class="built_in">print</span>(differentNumbers.allEqual())  <span class="comment">//打印 &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。</strong></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS底层-Block捕获变量原理分析</title>
    <url>/2019/04/13/iOS%E5%BA%95%E5%B1%82-Block%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><strong>主要内容：</strong></p>
<ol>
<li>分析<code>Block</code>捕获外部变量的过程</li>
<li>理解<code>Block</code>修改外部变量的限制</li>
<li>分析<code>__block</code>存储域类说明符的原理<span id="more"></span></li>
<li>理解<code>__block</code>变量的存储域</li>
<li>探究<code>Block</code>对对象的捕获过程</li>
<li><code>Block</code>的循环引用问题</li>
</ol>
<h4 id="一、分析Block捕获外部变量的过程"><a href="#一、分析Block捕获外部变量的过程" class="headerlink" title="一、分析Block捕获外部变量的过程"></a>一、分析Block捕获外部变量的过程</h4><p>为了保证<code>Block</code>内部能够正常访问外部的变量，<code>Block</code>有一个变量捕获机制，即<code>Block</code>语法表达式所使用变量可以被保存到<code>Block</code>的结构体实例(<code>Block</code>自身)中。</p>
<p>关于捕获，<code>Block</code>对不同的外部变量的处理有所不同，根据<code>OC</code>中使用变量的分类，大概包括以下几种情况：</p>
<ol>
<li>函数参数(这里研究<code>Block</code>捕获，所以此处不涉及)</li>
<li>局部变量(简称：自动变量)</li>
<li>静态局部变量(常简称，静态变量)</li>
<li>全局变量</li>
<li>静态全局变量</li>
</ol>
<p>那么，现在对<code>Block</code>捕获外部变量的四种情况进行测试，相关代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用如下的命令，可将OC代码编译为C++代码</span></span><br><span class="line"><span class="comment">//clang -rewrite-objc main.m</span></span><br><span class="line"></span><br><span class="line">int global_val <span class="operator">=</span> <span class="number">1</span>;                  <span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">static</span> int static_global_val <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">//静态全局变量</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    int val <span class="operator">=</span> <span class="number">1</span>;                     <span class="comment">//自动变量</span></span><br><span class="line">    <span class="keyword">static</span> int static_val <span class="operator">=</span> <span class="number">1</span>;       <span class="comment">//局部静态变量</span></span><br><span class="line">    </span><br><span class="line">    void (<span class="operator">^</span>myBlock)(void) <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        global_val <span class="operator">++</span>;</span><br><span class="line">        static_global_val <span class="operator">++</span>;</span><br><span class="line">        static_val <span class="operator">++</span>;</span><br><span class="line">        <span class="comment">//val++//直接修改会报错(Variable is not assignable (missing __block type specifier)</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;<span class="subst">\n</span>Block内:<span class="subst">\n</span>global_val = %d,<span class="subst">\n</span>static_global_val = %d,<span class="subst">\n</span>val = %d,<span class="subst">\n</span>static_val= %d&quot;</span>,global_val,static_global_val,val,static_val);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    global_val <span class="operator">++</span>;</span><br><span class="line">    static_global_val <span class="operator">++</span>;</span><br><span class="line">    val <span class="operator">++</span>;</span><br><span class="line">    static_val <span class="operator">++</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;<span class="subst">\n</span>Block外:<span class="subst">\n</span>global_val = %d,<span class="subst">\n</span>static_global_val = %d,<span class="subst">\n</span>val = %d,<span class="subst">\n</span>static_val= %d&quot;</span>,global_val,static_global_val,val,static_val);</span><br><span class="line">    myBlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行的结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Block外</span>:</span><br><span class="line">global_val <span class="operator">=</span> <span class="number">2</span>,</span><br><span class="line">static_global_val <span class="operator">=</span> <span class="number">2</span>,</span><br><span class="line">val <span class="operator">=</span> <span class="number">2</span>,</span><br><span class="line">static_val<span class="operator">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="type">Block内</span>:</span><br><span class="line">global_val <span class="operator">=</span> <span class="number">3</span>,</span><br><span class="line">static_global_val <span class="operator">=</span> <span class="number">3</span>,</span><br><span class="line">val <span class="operator">=</span> <span class="number">1</span>,</span><br><span class="line">static_val<span class="operator">=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>分析运行结果，我们会发现以上四种情况中，只有<code>静态局部变量</code>、<code>静态全局变量</code>、<code>全局变量</code>可以在<code>Block</code>里被修改，而且直接修改<code>自动变量</code>就会报错；</p>
<p>此时，考虑以下两个问题：</p>
<ol>
<li>为什么在<code>Block</code>里不允许更改自动变量？</li>
<li><code>Block</code>捕获不同的变量并修改时，有什么区别吗？</li>
</ol>
<p>为了具体分析，现在将上述代码转化为<code>C++</code>的源码，转换后的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">int global_val <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> int static_global_val <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span><span class="operator">*</span> <span class="type">Desc</span>;</span><br><span class="line">  int <span class="operator">*</span>static_val;  <span class="comment">//对应静态局部变量</span></span><br><span class="line">  int val;          <span class="comment">//对应自动变量</span></span><br><span class="line">  __main_block_impl_0(void <span class="operator">*</span>fp, <span class="keyword">struct</span> __main_block_desc_0 <span class="operator">*</span>desc, int <span class="operator">*</span>_static_val, int _val, int flags<span class="operator">=</span><span class="number">0</span>) : static_val(_static_val), val(_val) &#123;</span><br><span class="line">    impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> <span class="operator">=</span> flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> <span class="operator">=</span> fp;</span><br><span class="line">    <span class="type">Desc</span> <span class="operator">=</span> desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 <span class="operator">*</span>__cself) &#123;</span><br><span class="line">  int <span class="operator">*</span>static_val <span class="operator">=</span> __cself-&gt;static_val; <span class="comment">// bound by copy</span></span><br><span class="line">  int val <span class="operator">=</span> __cself-&gt;val; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        global_val <span class="operator">++</span>;</span><br><span class="line">        static_global_val <span class="operator">++</span>;</span><br><span class="line">        (<span class="operator">*</span>static_val) <span class="operator">++</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_78fd5a_mi_0,global_val,static_global_val,val,(<span class="operator">*</span>static_val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t <span class="type">Block_size</span>;</span><br><span class="line">&#125; __main_block_desc_0_DATA <span class="operator">=</span> &#123; <span class="number">0</span>, sizeof(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    int val <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> int static_val <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    void (<span class="operator">*</span>myBlock)(void) <span class="operator">=</span> ((void (<span class="operator">*</span>)())<span class="operator">&amp;</span>__main_block_impl_0((void <span class="operator">*</span>)__main_block_func_0, <span class="operator">&amp;</span>__main_block_desc_0_DATA, <span class="operator">&amp;</span>static_val, val));</span><br><span class="line"></span><br><span class="line">    global_val <span class="operator">++</span>;</span><br><span class="line">    static_global_val <span class="operator">++</span>;</span><br><span class="line">    val <span class="operator">++</span>;</span><br><span class="line">    static_val <span class="operator">++</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_78fd5a_mi_1,global_val,static_global_val,val,static_val);</span><br><span class="line"></span><br><span class="line">    ((void (<span class="operator">*</span>)(__block_impl <span class="operator">*</span>))((__block_impl <span class="operator">*</span>)myBlock)-&gt;<span class="type">FuncPtr</span>)((__block_impl <span class="operator">*</span>)myBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在代码分析之前，我们有必要对程序中的内存区域划分有所了解，其大致的分类如下：</p>
<table>
<thead>
<tr>
<th>内存区域</th>
<th>具体说明</th>
</tr>
</thead>
<tbody><tr>
<td>栈区</td>
<td>存放局部变量的值，系统自动分配和释放;<br>特点：容量小，速度快，有序</td>
</tr>
<tr>
<td>堆区</td>
<td>存放通过<code>malloc</code>系列函数或<code>new</code>操作符分配的内存，如对象；<br>一般由程序员分配和释放，如果不释放，则出现内存泄露;<br>特点：容量大，速度慢，无序；</td>
</tr>
<tr>
<td>静态区</td>
<td>存放全局变量和静态变量(包括静态局部变量和静态全局变量)；<br>当程序结束时，系统回收；</td>
</tr>
<tr>
<td>常量区</td>
<td>存放常量的内存区域；<br>程序结束时，系统回收；</td>
</tr>
<tr>
<td>代码区</td>
<td>存放二进制代码的区域</td>
</tr>
</tbody></table>
<p>了解了这些之后，我们再来具体分析代码和执行结果：</p>
<h5 id="1-全局变量和静态全局变量"><a href="#1-全局变量和静态全局变量" class="headerlink" title="1.全局变量和静态全局变量"></a>1.全局变量和静态全局变量</h5><p>这两种变量都存储在<code>静态区</code>，在任何时候都可以访问，所以<code>Block</code>无所谓捕获，而是采用了直接访问的方式成功的修改了它们的值；这一点从<code>Block</code>对应的构造函数中就可以看出来：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">__main_block_impl_0(void <span class="operator">*</span>fp, <span class="keyword">struct</span> __main_block_desc_0 <span class="operator">*</span>desc, int <span class="operator">*</span>_static_var, int _var, int flags<span class="operator">=</span><span class="number">0</span>) : static_var(_static_var), <span class="keyword">var</span>(_var);</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Block</code>的构造函数的参数里只使用到了<code>静态局部变量</code>和<code>自动变量</code>，并没有涉及到<code>全局变量</code>和<code>静态全局变量</code>。</p>
<p>而且我们也在<code>Block</code>的结构体中，也只发现了对应的静态变量和自动变量的属性，这进一步说明<code>Block</code>是直接使用<code>全局变量</code>和<code>静态全局变量</code>，而非捕获的方式；</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">int <span class="operator">*</span>static_val;  <span class="comment">//对应静态局部变量</span></span><br><span class="line">int val;          <span class="comment">//对应自动变量</span></span><br></pre></td></tr></table></figure>

<h5 id="2-自动变量与静态局部变量"><a href="#2-自动变量与静态局部变量" class="headerlink" title="2.自动变量与静态局部变量"></a>2.自动变量与静态局部变量</h5><p>虽然<code>自动变量</code>与<code>静态局部变量</code>都被<code>Block</code>捕获，但是只有静态局部变量才可以被修改成功。通过<code>Block</code>中对应的函数<code>__main_block_func_0</code>，可以观察到<code>Block</code>对外部变量的修改过程，相关代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 <span class="operator">*</span>__cself) &#123;</span><br><span class="line">  int <span class="operator">*</span>static_var <span class="operator">=</span> __cself-&gt;static_var; <span class="comment">// bound by copy</span></span><br><span class="line">  int <span class="keyword">var</span> <span class="operator">=</span> __cself-&gt;<span class="keyword">var</span>; <span class="comment">// bound by copy</span></span><br><span class="line">            global_var <span class="operator">++</span>;</span><br><span class="line">            static_global_var <span class="operator">++</span>;</span><br><span class="line">            (<span class="operator">*</span>static_var) <span class="operator">++</span>;</span><br><span class="line">            <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_TestBlock_b539f1_mi_0,global_var,static_global_var,<span class="keyword">var</span>,(<span class="operator">*</span>static_var));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Block</code>为了访问到对应的<code>自动变量</code>和<code>静态局部变量</code>都使用了<code>__cself</code>，这些操作其实都是针对<code>Block</code>自身属性的，但不同的是：</p>
<ul>
<li><code>外部静态局部变量</code>，由于是指针传递，所以修改的是同一个变量，可以修改成功；</li>
<li><code>外部自动变量</code>，由于是值传递，所以即使修改成功，也无法改变外部自动变量的值；</li>
</ul>
<p>因此，也许是出于安全的目的，在编译阶段我们就会收到错误提示：<code>Block</code>不能修改其捕获的外部自动变量，即:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Variable</span> <span class="keyword">is</span> not assignable(missing __block type specifier)</span><br></pre></td></tr></table></figure>

<h5 id="3-静态局部变量也在静态区，为什么不可以像全局变量一样直接修改？"><a href="#3-静态局部变量也在静态区，为什么不可以像全局变量一样直接修改？" class="headerlink" title="3.静态局部变量也在静态区，为什么不可以像全局变量一样直接修改？"></a>3.静态局部变量也在静态区，为什么不可以像全局变量一样直接修改？</h5><p>其实，关键原因还是<code>&quot;局部&quot;</code>两个字，我们看到<code>C++</code>代码中的函数<code>__main_block_func_0</code>被设置在了包含<code>Block</code>语法的<code>main</code>函数之外，而静态局部变量就是在<code>main</code>函数中定义的；</p>
<p>所以，<code>__main_block_func_0</code>和<code>静态局部变量</code>的作用域是不同的，当然不能像全局变量一样随时访问它。因此，还是采用了捕获和指针传递的方式来修改<code>静态局部变量</code>。</p>
<h5 id="4-为什么自动变量不能像静态变量一样指针传递呢？"><a href="#4-为什么自动变量不能像静态变量一样指针传递呢？" class="headerlink" title="4.为什么自动变量不能像静态变量一样指针传递呢？"></a>4.为什么自动变量不能像静态变量一样指针传递呢？</h5><p>这主要还是因为<code>自动变量</code>和<code>静态变量</code>的存储域的不同。</p>
<p>自动变量存在栈上，其被销毁的时间不定，这很有可能导致<code>Block</code>执行的时候自动变量已经被销毁，那么此时访问被销毁的地址就会产生野指针错误。</p>
<h4 id="二、理解Block修改外部变量的限制"><a href="#二、理解Block修改外部变量的限制" class="headerlink" title="二、理解Block修改外部变量的限制"></a>二、理解Block修改外部变量的限制</h4><p>通过以上的代码示例，我们可以将<code>Block</code>修改外部变量成功的情况分为两种：</p>
<ul>
<li>第一种：<code>Block</code>直接访问全局性的变量，如全局变量、静态全局变量；</li>
<li>第二种：<code>Block</code>间接访问静态局部变量，捕获外部变量并使用指针传递的方式；</li>
</ul>
<p>此时，我们把<code>Block</code>中不允许修改外部变量的值的问题，变成了<code>不允许修改自动变量</code>的问题，但这也并非最终答案，其实最根本的原因还是<strong>Block不允许修改栈中指针的内容</strong>；</p>
<p>下面的一段代码，可以从侧面来验证我们的想法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">  <span class="type">NSMutableString</span> <span class="operator">*</span>mStr <span class="operator">=</span> @<span class="string">&quot;mStr&quot;</span>.mutableCopy;</span><br><span class="line">    void (<span class="operator">^</span>myBlock)(void) <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//mStr = @&quot;newMstr&quot;.mutableCopy; //代码1：直接修改了mStr指针内容；</span></span><br><span class="line">        [mStr appendString:@<span class="string">&quot;-ExtraStr&quot;</span>]; <span class="comment">//代码2：修改mStr指向的堆中内容；</span></span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Block内：mStr:%@&quot;</span>,mStr);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;Block外：%@&quot;</span>,mStr);</span><br><span class="line">    myBlock();   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//Block外：mStr</span></span><br><span class="line"><span class="comment">//Block内：mStr:mStr-ExtraStr</span></span><br></pre></td></tr></table></figure>
<p>上述代码是操作一个自动变量的可变字符串，经过测试<code>mStr</code>不可以直接赋值，却可以通过<code>appendString</code>修改字符串，这其中的原因是什么呢？</p>
<p>首先还是将代码转化为<code>C++</code>源码，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span><span class="operator">*</span> <span class="type">Desc</span>;</span><br><span class="line">  <span class="type">NSMutableString</span> <span class="operator">*</span>mStr;</span><br><span class="line">  __main_block_impl_0(void <span class="operator">*</span>fp, <span class="keyword">struct</span> __main_block_desc_0 <span class="operator">*</span>desc, <span class="type">NSMutableString</span> <span class="operator">*</span>_mStr, int flags<span class="operator">=</span><span class="number">0</span>) : mStr(_mStr) &#123;</span><br><span class="line">    impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> <span class="operator">=</span> flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> <span class="operator">=</span> fp;</span><br><span class="line">    <span class="type">Desc</span> <span class="operator">=</span> desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 <span class="operator">*</span>__cself)&#123;</span><br><span class="line">  <span class="type">NSMutableString</span> <span class="operator">*</span>mStr <span class="operator">=</span> __cself-&gt;mStr; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        ((void (<span class="operator">*</span>)(id, <span class="type">SEL</span>, <span class="type">NSString</span> <span class="operator">*</span> _Nonnull))(void <span class="operator">*</span>)objc_msgSend)((id)mStr, sel_registerName(<span class="string">&quot;appendString:&quot;</span>), (<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_fe0cca_mi_1);</span><br><span class="line">        <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_fe0cca_mi_2,mStr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> void __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>dst, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_assign((void<span class="operator">*</span>)<span class="operator">&amp;</span>dst-&gt;mStr, (void<span class="operator">*</span>)src-&gt;mStr, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_dispose((void<span class="operator">*</span>)src-&gt;mStr, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t <span class="type">Block_size</span>;</span><br><span class="line">  void (<span class="operator">*</span><span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>);</span><br><span class="line">  void (<span class="operator">*</span>dispose)(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>);</span><br><span class="line">&#125; __main_block_desc_0_DATA <span class="operator">=</span> &#123; <span class="number">0</span>, sizeof(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">NSMutableString</span> <span class="operator">*</span>mStr <span class="operator">=</span> ((id (<span class="operator">*</span>)(id, <span class="type">SEL</span>))(void <span class="operator">*</span>)objc_msgSend)((id)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_fe0cca_mi_0, sel_registerName(<span class="string">&quot;mutableCopy&quot;</span>));</span><br><span class="line">    void (<span class="operator">*</span>myBlock)(void) <span class="operator">=</span> ((void (<span class="operator">*</span>)())<span class="operator">&amp;</span>__main_block_impl_0((void <span class="operator">*</span>)__main_block_func_0, <span class="operator">&amp;</span>__main_block_desc_0_DATA, mStr, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_fe0cca_mi_3,mStr);</span><br><span class="line">    ((void (<span class="operator">*</span>)(__block_impl <span class="operator">*</span>))((__block_impl <span class="operator">*</span>)myBlock)-&gt;<span class="type">FuncPtr</span>)((__block_impl <span class="operator">*</span>)myBlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为对象的字符串会涉及到释放的问题，所以此处转换后的源码与基本类型有所区别(但不影响此处分析，后续会讲到)。</p>
<p>我们发现<code>Block</code>捕获了<code>mStr</code>，而且采用了指针传递的方式，这与上面的静态局部变量被捕获的方式很相似，但是<code>mStr</code>依然不可以直接赋值新的字符串。</p>
<p>其实弄清楚问题的关键是理解下面这句代码究做了什么？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mStr <span class="operator">=</span> @<span class="string">&quot;newMstr&quot;</span>.mutableCopy;</span><br></pre></td></tr></table></figure>
<p>这句代码的含义可以归纳为：</p>
<ol>
<li>第一步：<code>@&quot;mStr&quot;.mutableCopy</code>创建了新的字符串对象，并将新对象的地址返回；</li>
<li>第二步：将新对象地址赋值给了<code>mStr</code>；</li>
</ol>
<p>我们知道<code>mStr</code>指针是在栈上的，它随时可能被释放，直接修改就有可能造成野指针错误，这刚好对应了先前自动变量不可修改的问题；</p>
<p>但通过<code>appendString</code>为什么又可以修改字符串呢？这主要因为<code>mStr</code>通过指针传递被<code>Block</code>捕获后，<code>Block</code>只是借助其内部的指针(和<code>mStr</code>同名，且指向同一个地址)，找到了可变字符串的位置，向这块内存追加新的内容，但是并未改变<code>mStr</code>的内存地址；</p>
<p><strong>重要总结：Block修改外部变量的限制，其实是指Block不允许修改栈中指针的内容</strong>；</p>
<p>说白了， <code>block</code>内部可以修改的是堆中的内容， 但不能直接修改栈中的任何东西；</p>
<h4 id="三、理解-block存储域类说明符的原理"><a href="#三、理解-block存储域类说明符的原理" class="headerlink" title="三、理解__block存储域类说明符的原理"></a>三、理解__block存储域类说明符的原理</h4><p>通过以上的分析，我们可以将<code>Block</code>理解为”<code>可以带有自动变量值的匿名函数</code>“，但由于存储域的关系，<code>Block</code>并不能直接修改捕获的自动变量。为了解决这个问题，总结起来有两种方案：</p>
<ol>
<li>使用存储域在静态区的变量(如<code>全局变量</code>、<code>静态全局变量</code>、<code>静态局部变量</code>)；</li>
<li>使用存储域类说明符<code>__block</code>；</li>
</ol>
<p>第一种方案我们已经分析过了，现在重点来理解<code>__block存储域说明符</code>的用法，其实<code>C</code>语言中的还有许多其他存储域类说明符，如：</p>
<ul>
<li><code>typedef</code></li>
<li><code>extern</code></li>
<li><code>static</code></li>
<li><code>auto</code></li>
<li><code>register</code></li>
</ul>
<p><code>__block说明符</code>就类似于<code>static、auto、register</code>，<strong>它们可以用于指定变量值设置到哪个存储域中</strong>。例如，<code>auto</code>表示自动变量存储在栈中(默认)，<code>static</code>表示静态变量存储在数据区中。</p>
<p>下面我们来实际使用<code>__block</code>，使用它来修改被<code>Block</code>捕获的自动变量，具体的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//__block存储域修饰符</span></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    __block int val <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    void (<span class="operator">^</span>myBlock)(void) <span class="operator">=</span> <span class="operator">^</span>&#123; val <span class="operator">=</span> <span class="number">20</span>;&#125;;</span><br><span class="line"></span><br><span class="line">    val <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    myBlock();</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;val: %@&quot;</span>,val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Block</code>中修改自动变量却没有像之前那样报错，这说明<code>__block说明符</code>是有效的，为了探究其中原理，现在我们再次把上述代码转换<code>C++</code>代码，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_val_0</span> &#123;</span><br><span class="line">  void <span class="operator">*</span>__isa;</span><br><span class="line">__Block_byref_val_0 <span class="operator">*</span>__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span><span class="operator">*</span> <span class="type">Desc</span>;</span><br><span class="line">  __Block_byref_val_0 <span class="operator">*</span>val; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(void <span class="operator">*</span>fp, <span class="keyword">struct</span> __main_block_desc_0 <span class="operator">*</span>desc, __Block_byref_val_0 <span class="operator">*</span>_val, int flags<span class="operator">=</span><span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> <span class="operator">=</span> flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> <span class="operator">=</span> fp;</span><br><span class="line">    <span class="type">Desc</span> <span class="operator">=</span> desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 <span class="operator">*</span>__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 <span class="operator">*</span>val <span class="operator">=</span> __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line"> (val-&gt;__forwarding-&gt;val) <span class="operator">=</span> <span class="number">20</span>;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> void __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>dst, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_assign((void<span class="operator">*</span>)<span class="operator">&amp;</span>dst-&gt;val, (void<span class="operator">*</span>)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_dispose((void<span class="operator">*</span>)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t <span class="type">Block_size</span>;</span><br><span class="line">  void (<span class="operator">*</span><span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>);</span><br><span class="line">  void (<span class="operator">*</span>dispose)(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>);</span><br><span class="line">&#125; __main_block_desc_0_DATA <span class="operator">=</span> &#123; <span class="number">0</span>, sizeof(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val <span class="operator">=</span> &#123;(void<span class="operator">*</span>)<span class="number">0</span>,(__Block_byref_val_0 <span class="operator">*</span>)<span class="operator">&amp;</span>val, <span class="number">0</span>, sizeof(__Block_byref_val_0), <span class="number">10</span>&#125;;</span><br><span class="line">    void (<span class="operator">*</span>myBlock)(void) <span class="operator">=</span> ((void (<span class="operator">*</span>)())<span class="operator">&amp;</span>__main_block_impl_0((void <span class="operator">*</span>)__main_block_func_0, <span class="operator">&amp;</span>__main_block_desc_0_DATA, (__Block_byref_val_0 <span class="operator">*</span>)<span class="operator">&amp;</span>val, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    (val.__forwarding-&gt;val) <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    ((void (<span class="operator">*</span>)(__block_impl <span class="operator">*</span>))((__block_impl <span class="operator">*</span>)myBlock)-&gt;<span class="type">FuncPtr</span>)((__block_impl <span class="operator">*</span>)myBlock);</span><br><span class="line">    <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_wd_fhcn9bn91v56nlzv9mt5z8ym0000gn_T_main_a9f88e_mi_0,(val.__forwarding-&gt;val));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析代码，我们会发现<code>__block变量</code>的初始化已经发生了根本的变化，此时的<code>自动变量val</code>对应的是<code>C++</code>源码中的<code>__Block_byref_val_0</code>结构体。该结构体包含了五个成员变量，具体定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_val_0</span> &#123;</span><br><span class="line">  void <span class="operator">*</span>__isa;                      <span class="comment">//isa指针</span></span><br><span class="line">__Block_byref_val_0 <span class="operator">*</span>__forwarding;  <span class="comment">//初始化传递的是自身结构体实例的指针</span></span><br><span class="line"> int __flags;                       <span class="comment">//标记flag</span></span><br><span class="line"> int __size;                        <span class="comment">//大小</span></span><br><span class="line"> int val;                           <span class="comment">//对应原自动变量val的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们看到<code>__block变量val</code>的初始值为<code>10</code>，而这个值也出现在了调用<code>__Block_byref_val_0</code>结构体构造方法的时候，总结<code>__block变量</code>被捕获的过程如下：</p>
<ol>
<li>自动变量<code>__block int varl</code>被封装为<code>__Block_byref_val_0</code>结构体，保存原始变量的指针和值；</li>
<li><code>__Block_byref_val_0</code>结构体包含一个与<code>__block变量</code>同名的成员变量<code>val</code>，对应外部自动变量的值；</li>
<li><code>__Block_byref_val_0</code>结构体包含一个<code>__forwarding</code>指针，初始化传递的是自己的地址;</li>
<li>在<code>Block</code>初始化的过程中，调用<code>__main_block_impl_0</code>结构体构造函数时，会将<code>__block变量</code>的<code>__Block_byref_val_0</code>结构体实例的指针作为参数；</li>
</ol>
<p>接下来分析给<code>__block变量</code>赋值的代码，转换后的源码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 <span class="operator">*</span>__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 <span class="operator">*</span>val <span class="operator">=</span> __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line"> (val-&gt;__forwarding-&gt;val) <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们看到函数首先通过<code>cself-&gt;val</code>拿到了对应<code>__block变量</code>的结构体实例，然后又通过<code>__Block_byref_val_0</code>结构体实例的成员变量<code>__forwarding</code>，最终访问到了结构体成员变量<code>val</code>；</p>
<p>具体的过程，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/block_visit__block_val.png" width="500" hegiht="313" align=center/></p>
<p>分析当前情况，我就会发现这里有两个很关键问题：</p>
<ol>
<li>为什么要使用多余的<code>__forwarding</code>指针来间接访问变量？</li>
<li>当前<code>__block</code>说明符的作用仅仅体现在：将<code>__block变量</code>封装为<code>__Block_byref_val_0</code>结构体，这并未从根本上改变自动变量的性质，自动变量究竟是如何被修改的呢？</li>
</ol>
<p>为了理解上述问题，我们首先应该对下面的代码有一个更加清晰的了解：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">void (<span class="operator">^</span>myBlock)(void) <span class="operator">=</span> <span class="operator">^</span>&#123; val <span class="operator">=</span> <span class="number">10</span>;&#125;;</span><br></pre></td></tr></table></figure>

<p>代码中创建后的<code>Block</code>直接赋值给了强指针，这其实满足了<code>ARC</code>环境下编辑器对<code>Block</code>的优化：</p>
<p><strong>编译器会自动将Block从栈拷贝到堆上，而Block中的用到的__block变量也会被一并拷贝，并且被堆上的Block持有</strong>。</p>
<p>所以，即使是<code>Block</code>语法所在的作用域结束，堆上的<code>Block</code>和<code>__block变量</code>依然继续存在，自然也就不存在自动变量创建在栈上被释放的问题了。</p>
<p>借助图示，理解如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/block_one_block_use__block_val.png" width="500" hegiht="313" align=center/></p>
<p>另外，当<code>__block</code>变量结构体实例在从栈上被拷贝到堆上时，会将成员变量的<code>__forwarding</code>的值替换为复制目标堆上的<code>__block</code>变量结构体实例的地址。</p>
<p>通过这种功能，无论是在<code>Block</code>语法中、<code>Block</code>语法外使用<code>__block</code>变量，还是<code>__block</code>变量配置在栈上或堆上，都可以顺利访问同<code>__block</code>变量。这就是<code>__forwarding</code>指针存在的意义。</p>
<p>使用图示，理解如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/block_copy__block_val__forwarding_pointer_change.png" width="500" hegiht="313" align=center/></p>
<p><strong>重要总结：</strong></p>
<ol>
<li><code>__block</code>修饰的自动变量被封装为结构体，作为一个对象随着<code>Block</code>被拷贝到了堆上，解决了自动变量容易因作用域结束而释放的问题。</li>
<li>而<code>__block</code>变量结构体中的<code>__forwarding</code>则保证了无论在栈上还是堆上访问的都是同一个<code>__block变量</code>；</li>
<li>我们能够成功修改<code>__block</code>变量的值，其实是修改了堆上被Block持有的<code>__block</code>变量的内部成员变量val；</li>
</ol>
<p><strong>其他问题：</strong></p>
<ol>
<li><code>ARC</code>存在编译器的自动优化，自动拷贝<code>Block</code>的情况还包含了很多种，这里只是其中一种情况，上篇已分析过；</li>
<li>上述代码中，<code>__block</code>说明符将基本类型的数据封装为结构体类型(其中包含了<code>isa</code>指针)，这其实就说明<code>__block</code>变量已经是作为了一个对象在使用；</li>
<li>而对象类型被<code>Block</code>捕获之后都会涉及一些释放的问题，所以源码也出现了许多与对象释放相关的函数如：<code>__main_block_copy_0</code>、<code>__main_block_dispose_0</code>等。这个问题后续会详细分析；</li>
</ol>
<h4 id="四、-block变量的存储域"><a href="#四、-block变量的存储域" class="headerlink" title="四、__block变量的存储域"></a>四、__block变量的存储域</h4><p><code>Block</code>的存储域通常涉及到拷贝的操作，那么对于<code>__block</code>变量又是如何处理的呢？使用<code>__block</code>变量的<code>Block</code>从栈上拷贝到堆上时，<code>__block</code>变量也会受到影响；</p>
<h5 id="1-单个Block中使用-block变量"><a href="#1-单个Block中使用-block变量" class="headerlink" title="1.单个Block中使用__block变量"></a>1.单个Block中使用__block变量</h5><p>若一个<code>Block</code>中使用<code>__block</code>变量，则当该<code>Block</code>从栈拷贝到堆上时，使用的所有<code>__block</code>变量也全部被从栈上拷贝到堆上。使用图示理解如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/block_one_block_use__block_val.png" width="500" hegiht="313" align=center/></p>
<h5 id="2-多个Block使用-block变量"><a href="#2-多个Block使用-block变量" class="headerlink" title="2.多个Block使用__block变量"></a>2.多个Block使用__block变量</h5><p>多个<code>Block</code>使用<code>__block</code>变量时，任何一个<code>Block</code>从栈上拷贝到堆上，<code>__block</code>变量就会一并从栈上拷贝到堆上并被该<code>Block</code>所持有。当剩下的Block从栈拷贝到堆上时，被拷贝的<code>Block</code>持有<code>__block</code>变量，并增加<code>__block</code>变量的引用计数。使用图示理解如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/block_many_block_use__block_val.png" width="500" hegiht="313" align=center/></p>
<h5 id="3-block变量的释放"><a href="#3-block变量的释放" class="headerlink" title="3.__block变量的释放"></a>3.__block变量的释放</h5><p>如果拷贝到堆上的<code>Block</code>被释放，那么它使用的<code>__block</code>变量的引用计数会减一，如果引用计数为<code>0</code>就会被释放。使用图示理解如下：</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/block___block_val_release.png" width="500" hegiht="313" align=center/>

<p>**重要总结：**无论是对基本类型还是对象使用<code>__block</code>修饰符，从转化后的源码来看，它们都会被转化为对应的结构体实例来使用，具有引用类型数据的特性。因此<code>__block</code>变量随着<code>Block</code>被拷贝到堆上后，它们的内存管理与普通的<code>OC</code>对象引用计数内存管理模式完全相同。</p>
<h4 id="五、理解Block对对象的捕获"><a href="#五、理解Block对对象的捕获" class="headerlink" title="五、理解Block对对象的捕获"></a>五、理解Block对对象的捕获</h4><p>仔细观察之前的源码我们就会发现，<code>Block</code>捕获对象类型和<code>__block</code>类型的变量(在底层被封装为结构体，也属于对象)明显比基本类型要复杂多，其实这里主要是因为对象类型还要涉及到释放的问题。下面的代码演示了<code>Block</code>对对象的捕获的过程，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">typedef void(<span class="operator">^</span><span class="type">AddBlock</span>)(<span class="type">NSString</span> <span class="operator">*</span>); <span class="comment">//定义一种携带字符串参数的Block</span></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">AddBlock</span> blk <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">NSMutableArray</span> <span class="operator">*</span>mArr <span class="operator">=</span> @[].mutableCopy;</span><br><span class="line">        blk <span class="operator">=</span> <span class="operator">^</span>(<span class="type">NSString</span> <span class="operator">*</span>string)&#123;</span><br><span class="line">            [mArr addObject:string];</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;mArr count = %ld&quot;</span>,[mArr count]);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;<span class="comment">//NSMutableArray所在的作用域结束</span></span><br><span class="line">    </span><br><span class="line">    blk(@<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    blk(@<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    blk(@<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line">mArr count <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">mArr count <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">mArr count <span class="operator">=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>分析代码：当前为<code>ARC</code>环境下，编译器自动对访问了自动变量的<code>mArr</code>的<code>blk</code>进行了拷贝；所以<code>mArr</code>离开其所在的作用域结束时并没有被释放。虽然<code>mArr</code>指针已经不能使用，但是<code>blk</code>依然保留有对<code>mArr</code>的引用可以找到这块内存。所以代码也是运行正常的；</p>
<p>现在查看编译器转换后的源码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span><span class="operator">*</span> <span class="type">Desc</span>;</span><br><span class="line">  <span class="type">NSMutableArray</span> <span class="operator">*</span>mArr;</span><br><span class="line">  __main_block_impl_0(void <span class="operator">*</span>fp, <span class="keyword">struct</span> __main_block_desc_0 <span class="operator">*</span>desc, <span class="type">NSMutableArray</span> <span class="operator">*</span>_mArr, int flags<span class="operator">=</span><span class="number">0</span>) : mArr(_mArr) &#123;</span><br><span class="line">    impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> <span class="operator">=</span> flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> <span class="operator">=</span> fp;</span><br><span class="line">    <span class="type">Desc</span> <span class="operator">=</span> desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>dst, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_assign((void<span class="operator">*</span>)<span class="operator">&amp;</span>dst-&gt;mArr, (void<span class="operator">*</span>)src-&gt;mArr, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_dispose((void<span class="operator">*</span>)src-&gt;mArr, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t <span class="type">Block_size</span>;</span><br><span class="line">  void (<span class="operator">*</span><span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>);</span><br><span class="line">  void (<span class="operator">*</span>dispose)(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>);</span><br><span class="line">&#125; __main_block_desc_0_DATA <span class="operator">=</span> &#123; <span class="number">0</span>, sizeof(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure>
<p>由于代码量较大，这里只提供了与捕获基本类型不同的部分；我们发现：</p>
<ol>
<li>当<code>Block</code>捕获对象类型的变量时，此处的<code>__main_block_desc_0</code>结构体中多了<code>copy</code>与<code>dispose</code>两个成员变量；</li>
<li>而且它们的初始化分别使用了<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>的函数指针；</li>
</ol>
<p>这里主要的原因是：</p>
<ol>
<li>在<code>Objective-C</code>中，<code>C</code>语言结构体不能含有<code>__strong、__weak</code>修饰符的变量，因为编译器不知道应该如何进行<code>C</code>语言结构的初始化和废弃操作，不能很好地管理内存；</li>
<li>但是<code>OC</code>的运行时库能够准确把握<code>Block</code>从栈复制到堆以及堆上<code>Block</code>被废弃的时机，所以这里才会增加与内存管理相关的变量和函数。</li>
</ol>
<h5 id="1-main-block-copy-0函数"><a href="#1-main-block-copy-0函数" class="headerlink" title="1.__main_block_copy_0函数"></a>1.__main_block_copy_0函数</h5><p>结构体<code>__main_block_desc_0</code>中的<code>copy</code>成员变量对应了<code>__main_block_copy_0</code>函数。</p>
<p>当<code>Block</code>从栈上拷贝到堆上时，<code>__main_block_copy_0</code>函数会被调用，然后再调用其内部的<code>_Block_object_assign</code>函数。<code>_Block_object_assign</code>函数就相当于<code>retain</code>操作，会自动根据<code>__main_block_impl_0</code>结构体内部的<code>mArr</code>是什么类型的指针，对<code>mArr</code>对象产生强引用或者弱引用。如果<code>mArr</code>指针是<code>__strong</code>类型，则为强引用，引用计数<code>+1</code>，如果<code>mArr</code>指针是<code>__weak</code>类型，则为弱引用，引用计数不变。</p>
<h5 id="2-main-block-dispose-0函数"><a href="#2-main-block-dispose-0函数" class="headerlink" title="2.__main_block_dispose_0函数"></a>2.__main_block_dispose_0函数</h5><p>结构体<code>__main_block_desc_0</code>中的<code>dispose</code>成员变量对应了<code>__main_block_dispose_0</code>函数。<br>当<code>Block</code>被废弃时，<code>__main_block_dispose_0</code>函数会被调用，<code>__main_block_dispose_0</code>函数就相当于release操作，将<code>mArr</code>对象的引用计数减1，如果此时引用计数为0，那么遵循引用计数的规则<code>mArr</code>也就被释放了。</p>
<h5 id="3-Block捕获对象与-block变量的区别"><a href="#3-Block捕获对象与-block变量的区别" class="headerlink" title="3.Block捕获对象与__block变量的区别"></a>3.Block捕获对象与__block变量的区别</h5><p>其实<code>Block</code>捕获对象与<code>__block</code>变量后，对于它们的内存管理的方式相同，也都是使用<code>copy</code>函数持有和<code>disposde</code>函数释放；两者体现在源码上的不同，我们可以观察下面的函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> void __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>dst, <span class="keyword">struct</span> __main_block_impl_0<span class="operator">*</span>src) &#123;_Block_object_assign((void<span class="operator">*</span>)<span class="operator">&amp;</span>dst-&gt;mArr, (void<span class="operator">*</span>)src-&gt;mArr, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br></pre></td></tr></table></figure>
<p><code>_Block_object_assign</code>函数中的最后一个参数用于区分<code>Block</code>捕获的是对象还是<code>__block</code>变量。</p>
<table>
<thead>
<tr>
<th>对象变量</th>
<th>__block变量</th>
</tr>
</thead>
<tbody><tr>
<td>BLOCK_FIELD_IS_OBJECT</td>
<td>BLOCK_FIELD_IS_BYREF</td>
</tr>
</tbody></table>
<h4 id="六、Block的循环引用问题"><a href="#六、Block的循环引用问题" class="headerlink" title="六、Block的循环引用问题"></a>六、Block的循环引用问题</h4><p><code>Block</code>在从栈拷贝到堆上时，如果其中捕获了强类型的对象，该对象就会被<code>Block</code>所持有。这样很容易就会引起循环引用，我们来看下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">typedef void(<span class="operator">^</span><span class="type">MyBlock</span>)(void);</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">MyObject</span> : <span class="type">NSObject</span></span><br><span class="line"><span class="meta">@property</span>(nonatomic,<span class="keyword">copy</span>) <span class="type">MyBlock</span> block;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">MyObject</span></span><br><span class="line"><span class="operator">-</span> (instancetype)<span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)dealloc &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;MyObject dealloc!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="operator">*</span>myObject <span class="operator">=</span> [[<span class="type">MyObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        myObject.block <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">            <span class="comment">//Capturing &#x27;myObject&#x27; strongly in this block is likely to lead to a retain cycle</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;捕获对象:%@&quot;</span>, myObject );</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;myObject的作用域结束了&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不仅编译器给出了内存泄漏的警告，而且测试结果也证实了<code>MyObject</code>的<code>dealloc</code>实例方法并没有执行，这里发生了循环引用。原因就在与<code>myObject</code>的<code>block</code>在被自动拷贝到堆上的过程中持有了<code>myObject</code>，而<code>myObject</code>本身就持有了<code>block</code>，所以两者相互持有就产生了问题。</p>
<p>现在就来总结类似情况下的<code>Block</code>循环引用的处理方法，可分为<code>ARC</code>和<code>MRC</code>两种情况：</p>
<h5 id="1-解决ARC环境下的循环引用问题"><a href="#1-解决ARC环境下的循环引用问题" class="headerlink" title="1.解决ARC环境下的循环引用问题"></a>1.解决ARC环境下的循环引用问题</h5><p><strong>方法1：使用弱引用修饰符__weak、和__unsafe_unretained修饰符；</strong><br>使用<code>__weak</code>解决上述问题，需要改进的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="operator">*</span>myObject <span class="operator">=</span> [[<span class="type">MyObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        __weak typeof(myObject) weakObject <span class="operator">=</span> myObject;</span><br><span class="line">        myObject.block <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;捕获对象:%@&quot;</span>, weakObject );</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;myObject的作用域结束了&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码使用弱引用修饰符<code>__weak ，在block内部对  myObject</code>设置为弱引用，弱引用不会导致Block捕获对象的引用计数增加(这在上述分析中已经讲过)。</p>
<p>注意<code>__weak</code>和<code>__unsafe_unretained</code>的区别：</p>
<ol>
<li><strong>__weak</strong>：<code>iOS4</code>之后才提供使用，而且比<code>__unsafe_unretained</code>更加安全，因为当它指向的对象销毁时，会自动将指针置为<code>nil</code>；推荐使用。</li>
<li><strong>__unsafe_unretained</strong>：在<code>__weak</code>出现以前常用修饰符，其指向的对象销毁时，指针存储的地址值不变，所以没有<code>__weak</code>安全。</li>
</ol>
<p><strong>方法2：使用__block说明符</strong><br>回忆<code>__block</code>修饰基本类型的C++源码，我们可以知道<code>__block</code>修饰对象时其实也会封装一个结构体类型，而这个结构体中会持有自动变量对象，这样就会造成下图的情况：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/block___block_handle_cycle1.jpeg" width="500" hegiht="313" align=center/><br>使用<code>__block</code>解决上述问题，需要改进的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="operator">*</span>myObject <span class="operator">=</span> [[<span class="type">MyObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        __block <span class="type">MyObject</span> <span class="operator">*</span>tempObject <span class="operator">=</span> myObject;</span><br><span class="line">        myObject.block <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;捕获对象:%@&quot;</span>, tempObject );</span><br><span class="line">            tempObject <span class="operator">=</span> <span class="literal">nil</span>;  <span class="comment">//关键代码1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        myObject.block();      <span class="comment">//关键代码2：执行持有的block；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;myObject的作用域结束了&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码有两句关键，已经通过注释标注；在<code>block</code>中通过<code> tempObject = nil</code>这句代码，<code>__block</code>变量<code>tempObject</code>对于<code>MyObject</code>类对象的强引用失效了，而这句代码生效的前提又是<code>block</code>被调用了(关键代码2)；这种方式避免了循环引用的产生的过程如下图：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/block___block_handle_cycle2.png" width="500" hegiht="313" align=center></p>
<p>**特别注意：**如果关键代码2没有被调用，同样会造成循环引用。</p>
<p><strong>使用__block变量相比弱引用修饰符的优缺点:</strong><br>优点：</p>
<ol>
<li>通过执行<code>block</code>的方式，可动态决定<code>__block</code>变量可以控制对象的持有时间；</li>
<li>在不能使用<code>__weak</code>修饰符的环境下，避免使用<code>__unsafe_unretained</code>(因为要考虑野指针问题)；</li>
</ol>
<p>缺点：为了避免循环引用，必须执行<code>Block</code>;</p>
<h5 id="2-解决MRC环境下的循环引用问题"><a href="#2-解决MRC环境下的循环引用问题" class="headerlink" title="2.解决MRC环境下的循环引用问题"></a>2.解决MRC环境下的循环引用问题</h5><p><strong>方法1：使用弱引用修饰符__unsafe_unretained修饰符；</strong><br>在<code>MRC</code>环境下不支持使用<code>__weak</code>，所以只能使用<code>__unsafe_unretained</code>；使用原理同<code>ARC</code>环境下相同，这里不再赘述。</p>
<p><strong>方法2：使用__block说明符</strong><br><code>MRC</code>环境下，<code>__block</code>说明符被用来避免循环引用。这是因为当<code>Block</code>从栈拷贝到堆时，若<code>Block</code>使用的变量是附有<code>__block</code>说明符的id类型或者对象类型的自动变量，不会被<code>retain</code>，否则就会被<code>retain</code>。这一点和<code>ARC</code>环境是不同的。现在我们在MRC环境下改进代码，具体如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">MyObject</span> <span class="operator">*</span>myObject <span class="operator">=</span> [[<span class="type">MyObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    __unsafe_unretained <span class="type">MyObject</span> <span class="operator">*</span>tempObject <span class="operator">=</span> myObject;</span><br><span class="line">    myObject.block <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;捕获对象:%@&quot;</span>, tempObject );</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">NSAutoreleasePool</span> <span class="operator">*</span>pool <span class="operator">=</span> [[<span class="type">NSAutoreleasePool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [myObject autorelease];</span><br><span class="line">    [pool drain];  <span class="comment">//等同于[myObject release];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//MyObject dealloc!</span></span><br></pre></td></tr></table></figure>

<p>上述操作将代码改为了<code>MRC</code>下的自动释放池，相比之前在<code>ARC</code>中使用<code>__block</code>，这里没有在<code>Block</code>内部置<code>nil</code>的操作，也没有调用<code>block</code>，但同样解决了循环引用的问题；</p>
<p><strong>重要总结：</strong><code>__block</code>说明符在<code>ARC</code>与<code>MRC</code>环境下的用途有很大区别，因此在编写代码时我们必须区分好这两种环境；
 </p>
]]></content>
      <categories>
        <category>iOS底层</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS底层-Block本质及存储域问题</title>
    <url>/2019/04/12/iOS%E5%BA%95%E5%B1%82-Block%E6%9C%AC%E8%B4%A8%E5%8F%8A%E5%AD%98%E5%82%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>主要内容：</strong></p>
<ol>
<li>分析<code>Block</code>的源码</li>
<li>验证<code>Block</code>的本质是对象</li>
<li>理解<code>Block</code>的存储域分类<span id="more"></span></li>
<li>验证<code>Block</code>的不同存储域</li>
<li>分析<code>Block</code>的<code>Copy</code>原理</li>
</ol>
<h4 id="一、分析Block的源码"><a href="#一、分析Block的源码" class="headerlink" title="一、分析Block的源码"></a>一、分析Block的源码</h4><p>为了分析<code>Block</code>的源码，从一个最简单的<code>Block</code>使用示例说起，测试代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.m文件：</span></span><br><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    int num <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    void (<span class="operator">^</span>block)(void) <span class="operator">=^</span>&#123;<span class="type">NSLog</span>(@<span class="string">&quot;num = %d&quot;</span>,num);&#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Objective-C</code>语言是基于<code>C</code>、<code>C++</code>的，为了深入理解<code>Block</code>的底层结构，我们可以通过如下的编译器命令将上述代码转换成<code>C++</code>源码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">clang <span class="operator">-</span>rewrite<span class="operator">-</span>objc 源代码文件名(如此例中的main.m)</span><br></pre></td></tr></table></figure>
<p>转化后的<code>C++</code>源码如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_impl</span> &#123;</span><br><span class="line">  void <span class="operator">*</span>isa;</span><br><span class="line">  int <span class="type">Flags</span>;</span><br><span class="line">  int <span class="type">Reserved</span>;</span><br><span class="line">  void <span class="operator">*</span><span class="type">FuncPtr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span><span class="operator">*</span> <span class="type">Desc</span>;</span><br><span class="line">  int num;</span><br><span class="line">  __main_block_impl_0(void <span class="operator">*</span>fp, <span class="keyword">struct</span> __main_block_desc_0 <span class="operator">*</span>desc, int _num, int flags<span class="operator">=</span><span class="number">0</span>) : num(_num) &#123;</span><br><span class="line">    impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> <span class="operator">=</span> flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> <span class="operator">=</span> fp;</span><br><span class="line">    <span class="type">Desc</span> <span class="operator">=</span> desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 <span class="operator">*</span>__cself) &#123;</span><br><span class="line">  int num <span class="operator">=</span> __cself-&gt;num; <span class="comment">// bound by copy</span></span><br><span class="line"><span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_wd_fhcn9bn91v56nlzv9mt5z8ym0000gn_T_main_9e3646_mi_0,num);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t <span class="type">Block_size</span>;</span><br><span class="line">&#125;</span><br><span class="line"> __main_block_desc_0_DATA <span class="operator">=</span> &#123; <span class="number">0</span>, sizeof(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    int num <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    void (<span class="operator">*</span>myBlock)(void) <span class="operator">=</span>((void (<span class="operator">*</span>)())<span class="operator">&amp;</span>__main_block_impl_0((void <span class="operator">*</span>)__main_block_func_0, <span class="operator">&amp;</span>__main_block_desc_0_DATA, num));</span><br><span class="line">    ((void (<span class="operator">*</span>)(__block_impl <span class="operator">*</span>))((__block_impl <span class="operator">*</span>)myBlock)-&gt;<span class="type">FuncPtr</span>)((__block_impl <span class="operator">*</span>)myBlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比<code>OC</code>代码与<code>C++</code>源码中的<code>main</code>函数，我们发现：</p>
<ol>
<li>创建<code>Block</code>其实是调用了<code>__main_block_impl_0</code>结构体的构造函数；</li>
<li><code>Block</code>中待执行代码也都被封装到了<code>__main_block_func_0</code>函数中；</li>
</ol>
<p>另外值得注意的是，这些<code>C++</code>的结构体和函数的命名，是根据<code>Block</code>语法所属的函数名(此处为<code>main</code>)和<code>Block</code>语法在该函数出现的顺序值(此处为<code>0</code>)来设定的；</p>
<p>根据这些对应关系，我们<code>对C++</code>源码中的内容一一分析：</p>
<h5 id="1-main-block-imp-0结构体"><a href="#1-main-block-imp-0结构体" class="headerlink" title="1.__main_block_imp_0结构体"></a>1.__main_block_imp_0结构体</h5><p><code>__main_block_impl_0</code>结构体对应了<code>Block</code>的定义，结构体内部包含了三个成员变量<code>impl</code>、<code>Desc</code>、<code>num</code>。</p>
<p><code>num</code>其实就是被捕获的变量(后续再讲)，另外还有一个同名的构造函数<code>__main_block_impl_0</code>。可以看到相关的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span><span class="operator">*</span> <span class="type">Desc</span>;</span><br><span class="line">  int num;</span><br><span class="line">  __main_block_impl_0(void <span class="operator">*</span>fp, <span class="keyword">struct</span> __main_block_desc_0 <span class="operator">*</span>desc, int _num, int flags<span class="operator">=</span><span class="number">0</span>) : num(_num) &#123;</span><br><span class="line">    impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> <span class="operator">=</span> flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> <span class="operator">=</span> fp;</span><br><span class="line">    <span class="type">Desc</span> <span class="operator">=</span> desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Block</code>通过调用这里的构造函数得以创建，调用时需传入了四个参数：<code>(void *fp, struct __main_block_desc_0 *desc, int _num, int flags=0)</code>，前三个参数对应成员变量的初始化，而最后一个参数<code>flags</code>携带默认值可暂不考虑；</p>
<h5 id="2-block-impl结构体"><a href="#2-block-impl结构体" class="headerlink" title="2.__block_impl结构体"></a>2.__block_impl结构体</h5><p><code>__main_block_imp_0</code>结构体的第一个成员变量<code>impl</code>，就是<code>__block_impl</code>结构体类型；</p>
<p>尤其注意：</p>
<ol>
<li>该结构体中包含有<code>isa</code>指针，从这一点就可以说明<code>Block</code>本质上还是一个<code>OC</code>对象，因为<code>OC</code>中只有对象才会具有<code>isa</code>指针的概念；</li>
<li><code>FuncPtr</code>是一个函数指针，在<code>__main_block_imp_0</code>构造函数调用时被赋值；</li>
</ol>
<h5 id="3-main-block-desc-0结构体"><a href="#3-main-block-desc-0结构体" class="headerlink" title="3.__main_block_desc_0结构体"></a>3.__main_block_desc_0结构体</h5><p><code>__main_block_imp_0</code>结构体构造函数中传入参数<code>desc</code>，其实就是<code>__main_block_desc_0</code>对象。该结构体包含两个成员变量：</p>
<ol>
<li><code>reserved</code>：系统保留值；</li>
<li><code>Block_size</code>：代表<code>Block</code>的大小；</li>
</ol>
<h5 id="4-main-block-func-0函数"><a href="#4-main-block-func-0函数" class="headerlink" title="4.__main_block_func_0函数"></a>4.__main_block_func_0函数</h5><p><code>__main_block_imp_0</code>结构体构造函数中传入函数指针<code>fp</code>，其实就是<code>__main_block_func_0</code>函数的地址；</p>
<p>该函数是将<code>Block</code>中所有的代码封装为函数，以待被调用；</p>
<h5 id="5-总结Block的特点"><a href="#5-总结Block的特点" class="headerlink" title="5.总结Block的特点"></a>5.总结Block的特点</h5><ol>
<li><code>Block</code>本质上一个<code>OC</code>对象：比如这里的<code>Block</code>，其底层对应了<code>__main_block_impl_0</code>结构体，而且内部包含有<code>isa</code>指针；</li>
<li><code>Block</code>中携带了函数执行的环境：此处<code>Block</code>里待执行的代码，在底层被封装为<code>__main_block_func_0</code>函数，以实现调用；</li>
<li><code>Block</code>相当于其他语言中的闭包或者匿名函数：它与函数区别在于，<code>Block</code>相当于<code>函数+函数执行的上下文环境</code>(捕获外部变量下面会讲到)；</li>
</ol>
<h4 id="二、验证Block的本质是对象"><a href="#二、验证Block的本质是对象" class="headerlink" title="二、验证Block的本质是对象"></a>二、验证Block的本质是对象</h4><p>下面通过打印的方式验证<code>Block</code>对象本质，测试代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)testBlock5 &#123;</span><br><span class="line">    void(<span class="operator">^</span>block)(int a) <span class="operator">=</span> <span class="operator">^</span>(int a) &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;This is a block&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,[block <span class="keyword">class</span>]);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,[[block <span class="keyword">class</span>] superclass]);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,[[[block <span class="keyword">class</span>] superclass] superclass]);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,[[[[block <span class="keyword">class</span>] superclass] superclass] superclass]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//__NSGlobalBlock__</span></span><br><span class="line"><span class="comment">//__NSGlobalBlock</span></span><br><span class="line"><span class="comment">//NSBlock</span></span><br><span class="line"><span class="comment">//NSObject</span></span><br></pre></td></tr></table></figure>
<p>观察打印结果：</p>
<ol>
<li>我们看到<code>Block</code>最终继承于<code>NSObject</code>类型，这里再一次验证了<code>Block</code>本质就是<code>OC</code>对象的结论；</li>
<li>而打印结果中出现的<code>__NSGlobalBlock__</code>，说明此处的<code>Block</code>的存储域为静态区；</li>
</ol>
<h4 id="三、理解Block的存储域分类"><a href="#三、理解Block的存储域分类" class="headerlink" title="三、理解Block的存储域分类"></a>三、理解Block的存储域分类</h4><p>在之前<code>Block</code>结构体构造函数中，我们很容易能找到这样一句代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">impl.isa <span class="operator">=</span> <span class="operator">&amp;</span>_NSConcreteStackBlock;</span><br></pre></td></tr></table></figure>
<p>我们已经知道<code>Block</code>也是一个<code>OC</code>对象，而每个<code>OC</code>对象都有一个<code>isa</code>指针指向其类对象，这里的情况也是类似的；</p>
<p>这里<code>Block</code>的<code>isa</code>指针指向了<code>_NSConcreteStackBlock</code>类对象，即此时的<code>Block</code>是以<code>_NSConcreteStackBlock</code>类为模板创建的实例；</p>
<p>除此之外，其实还有两个与之类似的类<code>_NSConcreteGlobalBlock</code>和<code>_NSConcreteMallocBlock</code>，不同的<code>Block</code>类创建的对象用于不同的存储域，也对应了对应不同的<code>OC</code>类型，具体整理如下：</p>
<table>
<thead>
<tr>
<th>clang类</th>
<th>OC类</th>
<th>内存区域</th>
</tr>
</thead>
<tbody><tr>
<td><code>_NSConcreteStackBlock</code></td>
<td><code>__NSStackBlock__</code></td>
<td>栈区</td>
</tr>
<tr>
<td><code>_NSConcreteMallocBlock</code></td>
<td><code>__NSMallocBlock__</code></td>
<td>堆区</td>
</tr>
<tr>
<td><code>_NSConcreteGlobalBlock</code></td>
<td><code>__NSGlobalBlock__</code></td>
<td>静态区</td>
</tr>
</tbody></table>
<h4 id="四、验证Block的不同存储域"><a href="#四、验证Block的不同存储域" class="headerlink" title="四、验证Block的不同存储域"></a>四、验证Block的不同存储域</h4><p>不同存储域的<code>Block</code>使用方式有很大差别，而正确区分<code>Block</code>类型的关键在于：<strong>Block中是否引用了自动变量(需要MRC下测试)</strong>，总结起来如下：</p>
<table>
<thead>
<tr>
<th>Block类型</th>
<th>环境</th>
<th>内存区域</th>
</tr>
</thead>
<tbody><tr>
<td><code>_NSConcreteGlobalBlock(__NSGlobalBlock__)</code></td>
<td>没有访问自动变量；<br>或者只用到静态区变量</td>
<td>静态区</td>
</tr>
<tr>
<td><code>_NSConcreteStackBlock( __NSStackBlock__)</code></td>
<td>访问了自动变量</td>
<td>栈区</td>
</tr>
<tr>
<td><code>_NSConcreteMallocBlock(__NSMallocBlock__)</code></td>
<td><code>__NSStackBlock__</code>调用了<code>copy</code></td>
<td>堆区</td>
</tr>
</tbody></table>
<p>为了验证上述情况，我们需要切换到<code>MRC</code>环境下，因为在<code>ARC</code>环境下的编译器为我们做了很多优化的工作，比如自动将栈区的<code>Block</code>拷贝到堆区，这样我们也就不容易捕获到<code>Block</code>初始状态的位置了。</p>
<p>所以，这里暂时将开发环境切换至<code>MRC</code>下来测试，相关的测试代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)testBlock7 &#123;</span><br><span class="line">    <span class="comment">//1.Block内部没有调用外部自动变量</span></span><br><span class="line">    void (<span class="operator">^</span>block1)(void) <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Block&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.Block内部调用外部自动变量</span></span><br><span class="line">    int a <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    void (<span class="operator">^</span>block2)(void) <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Block-%d&quot;</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.拷贝栈上的block</span></span><br><span class="line">    void (<span class="operator">^</span>block3)(void) <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Block-%d&quot;</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印Block类型</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%@ %@ %@&quot;</span>, [block1 <span class="keyword">class</span>], [block2 <span class="keyword">class</span>], [[block3 <span class="keyword">copy</span>] <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//__NSGlobalBlock__ __NSStackBlock__ __NSMallocBlock__</span></span><br></pre></td></tr></table></figure>

<h5 id="1-NSGlobalBlock-静态区"><a href="#1-NSGlobalBlock-静态区" class="headerlink" title="1.NSGlobalBlock(静态区)"></a>1.<strong>NSGlobalBlock</strong>(静态区)</h5><ol>
<li>判断依据：<code>Block</code>中没有引用自动变量或者只用到静态区变量；</li>
<li>此类型的<code>Block</code>与全局变量一样设置在程序的静态区，直到程序结束才会被回收；</li>
<li>此类型的<code>Block</code>不依赖执行时的状态，所以整个程序只需一个实例，用的也较少；</li>
</ol>
<h5 id="2-NSStackBlock-栈区"><a href="#2-NSStackBlock-栈区" class="headerlink" title="2.NSStackBlock(栈区)"></a>2.<strong>NSStackBlock</strong>(栈区)</h5><ol>
<li>判断依据：<code>Block</code>中访问自动变量，并且存放在栈中；</li>
<li>栈中的内存由系统自动分配和释放，作用域执行完毕之后就会被立即释放；</li>
<li>所以我们有可能遇到<code>Block</code>内存销毁之后才使用它的情况，开发中遇到的很多问题也都是因此而起；</li>
</ol>
<h5 id="3-NSMallocBlock-堆区"><a href="#3-NSMallocBlock-堆区" class="headerlink" title="3.NSMallocBlock(堆区)"></a>3.<strong>NSMallocBlock</strong>(堆区)</h5><ol>
<li><code>_NSStackBlock__</code>执行<code>copy</code>操作会生成<code>__NSMallocBlock__</code>；</li>
<li>栈<code>Block</code>被拷贝后存放在堆中后，需要我们自己进行内存管理，否则还可能造成一些循环引用的问题；</li>
</ol>
<h4 id="五、分析Block的Copy原理"><a href="#五、分析Block的Copy原理" class="headerlink" title="五、分析Block的Copy原理"></a>五、分析Block的Copy原理</h4><p><code>Block</code>有着不同的存储域类型，尤其是配置在栈上的<code>Block</code>(即<code>__NSStackBlock__</code>类型的<code>Block</code>)，如果其所属的作用域结束，该<code>Block</code>就会被释放，此时若继续使用<code>Block</code>，就会造成野指针问题；</p>
<p>所以，我们通常的做法就是执行<code>copy</code>操作，将其由栈区拷贝到堆区得到<code>__NSMallocBlock__</code>，而<code>__NSMallocBlock__</code>也会在其引用计数为<code>0</code>的时候被释放；</p>
<p>进一步分析<code>Block</code>的拷贝，需要分为<code>MRC</code>和<code>ARC</code>两种环境来考虑。</p>
<h5 id="1-MRC下的Block拷贝"><a href="#1-MRC下的Block拷贝" class="headerlink" title="1.MRC下的Block拷贝"></a>1.MRC下的Block拷贝</h5><p>在<code>MRC</code>环境下，我们只能显式的通过<code>copy</code>来实现<code>Block</code>的拷贝；通常为了避免<code>Block</code>的释放，我们定义<code>Block</code>属性的时候必须使用<code>copy修饰符</code>也正是基于这个原因。</p>
<p>下面是在<code>MRC</code>环境下测试栈<code>Block</code>的使用，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">typedef void(<span class="operator">^</span><span class="type">PrintBlock</span>)(void);</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">ViewController</span> ()</span><br><span class="line"><span class="meta">@property</span> (nonatomic ,<span class="keyword">copy</span>)<span class="type">PrintBlock</span> block1;</span><br><span class="line"><span class="meta">@property</span> (nonatomic ,<span class="keyword">copy</span>)<span class="type">PrintBlock</span> block2;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">ViewController</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> createBlock];</span><br><span class="line">    <span class="keyword">self</span>.block1();</span><br><span class="line">    <span class="keyword">self</span>.block2();</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;block1:%@&quot;</span>, [<span class="keyword">self</span>.block1 <span class="keyword">class</span>]); <span class="comment">//报错Thread 1: EXC_BAD_ACCESS (code=1, address=0x7ffeeb90b8c0)</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;block2:%@&quot;</span>, [<span class="keyword">self</span>.block2 <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)createBlock &#123;</span><br><span class="line">    int a <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//此处采用直接赋值的方式，不会触发setter方法</span></span><br><span class="line">    _block1 <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;This is block1-%d&quot;</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.block2 <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;This is block2-%d&quot;</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//离开此作用域，block1就会被释放</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;block1:%@、block2:%@&quot;</span>, [<span class="keyword">self</span>.block1 <span class="keyword">class</span>],[<span class="keyword">self</span>.block2 <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>
<p>打印结果及分析如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">block1:__NSStackBlock__<span class="operator">、</span>block2:__NSMallocBlock__</span><br><span class="line"><span class="type">This</span> <span class="keyword">is</span> block1<span class="operator">-</span><span class="number">10</span></span><br><span class="line"><span class="type">This</span> <span class="keyword">is</span> block2<span class="operator">-</span><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>由于<code>block1</code>采用的是直接赋值的方式，没有调用<code>setter</code>方法，所以<code>block1</code>并没有被拷贝到堆上，是一个栈上的<code>Block</code>，这样也就直接导致了第二次打印<code>block1</code>时所发生的野指针崩溃；</p>
<h5 id="2-ARC下的Block拷贝"><a href="#2-ARC下的Block拷贝" class="headerlink" title="2.ARC下的Block拷贝"></a>2.ARC下的Block拷贝</h5><p>在<code>ARC</code>环境下，编译器会根据情况自动将栈上的<code>Block</code>复制到堆上，总结有以下几种情况:</p>
<ul>
<li><code>Block</code>作为函数返回值时；这就类似于<code>MRC</code>中对返回值<code>Block</code>执行了<code>[[returnedBlock copy] autorelease]</code>;</li>
<li><code>Block</code>被强引用，如<code>Block</code>被赋值给<code>__strong</code>或者<code>id</code>类型；</li>
<li><code>Block</code>作为<code>GCD API</code>的方法参数时；</li>
<li><code>Block</code>作为系统方法名含有<code>usingBlock</code>的方法参数时;</li>
</ul>
<p>下面的代码演示了这些情况：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">typedef void(<span class="operator">^</span><span class="type">Block</span>)(void);</span><br><span class="line"><span class="operator">-</span>(<span class="type">Block</span>)getBlock&#123;</span><br><span class="line">    <span class="comment">//ARC下的Block中访问了auto变量，此时block类型应为__NSStackBlock__</span></span><br><span class="line">   int a <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">return</span>  <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;---------%d&quot;</span>, a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)testBlock9 &#123;</span><br><span class="line">    <span class="comment">//1.测试block作为函数返回值时</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;bock1-：%@&quot;</span>,[[<span class="keyword">self</span> getBlock] <span class="keyword">class</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.测试将block赋值给__strong指针时</span></span><br><span class="line">    int a <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.1.block内没有访问auto变量</span></span><br><span class="line">    <span class="type">Block</span> block21 <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;block21&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;block21-%@&quot;</span>,[block21 <span class="keyword">class</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.2.block内访问了auto变量，但没有赋值给__strong指针</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;block22-%@&quot;</span>,[<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;block22-%d&quot;</span>, a);</span><br><span class="line">    &#125; <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3.block赋值给__strong指针</span></span><br><span class="line">    <span class="type">Block</span> block23 <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;block23&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;block23-%@&quot;</span>,[block23 <span class="keyword">class</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.block作为Cocoa API中方法名含有usingBlock的方法参数时</span></span><br><span class="line">    <span class="type">NSArray</span> <span class="operator">*</span>array <span class="operator">=</span> @[@<span class="string">&quot;1&quot;</span>,@<span class="string">&quot;2&quot;</span>,@<span class="string">&quot;3&quot;</span>];</span><br><span class="line">    [array enumerateObjectsUsingBlock:<span class="operator">^</span>(id  _Nonnull obj, <span class="type">NSUInteger</span> idx, <span class="type">BOOL</span> <span class="operator">*</span> _Nonnull stop) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.block作为GCD API的方法参数时</span></span><br><span class="line">    <span class="comment">//Block中的延时操作完成时，系统将会对Block进行释放</span></span><br><span class="line">    dispatch_after(dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, (int64_t)(<span class="number">2.0</span> <span class="operator">*</span> <span class="type">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), <span class="operator">^</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果如下:</span></span><br><span class="line"><span class="comment">//bock1-：__NSMallocBlock__</span></span><br><span class="line"><span class="comment">//block21-__NSGlobalBlock__</span></span><br><span class="line"><span class="comment">//block22-__NSStackBlock__</span></span><br><span class="line"><span class="comment">//block23-__NSGlobalBlock__</span></span><br></pre></td></tr></table></figure>

<h5 id="3-其他存储域Block的拷贝"><a href="#3-其他存储域Block的拷贝" class="headerlink" title="3.其他存储域Block的拷贝"></a>3.其他存储域Block的拷贝</h5><p>上面讲述的重点都于对栈<code>Blok</code>的拷贝，若是对于已经配置在堆上或者配置在静态区的上的<code>Block</code>调用<code>copy</code>方法又将如何呢？下面是不同存储域的<code>Block</code>执行<code>copy</code>进行的总结：</p>
<table>
<thead>
<tr>
<th><code>Block</code>类型</th>
<th>副本源的配置存储域</th>
<th>复制效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>_NSConcreteStackBlock</code></td>
<td>栈区</td>
<td>从栈复制到堆</td>
</tr>
<tr>
<td><code>_NSConcreteGlobalBlock</code></td>
<td>静态区</td>
<td>什么也不做</td>
</tr>
<tr>
<td><code>_NSConcreteMallocBlock</code></td>
<td>堆区</td>
<td>引用增加</td>
</tr>
</tbody></table>
<h5 id="4-总结Block需要拷贝的原理"><a href="#4-总结Block需要拷贝的原理" class="headerlink" title="4. 总结Block需要拷贝的原理"></a>4. 总结Block需要拷贝的原理</h5><p><code>Block</code>默认创建于其所在函数的函数栈上，所以当函数作用域结束时就会随之销毁；</p>
<p>在<code>MRC</code>环境下，没有编译器的优化，所以我们非常强调要使用<code>copy</code>将<code>Block</code>拷贝到堆上，从而避免<code>Block</code>在其作用域结束时被直接释放;</p>
<p>在<code>ARC</code>环境下，编译器会根据情况自动将栈上的<code>Block</code>复制到堆上，对于<code>Block</code>使用<code>copy</code>还是<code>strong</code>效果是一样的，所以写不写<code>copy</code>都行。在<code>ARC</code>环境下对于<code>Block</code>依然使用<code>copy</code>，更像是从<code>MRC</code>遗留下来的“传统”，时刻提醒我们：编译器自动对<code>Block</code>进行了拷贝操作。如果不写<code>copy</code> ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对<code>Block</code>进行了拷贝操作”，他们有可能会在调用之前自行拷贝属性值，这种操作多余而低效。</p>
<p>最后，总结<code>Block</code>修饰符的使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MRC下block属性的建议写法：</span></span><br><span class="line"><span class="meta">@property</span> (<span class="keyword">copy</span>, nonatomic) void (<span class="operator">^</span>block)(void);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ARC下block属性的建议写法：</span></span><br><span class="line"><span class="meta">@property</span> (strong, nonatomic) void (<span class="operator">^</span>block)(void);</span><br><span class="line"><span class="meta">@property</span> (<span class="keyword">copy</span>, nonatomic) void (<span class="operator">^</span>block)(void);</span><br></pre></td></tr></table></figure>



<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502-CH1-SW1">苹果官方Block文档</a></li>
<li><a href="https://halfrost.com/ios_block/#blockcopydispose">深入研究 Block 捕获外部变量和 __block 实现原理</a></li>
<li><a href="https://segmentfault.com/a/1190000009470922">Block 到底啥时候会崩溃</a></li>
<li><a href="https://www.aopod.com/2016/11/16/block-empty-checking/">为何调用block应先判空</a></li>
<li><a href="https://juejin.im/post/5b0181e15188254270643e88#heading-27">iOS底层原理总结 - 探寻block的本质(一)</a></li>
<li><a href="https://juejin.im/entry/5a73d832f265da4e9311502d">在block内如何修改block外部变量引发的思考</a></li>
<li><a href="https://blog.csdn.net/majianfei1023/article/details/46629065">二级指针的作用详解</a></li>
<li><a href="https://www.jianshu.com/p/da96ec752aee">iOS Block底层探索</a></li>
<li><a href="https://www.jianshu.com/p/1f22891f2e8f">iOS底层-Block底层原理</a></li>
<li><a href="https://opensource.apple.com/source/libclosure/">苹果开源代码-libClosure</a></li>
<li><a href="https://www.jianshu.com/p/11c90d6d9f02">漫谈Block(理解Block_layout)</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS底层</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS底层-Runtime基础篇</title>
    <url>/2019/04/15/iOS%E5%BA%95%E5%B1%82-Runtime%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p><strong>主要内容：</strong></p>
<ol>
<li>理解<code>OC</code>是动态语言特性</li>
<li>理解消息机制的基本原理</li>
<li>与<code>Runtime</code>交互的三种方式<span id="more"></span></li>
<li>分析<code>Runtime</code>中的数据结构</li>
<li>深入理解Rutime消息发送原理</li>
<li>多继承的实现思路<code>Rutime</code></li>
<li>参考链接</li>
</ol>
<h4 id="一、理解OC是动态语言特性"><a href="#一、理解OC是动态语言特性" class="headerlink" title="一、理解OC是动态语言特性"></a>一、理解OC是动态语言特性</h4><h5 id="1-静态语言和动态语言"><a href="#1-静态语言和动态语言" class="headerlink" title="1.静态语言和动态语言"></a>1.静态语言和动态语言</h5><p><strong>静态语言</strong>：如<code>C</code>语言，编译阶段就要决定调用哪个函数，如果函数未实现就会编译报错。</p>
<p><strong>动态语言</strong>：如<code>OC</code>语言，编译阶段并不能决定真正调用哪个函数，只要函数声明过即使没有实现也不会报错。</p>
<p>我们常说<code>OC</code>是一门动态语言，就是因为它总是把一些决定性的工作从编译阶段推迟到运行时阶段。例如：</p>
<ol>
<li>多态特性，我们可以使用父类指针指向子类对象，并且调用子类方法；</li>
<li>我们利用运行时特性，动态的添加方法、替换方法；</li>
</ol>
<h5 id="2-理解Runtime"><a href="#2-理解Runtime" class="headerlink" title="2. 理解Runtime"></a>2. 理解Runtime</h5><ol>
<li><code>Runtime</code>是一套由<code>C</code>、<code>C++</code>、汇编编实现的一套<code>API</code>，为<code>OC</code>提供运行时机制；</li>
<li>运行时（<code>runtime</code>）将类型的确定由编译时推迟到了运行时；</li>
<li><code>OC</code>代码最终都会被编译器转化为运行时代码，再通过消息机制决定函数调用方式，这也是<code>OC</code>作为动态语言使用的基础。</li>
</ol>
<p><code>OC</code>代码的运行不仅需要编译器，还需要运行时系统<code>(Runtime Sytem</code>)来执行编译后的代码。</p>
<h4 id="二、理解消息机制的基本原理"><a href="#二、理解消息机制的基本原理" class="headerlink" title="二、理解消息机制的基本原理"></a>二、理解消息机制的基本原理</h4><p><code>OC</code>的方法调用都是类似<code>[receiver selector]</code>的形式，其实每次都是一个运行时消息发送过程；</p>
<h5 id="1-第一步：编译阶段"><a href="#1-第一步：编译阶段" class="headerlink" title="1.第一步：编译阶段"></a>1.第一步：编译阶段</h5><p><code>[receiver selector]</code>方法被编译器转化，分为两种情况：</p>
<ol>
<li>不带参数的方法被编译为：<code>objc_msgSend(receiver，selector)</code>；</li>
<li>带参数的方法被编译为：<code>objc_msgSend(recevier，selector，org1，org2，…)</code>；</li>
</ol>
<h5 id="2-第二步：运行时阶段"><a href="#2-第二步：运行时阶段" class="headerlink" title="2.第二步：运行时阶段"></a>2.第二步：运行时阶段</h5><p>消息接收者<code>recever</code>寻找对应的<code>selector</code>，也分为两种情况：</p>
<ol>
<li>接收者能找到对应的<code>selector</code>，直接执行接收<code>receiver</code>对象的<code>selector</code>方法；</li>
<li>接收者找不到对应的<code>selector</code>，消息被转发或者临时向接收者添加这个<code>selector</code>对应的实现内容，否则崩溃；</li>
</ol>
<p><strong>说明：OC调用方法[receiver selector]，编译阶段确定了要向哪个接收者发送message消息，但是接收者如何响应决定于运行时的判断;</strong></p>
<h4 id="三、与Runtime的交互"><a href="#三、与Runtime的交互" class="headerlink" title="三、与Runtime的交互"></a>三、与Runtime的交互</h4><p><code>Runtime</code>的官方文档中将<code>OC</code>与<code>Runtime</code>的交互划分三种层次：</p>
<ol>
<li><code>OC</code>源代码</li>
<li><code>NSObject</code>方法</li>
<li><code>Runtime</code> 函数</li>
</ol>
<p>这其实也是按照与<code>Runtime</code>交互程度从低到高排序的三种方式;</p>
<h5 id="1-OC源代码-Objec-C-Source-Code"><a href="#1-OC源代码-Objec-C-Source-Code" class="headerlink" title="1.OC源代码(Objec-C Source Code)"></a>1.OC源代码(Objec-C Source Code)</h5><p>我们已经说过，<code>OC</code>代码会在编译阶段被编译器转化。<code>OC</code>中的类、方法和协议等在<code>Runtime</code>中都由一些数据结构来定义。所以，我们平时直接使用<code>OC</code>编写代码，其实这已经是在和<code>Runtime</code>进行交互了，只不过这个过程对于我们来说是无感的;</p>
<h5 id="2-NSObject方法-NSObject-Methods"><a href="#2-NSObject方法-NSObject-Methods" class="headerlink" title="2.NSObject方法(NSObject Methods)"></a>2.NSObject方法(NSObject Methods)</h5><p><code>Runtime</code>的最大特征就是实现了<code>OC</code>语言的动态特性。作为大部分<code>Objective-C</code>类继承体系的根类的<code>NSObject</code>，其本身就具有了一些非常具有运行时动态特性的方法，比如<code>respondsToSelector:</code>方法可以检查在代码运行阶段当前对象是否能响应指定的消息，所以使用这些方法也算是一种与<code>Runtme</code>的交互方式，类似的方法还有如下：</p>
<ul>
<li><code>-description</code>：返回当前类的描述信息</li>
<li><code>-class</code>：方法返回对象的类；</li>
<li><code>-isKindOfClass</code>和 <code>-isMemberOfClass</code>：检查对象是否存在于指定的类的继承体系中；</li>
<li><code>-respondsToSelector</code>：检查对象能否响应指定的消息；</li>
<li><code>-conformsToProtocol </code>：检查对象是否实现了指定协议类的方法；</li>
<li><code>-methodForSelector </code>：返回指定方法实现的地址；</li>
</ul>
<h5 id="3-使用Runtime函数-Runtime-Functions"><a href="#3-使用Runtime函数-Runtime-Functions" class="headerlink" title="3.使用Runtime函数(Runtime Functions)"></a>3.使用Runtime函数(Runtime Functions)</h5><p><code>Runtime</code>系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于<code>/usr/include/objc</code>目录下。在我们工程代码里引用<code>Runtime</code>的头文件，同样能够实现类似<code>OC</code>代码的效果，一些代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相当于：Class class = [UIView class];</span></span><br><span class="line"><span class="type">Class</span> viewClass <span class="operator">=</span> objc_getClass(<span class="string">&quot;UIView&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//相当于：UIView *view = [UIView alloc];</span></span><br><span class="line"><span class="type">UIView</span> <span class="operator">*</span>view <span class="operator">=</span> ((id (<span class="operator">*</span>)(id, <span class="type">SEL</span>))(void <span class="operator">*</span>)objc_msgSend)((id)viewClass, sel_registerName(<span class="string">&quot;alloc&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于：UIView *view = [view init];</span></span><br><span class="line">((id (<span class="operator">*</span>)(id, <span class="type">SEL</span>))(void <span class="operator">*</span>)objc_msgSend)((id)view, sel_registerName(<span class="string">&quot;init&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="三、分析Runtime中数据结构"><a href="#三、分析Runtime中数据结构" class="headerlink" title="三、分析Runtime中数据结构"></a>三、分析Runtime中数据结构</h4><p><code>OC</code>代码被编译器转化为<code>C</code>语言，然后再通过运行时执行，最终实现了动态调用。这其中的<code>OC</code>类、对象和方法等都对应了<code>C</code>中的结构体，而且我们都可以在<code>Rutime</code>源码中找到它们的定义。</p>
<p>那么，我们如何来查看<code>Runtime</code>的代码呢？其实很简单，只需要我们在当前代码文件中引用头文件：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</span><br><span class="line">#<span class="keyword">import</span> &lt;objc/message.h&gt;</span><br></pre></td></tr></table></figure>

<p>然后，我们需要使用组合键<code>&quot;Command +鼠标点击&quot;</code>，即可进入<code>Runtime</code>的源码文件，下面我们继续来一一分析<code>OC</code>代码在<code>C</code>中对应的结构。</p>
<h5 id="1-id—-objc-object"><a href="#1-id—-objc-object" class="headerlink" title="1.id—&gt;objc_object"></a>1.id—&gt;objc_object</h5><p><code>id</code>是一个指向<code>objc_object</code>结构体的指针，即在<code>Runtime</code>中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">///A pointer to an instance of a class.</span></span><br><span class="line">typedef <span class="keyword">struct</span> <span class="title class_">objc_object</span> <span class="operator">*</span>id;</span><br></pre></td></tr></table></figure>
<p>下面是<code>Runtime</code>中对<code>objc_object</code>结构体的具体定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">///Represents an instance of a class.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line">    <span class="type">Class</span> _Nonnull isa  <span class="type">OBJC_ISA_AVAILABILITY</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们都知道<code>id</code>在<code>OC</code>中是表示一个任意类型的类实例，从这里也可以看出，<code>OC</code>中的对象虽然没有明显的使用指针，但是在<code>OC</code>代码被编译转化为<code>C</code>之后，每个<code>OC</code>对象其实都是拥有一个<code>isa</code>的指针的；</p>
<h5 id="2-Class-objc-classs"><a href="#2-Class-objc-classs" class="headerlink" title="2.Class - &gt;objc_classs"></a>2.Class - &gt;objc_classs</h5><p><code>class</code>是一个指向<code>objc_class</code>结构体的指针，即在<code>Runtime</code>中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> <span class="title class_">objc_class</span> <span class="operator">*</span><span class="type">Class</span>; </span><br></pre></td></tr></table></figure>
<p>下面是<code>Runtime</code>中对<code>objc_class</code>结构体的具体定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//usr/include/objc/runtime.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> &#123;</span><br><span class="line">    <span class="type">Class</span> _Nonnull isa  <span class="type">OBJC_ISA_AVAILABILITY</span>;</span><br><span class="line"><span class="keyword">#if</span> <span class="operator">!</span><span class="type">OBJC2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="type">Nullable</span> super_<span class="keyword">class</span>                              <span class="title class_">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    const char <span class="operator">*</span> <span class="type">Nonnull</span> name                               <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    long version                                             <span class="type">OBJC2_UNAVAILABLE</span>;</span><br><span class="line">    long info                                                <span class="type">OBJC2_UNAVAILABLE</span>;</span><br><span class="line">    long instance_size                                       <span class="type">OBJC2_UNAVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_ivar_list</span> <span class="operator">*</span> <span class="type">Nullable</span> ivars                  <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_method_list</span> <span class="operator">*</span> <span class="type">Nullable</span> <span class="operator">*</span> _Nullable methodLists                    <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_cache</span> <span class="operator">*</span> <span class="type">Nonnull</span> cache                       <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">objc_protocol_list</span> <span class="operator">*</span> <span class="type">Nullable</span> protocols          <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">&#125; <span class="type">OBJC2_UNAVAILABLE</span>;</span><br></pre></td></tr></table></figure>

<p>理解<code>objc_class</code>定义中的参数：</p>
<p><strong>isa指针：</strong><br>我们会发现<code>objc_class</code>和<code>objc_object</code>同样是结构体，而且都拥有一个<code>isa</code>指针。我们很容易理解<code>objc_object</code>的<code>isa</code>指针指向对象的定义，那么<code>objc_class</code>的指针是怎么回事呢？</p>
<p>其实，在<code>Runtime</code>中<code>Objc</code>类本身同时也是一个对象。<code>Runtime</code>把类对象所属类型就叫做元类，用于描述类对象本身所具有的特征，最常见的类方法就被定义于此，所以<code>objc_class</code>中的<code>isa</code>指针指向的是元类，每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。</p>
<p><strong>super_class指针</strong>：指向<code>objc_class</code>类所继承的父类，但是如果当前类已经是最顶层的类(如<code>NSProxy</code>),则<code>super_class</code>指针为<code>NULL</code></p>
<p><strong>cache</strong>：为了优化性能，<code>objc_class</code>中的<code>cache</code>结构体用于记录每次使用类或者实例对象调用的方法。这样每次响应消息的时候，<code>Runtime</code>系统会优先在<code>cache</code>中寻找响应方法，相比直接在类的方法列表中遍历查找，效率更高;</p>
<p><strong>ivars</strong>：用于存放所有的成员变量和属性信息，属性的存取方法都存放在<code>methodLists</code>中。</p>
<p><strong>methodLists</strong>：用于存放对象的所有成员方法;</p>
<h5 id="3-SEL"><a href="#3-SEL" class="headerlink" title="3.SEL"></a>3.SEL</h5><p><code>SEL</code>是一个指向<code>objc_selector</code>结构体的指针，即在<code>Runtime</code>中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method selector.</span></span><br><span class="line">typedef <span class="keyword">struct</span> <span class="title class_">objc_selector</span> <span class="operator">*</span><span class="type">SEL</span>;</span><br></pre></td></tr></table></figure>
<p><code>SEL</code>在<code>OC</code>中称作方法选择器，用于表示运行时方法的名字，然而我们并不能在<code>Runtime</code>中找到它的结构体的详细定义。<code>Objective-C</code>在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是<code>SEL</code>；</p>
<p><strong>注意</strong>：</p>
<ol>
<li>不同类中相同名字的方法对应的方法选择器是相同的；</li>
<li>即使是同一个类中，方法名相同而变量类型不同也会导致它们具有相同的方法选择器；</li>
</ol>
<p>通常我们获取SEL有三种方法：</p>
<ol>
<li><code>OC</code>中，使用<code>@selector</code>(“方法名字符串”)；</li>
<li><code>OC</code>中，使用<code>NSSelectorFromString</code>(“方法名字符串”)；</li>
<li><code>Runtime</code>方法，使用<code>sel_registerName</code>(“方法名字符串”)；</li>
</ol>
<h5 id="4-Ivar"><a href="#4-Ivar" class="headerlink" title="4.Ivar"></a>4.Ivar</h5><p><code>Ivar</code>代表类中实例变量的类型，是一个指向<code>ojbcet_ivar</code>的结构体的指针，即在<code>Runtime</code>中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents an instance variable.</span></span><br><span class="line">typedef <span class="keyword">struct</span> <span class="title class_">objc_ivar</span> <span class="operator">*</span><span class="type">Ivar</span>;</span><br></pre></td></tr></table></figure>

<p>下面是<code>Runtime</code>中对<code>objc_ivar</code>结构体的具体定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_ivar</span> &#123;</span><br><span class="line">    char <span class="operator">*</span> <span class="type">Nullable</span> ivar_name                               <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    char <span class="operator">*</span> <span class="type">Nullable</span> ivar_type                               <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    int ivar_offset                                          <span class="type">OBJC2_UNAVAILABLE</span>;</span><br><span class="line">#ifdef <span class="type">LP64</span></span><br><span class="line">    int space                                                <span class="type">OBJC2_UNAVAILABLE</span>;</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">&#125;          </span><br></pre></td></tr></table></figure>

<p>我们在<code>objc_class</code>中看到的<code>ivars</code>成员列表,其中的元素就是<code>Ivar</code>，我可以通过实例查找其在类中的名字，这个过程被称为反射，下面的<code>class_copyIvarList</code>获取的不仅有实例变量还有属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="type">Ivar</span> <span class="operator">*</span>ivarList <span class="operator">=</span> class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line">    <span class="keyword">for</span> (int i<span class="operator">=</span> <span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="type">Ivar</span> ivar <span class="operator">=</span> ivarList[i];</span><br><span class="line">        const char <span class="operator">*</span>ivarName <span class="operator">=</span> ivar_getName(ivar);</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Ivar(%d): %@&quot;</span>, i, [<span class="type">NSString</span> stringWithUTF8String:ivarName]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivarList)；</span><br></pre></td></tr></table></figure>

<h5 id="5-Method"><a href="#5-Method" class="headerlink" title="5.Method"></a>5.Method</h5><p><code>Method</code>表示某个方法的类型，即在<code>Runtime</code>中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method in a class definition.</span></span><br><span class="line">typedef <span class="keyword">struct</span> <span class="title class_">objc_method</span> <span class="operator">*</span><span class="type">Method</span>;</span><br></pre></td></tr></table></figure>
<p>我们可以在<code>objct_class</code>定义中看到<code>methodLists</code>，其中的元素就是<code>Method</code>，下面是<code>Runtime</code>中<code>objc_method</code>结构体的具体定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_method</span> &#123;</span><br><span class="line">    <span class="type">SEL</span> <span class="type">Nonnull</span> method_name                                 <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    char <span class="operator">*</span> <span class="type">Nullable</span> method_types                            <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">    <span class="type">IMP</span> <span class="type">Nonnull</span> method_imp                                  <span class="type">OBJC2UNAVAILABLE</span>;</span><br><span class="line">&#125;                                                           <span class="type">OBJC2_UNAVAILABLE</span>;</span><br></pre></td></tr></table></figure>

<p>理解<code>objc_method</code>定义中的参数：</p>
<ul>
<li><code>method_name</code>:方法名类型<code>SEL</code>；</li>
<li><code>method_types</code>: 一个<code>char</code>指针，指向存储方法的参数类型和返回值类型；</li>
<li><code>method_imp</code>：本质上是一个指针，指向方法的实现；</li>
</ul>
<p>这里其实就是<code>SEL(method_name)</code>与<code>IMP(method_name)</code>形成了一个映射，通过<code>SEL</code>，我们可以很方便的找到方法实现<code>IMP</code>；</p>
<h5 id="6-IMP"><a href="#6-IMP" class="headerlink" title="6.IMP"></a>6.IMP</h5><p><code>IMP</code>是一个函数指针，它在<code>Runtime</code>中的定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A pointer to the function of a method implementation.</span></span><br><span class="line">typedef void (<span class="type">IMP</span>)(void <span class="operator">/</span> id, <span class="type">SEL</span>, <span class="operator">...</span> <span class="operator">*/</span> ); </span><br></pre></td></tr></table></figure>

<p><code>IMP</code>这个函数指针指向了方法实现的首地址，当<code>OC</code>发起消息后，最终执行的代码是由<code>IMP</code>指针决定的。利用这个特性，我们可以对代码进行优化：当需要大量重复调用方法的时候，我们可以绕开消息绑定而直接利用IMP指针调起方法，这样的执行将会更加高效，相关的代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">void (<span class="operator">*</span>setter)(id, <span class="type">SEL</span>, <span class="type">BOOL</span>);</span><br><span class="line">int i;</span><br><span class="line">setter <span class="operator">=</span> (void (<span class="operator">*</span>)(id, <span class="type">SEL</span>, <span class="type">BOOL</span>))[target methodForSelector:<span class="meta">@selector</span>(setFilled:)];</span><br><span class="line"><span class="keyword">for</span> ( i <span class="operator">=</span> <span class="number">0</span> ; i <span class="operator">&lt;</span> <span class="number">1000</span> ; i<span class="operator">++</span> )</span><br><span class="line">    setter(targetList[i], <span class="meta">@selector</span>(setFilled:), <span class="type">YES</span>);</span><br></pre></td></tr></table></figure>
<p>注意：这里需要注意的就是函数指针的前两个参数必须是<code>id</code>和<code>SEL</code>；</p>
<h4 id="四、深入理解Rutime消息发送"><a href="#四、深入理解Rutime消息发送" class="headerlink" title="四、深入理解Rutime消息发送"></a>四、深入理解Rutime消息发送</h4><p>我们在分析了<code>OC</code>语言对应的底层<code>C</code>结构之后，现在可以进一步理解运行时的消息发送机制。先前讲到，<code>OC</code>调用方法被编译转化为如下的形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">id _Nullable objc_msgSend(id _Nullable <span class="keyword">self</span>, <span class="type">SEL</span> _Nonnull op, <span class="operator">...</span>)</span><br></pre></td></tr></table></figure>

<p>其实，除了常见的objc_msgSend，消息发送的方法还有<code>objc_msgSend_stret</code>、<code>objc_msgSendSuper</code>、<code>objc_msgSendSuper_stret</code>等，如果消息传递给超类就使用带有<code>super</code>的方法，如果返回值是结构体而不是简单值就使用带有<code>stret</code>的值。</p>
<p><strong>运行时阶段的消息发送的详细步骤如下</strong>：</p>
<ol>
<li>检测<code>selector</code>是不是要忽略的。比如 <code>Mac OS X </code>开发，有了垃圾回收就不理会<code>retain</code>，<code>release</code> 这些函数了；</li>
<li>检测<code>target</code> 是不是<code>nil</code> 对象。<code>ObjC</code> 的特性是允许对一个 <code>nil</code>对象执行任何一个方法不会 <code>Crash</code>，因为会被忽略掉；</li>
<li>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，若可以找得到就跳到对应的函数去执行；</li>
<li>如果在<code>cache</code>里找不到就找一下方法列表<code>methodLists</code>；</li>
<li>如果<code>methodLists</code>找不到就到超类的方法列表里寻找，一直找，直到找到<code>NSObject</code>类为止。 </li>
<li>如果还找不到，<code>Runtime</code>就提供了如下三种方法来处理：<code>动态方法解析</code>、<code>消息接受者重定向</code>、<code>消息重定向</code>，这三种方法的调用关系如下图：</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/Runtime_message_forward.png" width="500" align=center/>

<h5 id="1-动态方法解析-Dynamic-Method-Resolution"><a href="#1-动态方法解析-Dynamic-Method-Resolution" class="headerlink" title="1.动态方法解析(Dynamic Method Resolution)"></a>1.动态方法解析(Dynamic Method Resolution)</h5><p>所谓动态解析，我们可以理解为通过<code>cache</code>和方法列表没有找到方法时，<code>Runtime</code>为我们提供一次动态添加方法实现的机会，主要用到的方法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OC方法：</span></span><br><span class="line"><span class="comment">//类方法未找到时调起，可于此添加类方法实现</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">BOOL</span>)resolveClassMethod:(<span class="type">SEL</span>)sel</span><br><span class="line"><span class="comment">//实例方法未找到时调起，可于此添加实例方法实现</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">BOOL</span>)resolveInstanceMethod:(<span class="type">SEL</span>)sel</span><br><span class="line"></span><br><span class="line"><span class="comment">//Runtime方法：</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 运行时方法：向指定类中添加特定方法实现的操作</span></span><br><span class="line"><span class="comment"> @param cls 被添加方法的类</span></span><br><span class="line"><span class="comment"> @param name selector方法名</span></span><br><span class="line"><span class="comment"> @param imp 指向实现方法的函数指针</span></span><br><span class="line"><span class="comment"> @param types imp函数实现的返回值与参数类型</span></span><br><span class="line"><span class="comment"> @return 添加方法是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">BOOL</span> class_addMethod(<span class="type">Class</span> _Nullable cls,</span><br><span class="line">                     <span class="type">SEL</span> _Nonnull name,</span><br><span class="line">                     <span class="type">IMP</span> _Nonnull imp,</span><br><span class="line">                     const char <span class="operator">*</span> _Nullable types)</span><br></pre></td></tr></table></figure>

<p>下面使用一个示例来说明动态解析：<code>Perosn</code>类中声明方法却未添加实现，我们通过<code>Runtime</code>动态方法解析的操作为其他添加方法实现，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person.h文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">Person</span> : <span class="type">NSObject</span></span><br><span class="line"><span class="comment">//声明类方法，但未实现</span></span><br><span class="line"><span class="operator">+</span> (void)haveMeal:(<span class="type">NSString</span> <span class="operator">*</span>)food;</span><br><span class="line"><span class="comment">//声明实例方法，但未实现</span></span><br><span class="line"><span class="operator">-</span> (void)singSong:(<span class="type">NSString</span> <span class="operator">*</span>)name;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person.m文件</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">import</span> &quot;Person.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</span><br><span class="line"><span class="meta">@implementation</span> <span class="type">Person</span></span><br><span class="line"><span class="comment">//重写父类方法：处理类方法</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">BOOL</span>)resolveClassMethod:(<span class="type">SEL</span>)sel&#123;</span><br><span class="line">    <span class="keyword">if</span>(sel <span class="operator">==</span> <span class="meta">@selector</span>(haveMeal:))&#123;</span><br><span class="line">        class_addMethod(object_getClass(<span class="keyword">self</span>), sel, class_getMethodImplementation(object_getClass(<span class="keyword">self</span>), <span class="meta">@selector</span>(zs_haveMeal:)), <span class="string">&quot;v@&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="type">YES</span>;   <span class="comment">//添加函数实现，返回YES</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [class_getSuperclass(<span class="keyword">self</span>) resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写父类方法：处理实例方法</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">BOOL</span>)resolveInstanceMethod:(<span class="type">SEL</span>)sel&#123;</span><br><span class="line">    <span class="keyword">if</span>(sel <span class="operator">==</span> <span class="meta">@selector</span>(singSong:))&#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, class_getMethodImplementation([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="meta">@selector</span>(zs_singSong:)), <span class="string">&quot;v@&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span> (void)zs_haveMeal:(<span class="type">NSString</span> <span class="operator">*</span>)food&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)zs_singSong:(<span class="type">NSString</span> <span class="operator">*</span>)name&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TestViewController.m文件</span></span><br><span class="line"><span class="comment">//测试：Peson调用并未实现的类方法、实例方法，并没有崩溃</span></span><br><span class="line"><span class="type">Person</span> <span class="operator">*</span>ps <span class="operator">=</span> [[<span class="type">Person</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[<span class="type">Person</span> haveMeal:@<span class="string">&quot;Apple&quot;</span>]; <span class="comment">//打印：+[Person zs_haveMeal:]</span></span><br><span class="line">[ps singSong:@<span class="string">&quot;纸短情长&quot;</span>];   <span class="comment">//打印：-[Person zs_singSong:]</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>我们注意到<code>class_addMethod</code>方法中的特殊参数<code>“v@”</code>，具体可参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">这里</a>；</li>
<li>成功使用动态方法解析还有个前提，那就是我们必须存在可以处理消息的方法，比如上述代码中的<code>zs_haveMeal:</code>与<code>zs_singSong:</code>;</li>
</ol>
<h5 id="2-消息接收者重定向"><a href="#2-消息接收者重定向" class="headerlink" title="2.消息接收者重定向"></a>2.消息接收者重定向</h5><p>我们注意到动态方法解析过程中的两个<code>resolve</code>方法都返回了布尔值，当它们返回<code>YES</code>时方法即可正常执行，但是若它们返回<code>NO</code>，消息发送机制就进入了消息转发(<code>Forwarding</code>)的阶段了，我们可以使用<code>Runtime</code>通过下面的方法替换消息接收者的为其他对象，从而保证程序的继续执行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重定向类方法的消息接收者，返回一个类</span></span><br><span class="line"><span class="operator">-</span> (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向实例方法的消息接受者，返回一个实例对象</span></span><br><span class="line"><span class="operator">-</span> (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector</span><br></pre></td></tr></table></figure>

<p>下面使用一个示例来说明消息接收者的重定向：</p>
<p>我们创建一个<code>Student</code>类，声明并实现<code>takeExam</code>、<code>learnKnowledge</code>两个方法，然后在视图控制器<code>TestViewController</code>(一个继承了<code>UIViewController</code>的自定义类)里测试，关键代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student.h文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">Student</span> : <span class="type">NSObject</span></span><br><span class="line"><span class="comment">//类方法：参加考试</span></span><br><span class="line"><span class="operator">+</span> (void)takeExam:(<span class="type">NSString</span> <span class="operator">*</span>)exam;</span><br><span class="line"><span class="comment">//实例方法：学习知识</span></span><br><span class="line"><span class="operator">-</span> (void)learnKnowledge:(<span class="type">NSString</span> <span class="operator">*</span>)course;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Student.m文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">Student</span></span><br><span class="line"><span class="operator">+</span> (void)takeExam:(<span class="type">NSString</span> <span class="operator">*</span>)exam&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">-</span> (void)learnKnowledge:(<span class="type">NSString</span> <span class="operator">*</span>)course&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TestViewConroller.m文件</span></span><br><span class="line"><span class="comment">//重定向类方法：返回一个类对象</span></span><br><span class="line"><span class="operator">+</span> (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector <span class="operator">==</span> <span class="meta">@selector</span>(takeExam:)) &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> [<span class="type">Student</span> <span class="keyword">class</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重定向实例方法：返回类的实例</span></span><br><span class="line"><span class="operator">-</span> (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector <span class="operator">==</span> <span class="meta">@selector</span>(learnKnowledge:)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在TestViewConroller的viewDidLoad中测试：</span></span><br><span class="line"><span class="comment">//调用并未声明和实现的类方法</span></span><br><span class="line">[<span class="type">TestViewController</span> performSelector:<span class="meta">@selector</span>(takeExam:) withObject:@<span class="string">&quot;语文&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用并未声明和实现的类方法</span></span><br><span class="line"><span class="keyword">self</span>.student <span class="operator">=</span> [[<span class="type">Student</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="meta">@selector</span>(learnKnowledge:) withObject:@<span class="string">&quot;天文学知识&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常打印:</span></span><br><span class="line"><span class="comment">// +[Student takeExam:]</span></span><br><span class="line"><span class="comment">// -[Student learnKnowledge:]</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：动态方法解析阶段返回<code>NO</code>时，我们可以通过<code>forwardingTargetForSelector</code>可以修改消息的接收者，该方法返回参数是一个对象，如果这个对象是非<code>nil</code>，非<code>self</code>，系统会将运行的消息转发给这个对象执行。否则，继续查找其他流程。</p>
<h5 id="3-消息重定向"><a href="#3-消息重定向" class="headerlink" title="3.消息重定向"></a>3.消息重定向</h5><p>当以上两种方法无法生效，那么这个对象会因为找不到相应的方法实现而无法响应消息，此时<code>Runtime</code>系统会通过<code>forwardInvocation:</code>消息通知该对象，给予此次消息发送最后一次寻找<code>IMP</code>的机会：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)forwardInvocation:(<span class="type">NSInvocation</span> <span class="operator">*</span>)anInvocation；</span><br></pre></td></tr></table></figure>

<p>其实每个对象都从<code>NSObject</code>类中继承了<code>forwardInvocation</code>：方法，但是<code>NSObject</code>中的这个方法只是简单的调用了<code>doesNotRecongnizeSelector:</code>方法，提示我们错误。所以我们可以重写这个方法：对不能处理的消息做一些默认处理，也可以将消息转发给其他对象来处理，而不抛出错误。</p>
<p>我们注意到<code>anInvocation</code>是<code>forwardInvocation</code>唯一参数，它封装了原始的消息和消息参数。正是因为它，我们还不得不重写另一个函数：<code>methodSignatureForSelector</code>。这是因为在<code>forwardInvocation:</code> 消息发送前，<code>Runtime</code>系统会向对象发送<code>methodSignatureForSelector</code>消息，并取到返回的方法签名用于生成<code>NSInvocation</code>对象。</p>
<p>下面使用一个示例来重新定义转发逻辑：在上面的<code>TestViewController</code>添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span>(void)forwardInvocation:(<span class="type">NSInvocation</span> <span class="operator">*</span>)anInvocation&#123;</span><br><span class="line">    <span class="comment">//1.从anInvocation中获取消息</span></span><br><span class="line">    <span class="type">SEL</span> sel <span class="operator">=</span> anInvocation.selector;</span><br><span class="line">    <span class="comment">//2.判断Student方法是否可以响应应sel</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.student respondsToSelector:sel]) &#123;</span><br><span class="line">        <span class="comment">//2.1若可以响应，则将消息转发给其他对象处理</span></span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>.student];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//2.2若仍然无法响应，则报错：找不到响应方法</span></span><br><span class="line">        [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要从这个方法中获取的信息来创建NSInvocation对象，因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">NSMethodSignature</span><span class="operator">*</span>)methodSignatureForSelector:(<span class="type">SEL</span>)aSelector&#123;</span><br><span class="line">    <span class="type">NSMethodSignature</span> <span class="operator">*</span>methodSignature <span class="operator">=</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>methodSignature) &#123;</span><br><span class="line">        methodSignature <span class="operator">=</span> [<span class="type">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v@:*&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> methodSignature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 然后再在视图控制器里直接调用<code>Student</code>的方法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//self是当前的TestViewController,调用了自己并不存在的learnKonwledge:方法</span></span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="meta">@selector</span>(learnKnowledge:) withObject:@<span class="string">&quot;天文学”];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//正常打印:</span></span><br><span class="line"><span class="string">//-[Student learnKnowledge:]</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><p>从以上的代码中就可以看出，<code>forwardingTargetForSelector</code>仅支持一个对象的返回，也就是说消息只能被转发给一个对象，而<code>forwardInvocation</code>可以将消息同时转发给任意多个对象，这就是两者的最大区别。</p>
</li>
<li><p>虽然理论上可以重载<code>doesNotRecognizeSelector</code>函数实现保证不抛出异常（不调用<code>super</code>实现），但是苹果文档着重提出“一定不能让这个函数就这么结束掉，必须抛出异常”。(If you override this method, you must call super or raise an <a href="https://developer.apple.com/documentation/foundation/nsexceptionname/1415426-invalidargumentexception">invalidArgumentException</a> exception at the end of your implementation. In other words, this method must not return normally; it must always result in an exception being thrown.)</p>
</li>
<li><p><code>forwardInvocation</code>甚至能够修改消息的内容，用于实现更加强大的功能;</p>
</li>
</ol>
<h4 id="六、多继承的实现思路：Runtime"><a href="#六、多继承的实现思路：Runtime" class="headerlink" title="六、多继承的实现思路：Runtime"></a>六、多继承的实现思路：Runtime</h4><p>我们会发现<code>Runtime</code>消息转发的一个特点：一个对象可以调起它本身不具备的方法。这个过程与<code>OC</code>中的继承特性很相似，其实官方文档中图示也很好的说明了这个问题：</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/Runtime_multiple_inheritance.png" width="500" align=center/>

<p>图中的<code>Warrior</code>通过<code>forwardInvocation</code>：将<code>negotiate</code>消息转发给了<code>Diplomat</code>，这就好像是<code>Warrior</code>使用了超类<code>Diplomat</code>的方法一样。所以从这个思路，我们可以在实际开发需求中模拟多继承的操作;</p>
<h4 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h4><ol>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048">Objective-C Runtime Programming Guide</a></li>
<li><a href="https://opensource.apple.com/tarballs/objc4/">Runtime官方源码下载</a></li>
<li><a href="https://www.jianshu.com/p/d2f589e3e1ef">objc4-781 源码编译以及调试</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS底层</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS底层-Runtime应用篇</title>
    <url>/2019/04/15/iOS%E5%BA%95%E5%B1%82-Runtime%E5%BA%94%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<p><strong>主要内容：</strong></p>
<ol>
<li><code>Runtime</code>应用场景</li>
<li>动态方法交换：<code>Method Swizzling </code></li>
<li>实现分类添加新属性<span id="more"></span></li>
<li>获取类的详细信息</li>
<li>解决同一方法高频率调用的效率问题</li>
<li>方法动态解析与消息转发</li>
<li>动态修改属性变量</li>
<li>优化自动归档和解档</li>
<li>实现字典与模型的转换</li>
</ol>
<h4 id="一、Runtime应用场景"><a href="#一、Runtime应用场景" class="headerlink" title="一、Runtime应用场景"></a>一、Runtime应用场景</h4><p>上篇讲述了<code>iOS</code>运行时<code>Runtime</code>基础，本篇将会总结<code>Rutime</code>的具体应用实例。</p>
<p>&#96;结合Runtime动态特性，其在开发中的应用大致分为以下几个方面：</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/Runtime_use_conditions.png" width="600" hegiht="300" align=center>

<h4 id="二、动态方法交换：Method-Swizzling"><a href="#二、动态方法交换：Method-Swizzling" class="headerlink" title="二、动态方法交换：Method Swizzling"></a>二、动态方法交换：Method Swizzling</h4><p>实现动态方法交换(<code>Method Swizzling</code>)是<code>Runtime</code>中最常见的应用场景，其原理是：通过<code>Runtime</code>获取到方法实现的地址，进而动态交换两个方法的功能。使用到关键方法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取类方法的Mthod</span></span><br><span class="line"><span class="type">Method</span> _Nullable class_getClassMethod(<span class="type">Class</span> _Nullable cls, <span class="type">SEL</span> _Nonnull name)</span><br><span class="line"><span class="comment">//获取实例对象方法的Mthod</span></span><br><span class="line"><span class="type">Method</span> _Nullable class_getInstanceMethod(<span class="type">Class</span> _Nullable cls, <span class="type">SEL</span> _Nonnull name)</span><br><span class="line"><span class="comment">//交换两个方法的实现</span></span><br><span class="line">void method_exchangeImplementations(<span class="type">Method</span> _Nonnull m1, <span class="type">Method</span> _Nonnull m2)</span><br></pre></td></tr></table></figure>

<h5 id="1-动态方法交换示例"><a href="#1-动态方法交换示例" class="headerlink" title="1.动态方法交换示例"></a>1.动态方法交换示例</h5><p>现在演示一个代码示例：在视图控制中，定义两个实例方法<code>printA</code>与<code>printB</code>，然后执行交换</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)printA&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印A......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)printB&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印B......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个实例方法的实现，并测试打印</span></span><br><span class="line"><span class="type">Method</span> methodA <span class="operator">=</span> class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="meta">@selector</span>(printA));</span><br><span class="line"><span class="type">Method</span> methodB <span class="operator">=</span> class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="meta">@selector</span>(printB));</span><br><span class="line">method_exchangeImplementations(methodA, methodB);</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> printA];  <span class="comment">//打印B......</span></span><br><span class="line">[<span class="keyword">self</span> printB];  <span class="comment">//打印A......</span></span><br></pre></td></tr></table></figure>

<h5 id="2-拦截并替换系统方法"><a href="#2-拦截并替换系统方法" class="headerlink" title="2.拦截并替换系统方法"></a>2.拦截并替换系统方法</h5><p><code>Runtime</code>动态方法交换更多的是应用于<code>系统类库</code>和<code>第三方框架</code>的方法替换。在不可见源码的情况下，我们可以借助<code>Rutime</code>交换方法实现，为原有方法添加额外功能，这在实际开发中具有十分重要的意义。</p>
<p>下面将展示一个拦截并替换系统方法的示例：为了实现不同机型上的字体都按照比例适配，我们可以拦截系统<code>UIFont</code>的<code>systemFontOfSize</code>方法，具体操作如下：</p>
<p>步骤1：在当前工程中添加<code>UIFont</code>的分类：<code>UIFont+Adapt</code>,并在其中添用以替换的方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span> (<span class="type">UIFont</span> <span class="operator">*</span>)zs_systemFontOfSize:(<span class="type">CGFloat</span>)fontSize&#123;</span><br><span class="line">    <span class="comment">//获取设备屏幕宽度，并计算出比例scale</span></span><br><span class="line">    <span class="type">CGFloat</span> width <span class="operator">=</span> [[<span class="type">UIScreen</span> mainScreen] bounds].size.width;</span><br><span class="line">    <span class="type">CGFloat</span> scale  <span class="operator">=</span> width<span class="operator">/</span><span class="number">375.0</span>;</span><br><span class="line">    <span class="comment">//注意：由于方法交换，系统的方法名已变成了自定义的方法名，所以这里使用了</span></span><br><span class="line">    <span class="comment">//自定义的方法名来获取UIFont</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="type">UIFont</span> zs_systemFontOfSize:fontSize <span class="operator">*</span> scale];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：在<code>UIFont</code>的分类中拦截系统方法，将其替换为我们自定义的方法，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//load方法不需要手动调用，iOS会在应用程序启动的时候自动调起load方法，</span></span><br><span class="line"><span class="comment">//而且load执行时间较早，所以在此方法中执行交换操作比较合适。</span></span><br><span class="line"><span class="operator">+</span> (void)load&#123;</span><br><span class="line">    <span class="comment">//获取系统方法地址</span></span><br><span class="line">    <span class="type">Method</span> sytemMethod <span class="operator">=</span> class_getClassMethod([<span class="type">UIFont</span> <span class="keyword">class</span>], <span class="meta">@selector</span>(systemFontOfSize:));</span><br><span class="line">    <span class="comment">//获取自定义方法地址</span></span><br><span class="line">    <span class="type">Method</span> customMethod <span class="operator">=</span> class_getClassMethod([<span class="type">UIFont</span> <span class="keyword">class</span>], <span class="meta">@selector</span>(zs_systemFontOfSize:));</span><br><span class="line">    <span class="comment">//交换两个方法的实现</span></span><br><span class="line">    method_exchangeImplementations(sytemMethod, customMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加一段测试代码，切换不同的模拟器，观察在不同机型上文字的大小：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UILabel</span> <span class="operator">*</span>label <span class="operator">=</span> [[<span class="type">UILabel</span> alloc] initWithFrame:<span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">50</span>)];</span><br><span class="line">label.text <span class="operator">=</span> @<span class="string">&quot;测试Runtime拦截方法&quot;</span>;</span><br><span class="line">label.font <span class="operator">=</span> [<span class="type">UIFont</span> systemFontOfSize:<span class="number">20</span>];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:label];</span><br></pre></td></tr></table></figure>
<p>这里只是一个简单的示例，详细的用法可参考：</p>
<h4 id="三、实现分类添加新属性"><a href="#三、实现分类添加新属性" class="headerlink" title="三、实现分类添加新属性"></a>三、实现分类添加新属性</h4><p>我们在开发中常常使用类目<code>Category</code>为一些已有的类扩展功能。虽然继承也能够为已有类增加新的方法，而且相比类目更是具有增加属性的优势，但是继承毕竟是一个重量级的操作，添加不必要的继承关系无疑增加了代码的复杂度。</p>
<p>遗憾的是，<code>OC</code>的类目并不支持直接添加属性，如果我们直接在分类的声明中写入<code>Property</code>属性，那么只能为其生成<code>set</code>与<code>get</code>方法声明，却不能生成成员变量，直接调用这些属性还会造成崩溃。</p>
<p>所以为了实现给分类添加属性，我们还需借助<code>Runtime</code>的关联对象(<code>Associated Objects</code>)特性，它能够帮助我们在运行阶段将任意的属性关联到一个对象上，下面是相关的三个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 1.给对象设置关联属性</span></span><br><span class="line"><span class="comment"> @param object 需要设置关联属性的对象，即给哪个对象关联属性</span></span><br><span class="line"><span class="comment"> @param key 关联属性对应的key，可通过key获取这个属性，</span></span><br><span class="line"><span class="comment"> @param value 给关联属性设置的值</span></span><br><span class="line"><span class="comment"> @param policy 关联属性的存储策略(对应Property属性中的assign,copy，retain等)</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_ASSIGN             @property(assign)。</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_RETAIN_NONATOMIC   @property(strong, nonatomic)。</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_COPY_NONATOMIC     @property(copy, nonatomic)。</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_RETAIN             @property(strong,atomic)。</span></span><br><span class="line"><span class="comment"> OBJC_ASSOCIATION_COPY               @property(copy, atomic)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">void objc_setAssociatedObject(id _Nonnull object,</span><br><span class="line">                              const void <span class="operator">*</span> _Nonnull key,</span><br><span class="line">                              id _Nullable value,</span><br><span class="line">                              objc_AssociationPolicy policy)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2.通过key获取关联的属性</span></span><br><span class="line"><span class="comment"> @param object 从哪个对象中获取关联属性</span></span><br><span class="line"><span class="comment"> @param key 关联属性对应的key</span></span><br><span class="line"><span class="comment"> @return 返回关联属性的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">id _Nullable objc_getAssociatedObject(id _Nonnull object,</span><br><span class="line">                                      const void <span class="operator">*</span> _Nonnull key)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 3.移除对象所关联的属性</span></span><br><span class="line"><span class="comment"> @param object 移除某个对象的所有关联属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">void objc_removeAssociatedObjects(id _Nonnull object)</span><br></pre></td></tr></table></figure>

<p>注意：<code>key</code>与关联属性一一对应，我们必须确保其全局唯一性；</p>
<p>现在演示一个代码示例：为<code>*UIImage*</code>增加一个分类：<code>UIImage+Tools</code>，并为其设置关联属性<code>urlString</code>(图片网络链接属性），相关代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UIImage+Tools.h文件中</span></span><br><span class="line"><span class="type">UIImage</span><span class="operator">+</span><span class="type">Tools</span>.m</span><br><span class="line"><span class="meta">@interface</span> <span class="type">UIImage</span> (<span class="type">Tools</span>)</span><br><span class="line"><span class="comment">//添加一个新属性：图片网络链接</span></span><br><span class="line"><span class="meta">@property</span>(nonatomic,<span class="keyword">copy</span>)<span class="type">NSString</span> <span class="operator">*</span>urlString;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UIImage+Tools.m文件中</span></span><br><span class="line">#<span class="keyword">import</span> &quot;UIImage+Tools.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</span><br><span class="line"><span class="meta">@implementation</span> <span class="type">UIImage</span> (<span class="type">Tools</span>)</span><br><span class="line"><span class="comment">//set方法</span></span><br><span class="line"><span class="operator">-</span> (void)setUrlString:(<span class="type">NSString</span> <span class="operator">*</span>)urlString&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>,</span><br><span class="line">                             <span class="meta">@selector</span>(urlString),</span><br><span class="line">                             urlString,</span><br><span class="line">                             <span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">NSString</span> <span class="operator">*</span>)urlString&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>,</span><br><span class="line">                                    <span class="meta">@selector</span>(urlString));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加一个自定义方法，用于清除所有关联属性</span></span><br><span class="line"><span class="operator">-</span> (void)clearAssociatedObjcet&#123;</span><br><span class="line">    objc_removeAssociatedObjects(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<p> 测试文件中:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIImage</span> <span class="operator">*</span>image <span class="operator">=</span> [[<span class="type">UIImage</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">image.urlString <span class="operator">=</span> @<span class="string">&quot;http://www.image.png&quot;</span>;</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;获取关联属性：%@&quot;</span>,image.urlString);</span><br><span class="line">    </span><br><span class="line">[image clearAssociatedObjcet];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;获取关联属性：%@&quot;</span>,image.urlString);</span><br><span class="line"><span class="comment">//打印：</span></span><br><span class="line"><span class="comment">//获取关联属性：http://www.image.png</span></span><br><span class="line"><span class="comment">//获取关联属性：(null)</span></span><br></pre></td></tr></table></figure>



<h4 id="四、获取类的详细信息"><a href="#四、获取类的详细信息" class="headerlink" title="四、获取类的详细信息"></a>四、获取类的详细信息</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">ClassA</span> : <span class="type">NSObject</span> &#123;</span><br><span class="line"> int _a;</span><br><span class="line"> int _b;</span><br><span class="line"> int _c;</span><br><span class="line"> <span class="type">CGFloat</span> d; <span class="comment">//不推荐这样写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong) <span class="type">NSArray</span>          <span class="operator">*</span>arrayA;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="keyword">copy</span>  ) <span class="type">NSString</span>         <span class="operator">*</span>stringA;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, assign) dispatch_queue_t testQueue;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">ClassA</span></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<h5 id="1-获取所有成员变量"><a href="#1-获取所有成员变量" class="headerlink" title="1.获取所有成员变量"></a>1.获取所有成员变量</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Ivar</span> <span class="operator">*</span>ivarList <span class="operator">=</span> class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line"><span class="keyword">for</span> (int i<span class="operator">=</span> <span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">    <span class="type">Ivar</span> ivar <span class="operator">=</span> ivarList[i];</span><br><span class="line">    const char <span class="operator">*</span>ivarName <span class="operator">=</span> ivar_getName(ivar);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;Ivar(%d): %@&quot;</span>, i, [<span class="type">NSString</span> stringWithUTF8String:ivarName]);</span><br><span class="line">&#125;</span><br><span class="line">free(ivarList);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">_a</span></span><br><span class="line"><span class="comment">_b</span></span><br><span class="line"><span class="comment">_c</span></span><br><span class="line"><span class="comment">d</span></span><br><span class="line"><span class="comment">_arrayA</span></span><br><span class="line"><span class="comment">_stringA</span></span><br><span class="line"><span class="comment">_testQueue</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="2-获取属性列表"><a href="#2-获取属性列表" class="headerlink" title="2.获取属性列表"></a>2.获取属性列表</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">unsigned int count;</span><br><span class="line">objc_property_t <span class="operator">*</span>propertyList <span class="operator">=</span> class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line"><span class="keyword">for</span> (unsigned int i <span class="operator">=</span> <span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">    const char <span class="operator">*</span>propertyName <span class="operator">=</span> property_getName(propertyList[i]);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;PropertyName(%d): %@&quot;</span>,i,[<span class="type">NSString</span> stringWithUTF8String:propertyName]);</span><br><span class="line">&#125;</span><br><span class="line">free(propertyList);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">arrayA</span></span><br><span class="line"><span class="comment">stringA</span></span><br><span class="line"><span class="comment">testQueue</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="3-获取所有方法"><a href="#3-获取所有方法" class="headerlink" title="3.获取所有方法"></a>3.获取所有方法</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="operator">*</span>methodList <span class="operator">=</span> class_copyMethodList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line"><span class="keyword">for</span> (unsigned int i <span class="operator">=</span> <span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">    <span class="type">Method</span> method <span class="operator">=</span> methodList[i];</span><br><span class="line">    <span class="type">SEL</span> mthodName <span class="operator">=</span> method_getName(method);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;MethodName(%d): %@&quot;</span>,i,<span class="type">NSStringFromSelector</span>(mthodName));</span><br><span class="line">&#125;</span><br><span class="line">free(methodList);</span><br></pre></td></tr></table></figure>

<h5 id="4-获取当前遵循的所有协议"><a href="#4-获取当前遵循的所有协议" class="headerlink" title="4.获取当前遵循的所有协议"></a>4.获取当前遵循的所有协议</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">__unsafe_unretained <span class="type">Protocol</span> <span class="operator">**</span>protocolList <span class="operator">=</span> class_copyProtocolList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line"><span class="keyword">for</span> (int i<span class="operator">=</span><span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">    <span class="type">Protocol</span> <span class="operator">*</span>protocal <span class="operator">=</span> protocolList[i];</span><br><span class="line">    const char <span class="operator">*</span>protocolName <span class="operator">=</span> protocol_getName(protocal);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;protocol(%d): %@&quot;</span>,i, [<span class="type">NSString</span> stringWithUTF8String:protocolName]);</span><br><span class="line">&#125;</span><br><span class="line">free(propertyList);</span><br></pre></td></tr></table></figure>

<p><strong>注意：C语言中使用Copy操作的方法，要注意释放指针，防止内存泄漏</strong></p>
<h4 id="五、解决同一方法高频率调用的效率问题"><a href="#五、解决同一方法高频率调用的效率问题" class="headerlink" title="五、解决同一方法高频率调用的效率问题"></a>五、解决同一方法高频率调用的效率问题</h4><p><code>Runtime</code>源码中的<code>IMP</code>作为函数指针，指向方法的实现。通过它，我们可以绕开发送消息的过程来提高函数调用的效率。当我们需要持续大量重复调用某个方法的时候，会十分有用，具体代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">void (<span class="operator">*</span>setter)(id, <span class="type">SEL</span>, <span class="type">BOOL</span>);</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">setter <span class="operator">=</span> (void (<span class="operator">*</span>)(id, <span class="type">SEL</span>, <span class="type">BOOL</span>))[target methodForSelector:<span class="meta">@selector</span>(setFilled:)];</span><br><span class="line"><span class="keyword">for</span> ( i <span class="operator">=</span> <span class="number">0</span> ; i <span class="operator">&lt;</span> <span class="number">1000</span> ; i<span class="operator">++</span> )</span><br><span class="line">    setter(targetList[i], <span class="meta">@selector</span>(setFilled:), <span class="type">YES</span>);</span><br></pre></td></tr></table></figure>



<h4 id="六、方法动态解析与消息转发"><a href="#六、方法动态解析与消息转发" class="headerlink" title="六、方法动态解析与消息转发"></a>六、方法动态解析与消息转发</h4><p>其实该部分可以参考基础篇中内容，这里不再重复赘述，只是大概做出一些总结。</p>
<h5 id="1-动态方法解析：动态添加方法"><a href="#1-动态方法解析：动态添加方法" class="headerlink" title="1.动态方法解析：动态添加方法"></a>1.动态方法解析：动态添加方法</h5><p><code>Runtime</code>足够强大，能够让我们在运行时动态添加一个未实现的方法，这个功能主要有两个应用场景：</p>
<p>场景1：动态添加未实现方法，解决代码中因为方法未找到而报错的问题；</p>
<p>场景2：利用懒加载思路，若一个类有很多个方法，同时加载到内存中会耗费资源，可以使用动态解析添加方法。方法动态解析主要用到的方法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OC方法：</span></span><br><span class="line"><span class="comment">//类方法未找到时调起，可于此添加类方法实现</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">BOOL</span>)resolveClassMethod:(<span class="type">SEL</span>)sel</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例方法未找到时调起，可于此添加实例方法实现</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">BOOL</span>)resolveInstanceMethod:(<span class="type">SEL</span>)sel</span><br><span class="line"></span><br><span class="line"><span class="comment">//Runtime方法：</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 运行时方法：向指定类中添加特定方法实现的操作</span></span><br><span class="line"><span class="comment"> @param cls 被添加方法的类</span></span><br><span class="line"><span class="comment"> @param name selector方法名</span></span><br><span class="line"><span class="comment"> @param imp 指向实现方法的函数指针</span></span><br><span class="line"><span class="comment"> @param types imp函数实现的返回值与参数类型</span></span><br><span class="line"><span class="comment"> @return 添加方法是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">BOOL</span> class_addMethod(<span class="type">Class</span> _Nullable cls,</span><br><span class="line">                     <span class="type">SEL</span> _Nonnull name,</span><br><span class="line">                     <span class="type">IMP</span> _Nonnull imp,</span><br><span class="line">                     const char <span class="operator">*</span> _Nullable types)</span><br></pre></td></tr></table></figure>

<h5 id="2-解决方法无响应崩溃问题"><a href="#2-解决方法无响应崩溃问题" class="headerlink" title="2.解决方法无响应崩溃问题"></a>2.解决方法无响应崩溃问题</h5><p>执行<code>OC</code>方法其实就是一个发送消息的过程，若方法未实现，我们可以利用方法动态解析与消息转发来避免程序崩溃，这主要涉及下面一个处理未实现消息的过程：</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/Runtime_message_forward.png" width="600" align=center>

<p>除了上述的方法动态解析，还使用到的相关方法如下：</p>
<p>消息接收者重定向</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重定向类方法的消息接收者，返回一个类</span></span><br><span class="line"><span class="operator">-</span> (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向实例方法的消息接受者，返回一个实例对象</span></span><br><span class="line"><span class="operator">-</span> (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector</span><br></pre></td></tr></table></figure>

<p>消息重定向</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)forwardInvocation:(<span class="type">NSInvocation</span> <span class="operator">*</span>)anInvocation；</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">NSMethodSignature</span><span class="operator">*</span>)methodSignatureForSelector:(<span class="type">SEL</span>)aSelector;</span><br></pre></td></tr></table></figure>



<h4 id="七、动态修改属性变量"><a href="#七、动态修改属性变量" class="headerlink" title="七、动态修改属性变量"></a>七、动态修改属性变量</h4><p>现在假设这样一个情况：我们使用第三方框架里的<code>Person</code>类，在特殊需求下想要更改其私有属性<code>nickName</code>，这样的操作我们就可以使用<code>Runtime</code>可以动态修改对象属性。</p>
<p>基本思路：首先使用<code>Runtime</code>获取<code>Peson</code>对象的所有属性，找到<code>nickName</code>，然后使用<code>ivar</code>的方法修改其值。具体的代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="operator">*</span>ps <span class="operator">=</span> [[<span class="type">Person</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;ps-nickName: %@&quot;</span>,[ps valueForKey:@<span class="string">&quot;nickName&quot;</span>]); <span class="comment">//null</span></span><br><span class="line"><span class="comment">//第一步：遍历对象的所有属性</span></span><br><span class="line">unsigned int count;</span><br><span class="line"><span class="type">Ivar</span> <span class="operator">*</span>ivarList <span class="operator">=</span> class_copyIvarList([ps <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line"><span class="keyword">for</span> (int i<span class="operator">=</span> <span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">    <span class="comment">//第二步：获取每个属性名</span></span><br><span class="line">    <span class="type">Ivar</span> ivar <span class="operator">=</span> ivarList[i];</span><br><span class="line">    const char <span class="operator">*</span>ivarName <span class="operator">=</span> ivar_getName(ivar);</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>propertyName <span class="operator">=</span> [<span class="type">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">    <span class="keyword">if</span> ([propertyName isEqualToString:@<span class="string">&quot;_nickName&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">//第三步：匹配到对应的属性，然后修改；注意属性带有下划线</span></span><br><span class="line">        object_setIvar(ps, ivar, @<span class="string">&quot;梧雨北辰&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;ps-nickName: %@&quot;</span>,[ps valueForKey:@<span class="string">&quot;nickName&quot;</span>]); <span class="comment">//梧雨北辰</span></span><br></pre></td></tr></table></figure>

<p>总结：此过程类似<code>KVC</code>的取值和赋值</p>
<h4 id="八、优化自动归档和解档"><a href="#八、优化自动归档和解档" class="headerlink" title="八、优化自动归档和解档"></a>八、优化自动归档和解档</h4><p>归档是一种常用的轻量型文件存储方式，但是它有个弊端：在归档过程中，若一个<code>Model</code>有多个属性，我们不得不对每个属性进行处理，非常繁琐。</p>
<p>归档操作主要涉及两个方法：<code>encodeObject</code> 和 <code>decodeObjectForKey</code>，现在，我们可以利用<code>Runtime</code>来改进它们，关键的代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原理：使用Runtime动态获取所有属性</span></span><br><span class="line"><span class="comment">//解档操作</span></span><br><span class="line"><span class="operator">-</span> (instancetype)initWithCoder:(<span class="type">NSCoder</span> <span class="operator">*</span>)aDecoder&#123;</span><br><span class="line">    <span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        unsigned int count <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Ivar</span> <span class="operator">*</span>ivarList <span class="operator">=</span> class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> count; i<span class="operator">++</span>) &#123;</span><br><span class="line">            <span class="type">Ivar</span> ivar <span class="operator">=</span> ivarList[i];</span><br><span class="line">            const char <span class="operator">*</span>ivarName <span class="operator">=</span> ivar_getName(ivar);</span><br><span class="line">            <span class="type">NSString</span> <span class="operator">*</span>key <span class="operator">=</span> [<span class="type">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">            id value <span class="operator">=</span> [aDecoder decodeObjectForKey:key];</span><br><span class="line">            [<span class="keyword">self</span> setValue:value forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivarList); <span class="comment">//释放指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归档操作</span></span><br><span class="line"><span class="operator">-</span> (void)encodeWithCoder:(<span class="type">NSCoder</span> <span class="operator">*</span>)aCoder&#123;</span><br><span class="line">    unsigned int count <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Ivar</span> <span class="operator">*</span>ivarList <span class="operator">=</span> class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">NSInteger</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> count; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="type">Ivar</span> ivar <span class="operator">=</span> ivarList[i];</span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>key <span class="operator">=</span> [<span class="type">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        </span><br><span class="line">        id value <span class="operator">=</span> [<span class="keyword">self</span> valueForKey:key];</span><br><span class="line">        [aCoder encodeObject:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivarList); <span class="comment">//释放指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是有关归档的测试代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--测试归档</span></span><br><span class="line"><span class="type">Person</span> <span class="operator">*</span>ps <span class="operator">=</span> [[<span class="type">Person</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">ps.name <span class="operator">=</span> @<span class="string">&quot;梧雨北辰&quot;</span>;</span><br><span class="line">ps.age  <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"><span class="type">NSString</span> <span class="operator">*</span>temp <span class="operator">=</span> <span class="type">NSTemporaryDirectory</span>();</span><br><span class="line"><span class="type">NSString</span> <span class="operator">*</span>fileTemp <span class="operator">=</span> [temp stringByAppendingString:@<span class="string">&quot;person.archive&quot;</span>];</span><br><span class="line">[<span class="type">NSKeyedArchiver</span> archiveRootObject:ps toFile:fileTemp];</span><br><span class="line"></span><br><span class="line"><span class="comment">//--测试解档</span></span><br><span class="line"><span class="type">NSString</span> <span class="operator">*</span>temp <span class="operator">=</span> <span class="type">NSTemporaryDirectory</span>();</span><br><span class="line"><span class="type">NSString</span> <span class="operator">*</span>fileTemp <span class="operator">=</span> [temp stringByAppendingString:@<span class="string">&quot;person.henry&quot;</span>];</span><br><span class="line"><span class="type">Person</span> <span class="operator">*</span>person <span class="operator">=</span> [<span class="type">NSKeyedUnarchiver</span> unarchiveObjectWithFile:fileTemp];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;person-name:%@，person-age:%ld&quot;</span>,person.name,person.age); </span><br><span class="line"><span class="comment">//person-name:梧雨北辰，person-age:18</span></span><br></pre></td></tr></table></figure>



<h4 id="九、实现字典与模型的转换"><a href="#九、实现字典与模型的转换" class="headerlink" title="九、实现字典与模型的转换"></a>九、实现字典与模型的转换</h4><p>字典数据转模型的操作在项目开发中很常见，通常我们会选择第三方如<code>YYModel</code>；其实我们也可以自己来实现这一功能，主要的思路有两种：<code>KVC</code>、<code>Runtime</code>，总结字典转化模型过程中需要解决的问题如下：</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/Runtime_use_dic_model_analyze.png" width="600" hegiht="300" align=center>

<p>现在，我们使用<code>Runtime</code>来实现字典转模型的操作，大致的思路是这样：</p>
<p>借助<code>Runtime</code>可以动态获取成员列表的特性，遍历模型中所有属性，然后以获取到的属性名为<code>key</code>，在<code>JSON</code>字典中寻找对应的值<code>value</code>；再将每一个对应<code>Value</code>赋值给模型，就完成了字典转模型的目的。</p>
<p>首先准备下面的<code>JSON</code>数据用于测试：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:<span class="string">&quot;2462079046&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;梧雨北辰&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>,</span><br><span class="line">    <span class="string">&quot;weight&quot;</span>:<span class="number">140</span>,</span><br><span class="line">    <span class="string">&quot;address&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;country&quot;</span>:<span class="string">&quot;中国&quot;</span>,</span><br><span class="line">            <span class="string">&quot;province&quot;</span>: <span class="string">&quot;河南&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">    <span class="string">&quot;courses&quot;</span>:[&#123;</span><br><span class="line">               <span class="string">&quot;name&quot;</span>:<span class="string">&quot;Chinese&quot;</span>,</span><br><span class="line">               <span class="string">&quot;desc&quot;</span>:<span class="string">&quot;语文课&quot;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">               <span class="string">&quot;name&quot;</span>:<span class="string">&quot;Math&quot;</span>,</span><br><span class="line">               <span class="string">&quot;desc&quot;</span>:<span class="string">&quot;数学课&quot;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">               <span class="string">&quot;name&quot;</span>:<span class="string">&quot;English&quot;</span>,</span><br><span class="line">               <span class="string">&quot;desc&quot;</span>:<span class="string">&quot;英语课&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的代码实现流程如下：</p>
<h5 id="步骤1：创建NSObject的类目NSObject-ZSModel，用于实现字典转模型"><a href="#步骤1：创建NSObject的类目NSObject-ZSModel，用于实现字典转模型" class="headerlink" title="步骤1：创建NSObject的类目NSObject+ZSModel，用于实现字典转模型"></a>步骤1：创建NSObject的类目NSObject+ZSModel，用于实现字典转模型</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">NSObject</span> (<span class="type">ZSModel</span>)</span><br><span class="line"><span class="operator">+</span> (instancetype)zs_modelWithDictionary:(<span class="type">NSDictionary</span> <span class="operator">*</span>)dictionary;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ZSModel协议，协议方法可以返回一个字典，表明特殊字段的处理规则</span></span><br><span class="line"><span class="meta">@protocol</span> <span class="type">ZSModel</span>&lt;<span class="type">NSObject</span>&gt;</span><br><span class="line"><span class="meta">@optional</span></span><br><span class="line"><span class="operator">+</span> (nullable <span class="type">NSDictionary</span>&lt;<span class="type">NSString</span> *, id&gt; <span class="operator">*</span>)modelContainerPropertyGenericClass;</span><br><span class="line"><span class="meta">@end</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &quot;NSObject+ZSModel.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</span><br><span class="line"><span class="meta">@implementation</span> <span class="type">NSObject</span> (<span class="type">ZSModel</span>)</span><br><span class="line"><span class="operator">+</span> (instancetype)zs_modelWithDictionary:(<span class="type">NSDictionary</span> <span class="operator">*</span>)dictionary&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建当前模型对象</span></span><br><span class="line">    id object <span class="operator">=</span> [[<span class="keyword">self</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="comment">//1.获取当前对象的成员变量列表</span></span><br><span class="line">    unsigned int count <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Ivar</span> <span class="operator">*</span>ivarList <span class="operator">=</span> class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="operator">&amp;</span>count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.遍历ivarList中所有成员变量，以其属性名为key，在字典中查找Value</span></span><br><span class="line">    <span class="keyword">for</span> (int i<span class="operator">=</span> <span class="number">0</span>; i<span class="operator">&lt;</span>count; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="comment">//2.1获取成员属性</span></span><br><span class="line">        <span class="type">Ivar</span> ivar <span class="operator">=</span> ivarList[i];</span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>ivarName <span class="operator">=</span> [<span class="type">NSString</span> stringWithUTF8String:ivar_getName(ivar)] ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.2截取成员变量名：去掉成员变量前面的&quot;_&quot;号</span></span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>propertyName <span class="operator">=</span> [ivarName substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.3以属性名为key，在字典中查找value</span></span><br><span class="line">        id value <span class="operator">=</span> dictionary[propertyName];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取成员变量类型, 因为ivar_getTypeEncoding获取的类型是&quot;@\&quot;NSString\&quot;&quot;的形式</span></span><br><span class="line">        <span class="comment">//所以我们要做以下的替换</span></span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>ivarType <span class="operator">=</span> [<span class="type">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];<span class="comment">// 替换:</span></span><br><span class="line">        <span class="comment">//3.1去除转义字符：@\&quot;name\&quot; -&gt; @&quot;name&quot;</span></span><br><span class="line">        ivarType <span class="operator">=</span> [ivarType stringByReplacingOccurrencesOfString:@<span class="string">&quot;<span class="subst">\&quot;</span>&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">        <span class="comment">//3.2去除@符号</span></span><br><span class="line">        ivarType <span class="operator">=</span> [ivarType stringByReplacingOccurrencesOfString:@<span class="string">&quot;@&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.对特殊成员变量进行处理：</span></span><br><span class="line">        <span class="comment">//判断当前类是否实现了协议方法，获取协议方法中规定的特殊变量的处理方式</span></span><br><span class="line">        <span class="type">NSDictionary</span> <span class="operator">*</span>perpertyTypeDic;</span><br><span class="line">        <span class="keyword">if</span>([<span class="keyword">self</span> respondsToSelector:<span class="meta">@selector</span>(modelContainerPropertyGenericClass)])&#123;</span><br><span class="line">            perpertyTypeDic <span class="operator">=</span> [<span class="keyword">self</span> performSelector:<span class="meta">@selector</span>(modelContainerPropertyGenericClass) withObject:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.1处理：字典的key与模型属性不匹配的问题，如id-&gt;uid</span></span><br><span class="line">        id anotherName <span class="operator">=</span> perpertyTypeDic[propertyName];</span><br><span class="line">        <span class="keyword">if</span>(anotherName <span class="operator">&amp;&amp;</span> [anotherName isKindOfClass:[<span class="type">NSString</span> <span class="keyword">class</span>]])&#123;</span><br><span class="line">            value <span class="operator">=</span>  dictionary[anotherName];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.2.处理：模型嵌套模型</span></span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="type">NSDictionary</span> <span class="keyword">class</span>]] <span class="operator">&amp;&amp;</span> <span class="operator">!</span>[ivarType hasPrefix:@<span class="string">&quot;NS&quot;</span>]) &#123;</span><br><span class="line">            <span class="type">Class</span> modelClass <span class="operator">=</span> <span class="type">NSClassFromString</span>(ivarType);</span><br><span class="line">            <span class="keyword">if</span> (modelClass <span class="operator">!=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="comment">//将被嵌套字典数据也转化成Model</span></span><br><span class="line">                value <span class="operator">=</span> [modelClass zs_modelWithDictionary:value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.3处理：模型嵌套模型数组</span></span><br><span class="line">        <span class="comment">//判断当前Vaue是一个数组，而且存在协议方法返回了perpertyTypeDic</span></span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="type">NSArray</span> <span class="keyword">class</span>]] <span class="operator">&amp;&amp;</span> perpertyTypeDic) &#123;</span><br><span class="line">            <span class="type">Class</span> itemModelClass <span class="operator">=</span> perpertyTypeDic[propertyName];</span><br><span class="line">            <span class="comment">//封装数组：将每一个子数据转化为Model</span></span><br><span class="line">            <span class="type">NSMutableArray</span> <span class="operator">*</span>itemArray <span class="operator">=</span> @[].mutableCopy;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">NSDictionary</span> <span class="operator">*</span>itemDic  <span class="keyword">in</span> value) &#123;</span><br><span class="line">                id model <span class="operator">=</span> [itemModelClass zs_modelWithDictionary:itemDic];</span><br><span class="line">                [itemArray addObject:model];</span><br><span class="line">            &#125;</span><br><span class="line">            value <span class="operator">=</span> itemArray;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.使用KVC方法将Vlue更新到object中</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="operator">!=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">            [object setValue:value forKey:propertyName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivarList); <span class="comment">//释放C指针</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>



<h5 id="步骤2：分别创建各个数据模型Student、Address、Course"><a href="#步骤2：分别创建各个数据模型Student、Address、Course" class="headerlink" title="步骤2：分别创建各个数据模型Student、Address、Course"></a>步骤2：分别创建各个数据模型Student、Address、Course</h5><p><strong>Student类</strong>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h文件</span></span><br><span class="line">#<span class="keyword">import</span> &quot;NSObject+ZSModel.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &quot;AddressModel.h&quot;</span><br><span class="line">#<span class="keyword">import</span> &quot;CourseModel.h&quot;</span><br><span class="line"><span class="meta">@interface</span> <span class="type">StudentModel</span> : <span class="type">NSObject</span>&lt;<span class="type">ZSModel</span>&gt; <span class="comment">//遵循协议</span></span><br><span class="line"><span class="comment">//普通属性</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="keyword">copy</span>) <span class="type">NSString</span> <span class="operator">*</span>uid;</span><br><span class="line"><span class="meta">@property</span>(nonatomic,<span class="keyword">copy</span>)<span class="type">NSString</span> <span class="operator">*</span>name;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, assign) <span class="type">NSInteger</span> age;</span><br><span class="line"><span class="comment">//嵌套模型</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong) <span class="type">AddressModel</span> <span class="operator">*</span>address;</span><br><span class="line"><span class="comment">//嵌套模型数组</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong) <span class="type">NSArray</span> <span class="operator">*</span>courses;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m文件</span></span><br><span class="line">#<span class="keyword">import</span> &quot;StudentModel.h&quot;</span><br><span class="line"><span class="meta">@implementation</span> <span class="type">StudentModel</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">NSDictionary</span> <span class="operator">*</span>)modelContainerPropertyGenericClass &#123;</span><br><span class="line">    <span class="comment">//需要特别处理的属性</span></span><br><span class="line">    <span class="keyword">return</span> @&#123;@<span class="string">&quot;courses&quot;</span> : [<span class="type">CourseModel</span> <span class="keyword">class</span>],@<span class="string">&quot;uid&quot;</span>:@<span class="string">&quot;id&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>Address类</strong>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AddressModel.h文件</span></span><br><span class="line"><span class="meta">@interface</span> <span class="type">AddressModel</span> : <span class="type">NSObject</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="keyword">copy</span>) <span class="type">NSString</span> <span class="operator">*</span>country;  <span class="comment">//国籍</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="keyword">copy</span>) <span class="type">NSString</span> <span class="operator">*</span>province; <span class="comment">//省份</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="keyword">copy</span>) <span class="type">NSString</span> <span class="operator">*</span>city;     <span class="comment">//城市</span></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------优美的分割线------------------------</span></span><br><span class="line"><span class="comment">//AddressModel.m文件</span></span><br><span class="line">#<span class="keyword">import</span> &quot;AddressModel.h&quot;</span><br><span class="line"><span class="meta">@implementation</span> <span class="type">AddressModel</span></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>Course类</strong>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取JSON数据</span></span><br><span class="line"><span class="type">NSDictionary</span> <span class="operator">*</span>jsonData <span class="operator">=</span> [<span class="type">FileTools</span> getDictionaryFromJsonFile:@<span class="string">&quot;Student&quot;</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,jsonData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典转模型</span></span><br><span class="line"><span class="type">StudentModel</span> <span class="operator">*</span>student <span class="operator">=</span> [<span class="type">StudentModel</span> zs_modelWithDictionary:jsonData];</span><br><span class="line"><span class="type">CourseModel</span> <span class="operator">*</span>courseModel <span class="operator">=</span> student.courses[<span class="number">0</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,courseModel.name);</span><br></pre></td></tr></table></figure>



<h5 id="步骤3：测试字典转模型操作"><a href="#步骤3：测试字典转模型操作" class="headerlink" title="步骤3：测试字典转模型操作"></a>步骤3：测试字典转模型操作</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取JSON数据</span></span><br><span class="line"><span class="type">NSDictionary</span> <span class="operator">*</span>jsonData <span class="operator">=</span> [<span class="type">FileTools</span> getDictionaryFromJsonFile:@<span class="string">&quot;Student&quot;</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,jsonData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典转模型</span></span><br><span class="line"><span class="type">StudentModel</span> <span class="operator">*</span>student <span class="operator">=</span> [<span class="type">StudentModel</span> zs_modelWithDictionary:jsonData];</span><br><span class="line"><span class="type">CourseModel</span> <span class="operator">*</span>courseModel <span class="operator">=</span> student.courses[<span class="number">0</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,courseModel.name);</span><br></pre></td></tr></table></figure>

<p>效果如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/Runtime_use_dic_model_result.png" width="600" align=center></p>
<h4 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h4><p>以上就是我们在实际开发中常用的<code>Runtime</code>的操作了，<code>Runtime</code>的强大作用远不止如此。深入的了解和学习<code>Runtime</code>，不仅仅有助于<code>iOS</code>开发，而且对于理解编程语言的底层原理也十分有用，Keep Learning！~</p>
<p>参考链接：</p>
<ol>
<li><a href="https://halfrost.com/how_to_use_runtime/">如何正确使用 Runtime</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048">Objective-C Runtime Programming Guide</a></li>
<li><a href="%5Bhttp://nshipster.cn/method-swizzling/%5D(http://nshipster.cn/method-swizzling/)">Method Swizzling</a></li>
<li><a href="https://www.cnblogs.com/wuqh-iOS/p/4846811.html">iOS数据持久化存储:归档</a></li>
<li><a href="https://github.com/ibireme/YYModel">YYModel源码</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS底层</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS底层-内存管理基本概念</title>
    <url>/2019/04/16/iOS%E5%BA%95%E5%B1%82-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p><strong>主要内容：</strong></p>
<ol>
<li>内存区域划分</li>
<li>内存管理&#x2F;引用计数</li>
<li><code>MRC</code>手动管理引用计数<span id="more"></span></li>
<li><code>ARC</code>自动引用计数</li>
<li><code>MRC</code>与<code>ARC</code>的切换</li>
<li>内存泄漏问题</li>
<li>野指针问题</li>
</ol>
<h4 id="一、内存区域划分"><a href="#一、内存区域划分" class="headerlink" title="一、内存区域划分"></a>一、内存区域划分</h4><p>程序在分配内存的时，主要分为：栈区、堆区、静态区、常量区、代码区；</p>
<table>
<thead>
<tr>
<th>内存区域</th>
<th>具体说明</th>
</tr>
</thead>
<tbody><tr>
<td>栈区</td>
<td>存放局部变量的值，系统自动分配和释放;<br>特点：容量小，速度快，有序</td>
</tr>
<tr>
<td>堆区</td>
<td>存放通过<code>malloc</code>系列函数或<code>new</code>操作符分配的内存，如对象；<br>一般由程序员分配和释放，如果不释放，则出现内存泄露;<br>特点：容量大，速度慢，无序；</td>
</tr>
<tr>
<td>静态区</td>
<td>存放全局变量和静态变量(包括静态局部变量和静态全局变量)；<br>当程序结束时，系统回收；</td>
</tr>
<tr>
<td>常量区</td>
<td>存放常量的内存区域；<br>程序结束时，系统回收；</td>
</tr>
<tr>
<td>代码区</td>
<td>存放二进制代码的区域</td>
</tr>
</tbody></table>
<p>从上述分类上看，我们在开发过程中主要涉及的是堆上内存的管理。通常，我们创建一个对象的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>]; </span><br></pre></td></tr></table></figure>
<p>上述代码创建了一个<code>NSObject</code>类型的指针<code>obj</code>和一个<code>NSObject</code>类型的对象。<code>obj</code>指针存在栈上，而其指向的对象则是在堆上。这种对象也称之为<strong>堆对象</strong>。</p>
<h4 id="二、内存管理-引用计数"><a href="#二、内存管理-引用计数" class="headerlink" title="二、内存管理&#x2F;引用计数"></a>二、内存管理&#x2F;引用计数</h4><h5 id="1-OC使用引用计数机制管理内存"><a href="#1-OC使用引用计数机制管理内存" class="headerlink" title="1.OC使用引用计数机制管理内存"></a>1.OC使用引用计数机制管理内存</h5><ol>
<li>无论是<code>MRC</code>还是<code>ARC</code>环境，<code>OC</code>都采用引用计数来管理内存；每个对象都有一个引用计数器，任何时候指向对象的指针个数和对象的引用计数相等；</li>
<li>每次<code>RunLoop</code>完成一次迭代循环，都会检查对象的引用计数，如果引用计数为<code>0</code>，说明这个对象没有地方在使用，将会被释放；</li>
<li><code>OC</code>管理内存涉及到对象的<code>&quot;生成&quot;</code>、<code>&quot;持有&quot;</code>、<code>&quot;释放&quot;</code>，<code>MRC</code>需要调用对应的方法来管理引用计数，而<code>ARC</code>则是自动管理引用计数，无需再调用这些内存管理的方法。</li>
</ol>
<p>虽然<code>MRC</code>和<code>ARC</code>两者管理内存的形式不同，但是它们都遵循相同的内存管理规律，内容如下：</p>
<ol>
<li>自己生成的对象，自己所持有;</li>
<li>非自己生成的对象，自己也能持有;</li>
<li>不再需要自己持有对象时，释放；</li>
<li>非自己持有的对象，无法释放；</li>
</ol>
<h4 id="三、MRC手动管理引用计数"><a href="#三、MRC手动管理引用计数" class="headerlink" title="三、MRC手动管理引用计数"></a>三、MRC手动管理引用计数</h4><ol>
<li><code>MRC</code>，即手动管理引用计数。当我们通过<code>alloc</code>、<code>retain</code>等方法持有对象后，也必须有相应的<code>release</code>或者<code>autorelease</code>将其释放。</li>
<li>即：在<code>MRC</code>模式下必须遵守：<code>谁创建谁释放</code>，<code>谁引用谁管理</code>；</li>
</ol>
<p>总结对象操作与<code>Objective-C</code>内存方法对应关系如下：</p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th>OC方法</th>
</tr>
</thead>
<tbody><tr>
<td>生成并持有对象</td>
<td>以<code>alloc</code>&#x2F;<code>new</code>&#x2F;<code>copy</code>&#x2F;<code>mutableCopy</code>等名称开头方法</td>
</tr>
<tr>
<td>持有对象</td>
<td><code>retain</code>方法</td>
</tr>
<tr>
<td>释放对象</td>
<td><code>release</code>方法</td>
</tr>
<tr>
<td>废弃对象</td>
<td><code>dealloc</code>方法</td>
</tr>
</tbody></table>
<h5 id="1-自己生成的对象，自己所持有-非自己生成对象，不持有"><a href="#1-自己生成的对象，自己所持有-非自己生成对象，不持有" class="headerlink" title="1.自己生成的对象，自己所持有&#x2F;非自己生成对象，不持有"></a>1.自己生成的对象，自己所持有&#x2F;非自己生成对象，不持有</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];  <span class="comment">//自己生成并持有对象</span></span><br><span class="line">id obj1 <span class="operator">=</span> [<span class="type">NSMutableArray</span> array];  <span class="comment">//取得非自己生成的对象，但不持有对象</span></span><br></pre></td></tr></table></figure>
<p><code>OC</code>中使用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>这些名称开头的方法意味着自己生成对象并持有，否则就是非自己生成的对象不持有。如上源码，使用<code>NSObject</code>类的<code>alloc</code>类方法就能自己生成并持有对象，指向生成并持有对象的指针被赋值给了<code>obj</code>。</p>
<p>通过自定义方法来理解这两种创建对象方法的区别(系统方法也是类似的实现)，测试代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以alloc开头的方法</span></span><br><span class="line"><span class="operator">-</span> (id)allocObject &#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (id)object &#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [obj autorelease];  <span class="comment">//用该方法，可以使取得的对象存在，但是自己不持有对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>autorelease</code>即自动释放，对象已经加入自动释放池，所以获取对象并不持有；涉及到的自动释放池的内容会在后续详细总结。</p>
<p>**注意：**生成并持有对象的的方法一定是驼峰拼写来命名的方法，如<code>alloc</code>、<code>allocMyObject</code>等方法；相反<code>allocate</code>、<code>mutableCopyed</code>就不属于这类方法；</p>
<h5 id="2-非自己生成的对象，自己也能持有"><a href="#2-非自己生成的对象，自己也能持有" class="headerlink" title="2.非自己生成的对象，自己也能持有"></a>2.非自己生成的对象，自己也能持有</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">id obj1 <span class="operator">=</span> [<span class="type">NSMutableArray</span> array];  <span class="comment">//取得非自己生成的对象，但不持有对象</span></span><br><span class="line">[obj retain];                      <span class="comment">//通过retain方法，持有了对象</span></span><br></pre></td></tr></table></figure>
<p>源代码中，<code>NSMutableArray</code>类对象被赋值给变量<code>obj</code>，但是变量<code>obj</code>自己不持有该对象。使用<code>retain</code>方法后可以持有对象。</p>
<h5 id="3-不再需要自己持有对象时释放"><a href="#3-不再需要自己持有对象时释放" class="headerlink" title="3.不再需要自己持有对象时释放"></a>3.不再需要自己持有对象时释放</h5><p>自己持有的对象，一旦不需要，持有者有义务释放该对象，释放对象使用<code>release</code>方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>]; <span class="comment">//自己生成并持有对象</span></span><br><span class="line">[obj release];                    <span class="comment">//释放自己持有的对象</span></span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,obj);                 <span class="comment">//已经释放，再次使用会崩溃</span></span><br></pre></td></tr></table></figure>
<p>虽然指向对象的指针依然保留在变量<code>obj</code>中，看似可以访问，但对象一经释放就绝不可再访问。</p>
<h5 id="4-非自己持有的对象无法释放"><a href="#4-非自己持有的对象无法释放" class="headerlink" title="4.非自己持有的对象无法释放"></a>4.非自己持有的对象无法释放</h5><p>在应用程序中释放非自己持有的对象就会造成崩溃，使用代码演示如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况1：释放完不再需要的对象后再次释放，访问了已经废弃的对象而崩溃！</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[obj release];</span><br><span class="line">[obj release];</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况2：取得自己并不持有的对象对其释放，释放了非自己持有的对象而崩溃！</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSMutableArray</span> array];</span><br><span class="line">[obj release];</span><br></pre></td></tr></table></figure>


<h4 id="四、ARC自动引用计数"><a href="#四、ARC自动引用计数" class="headerlink" title="四、ARC自动引用计数"></a>四、ARC自动引用计数</h4><ol>
<li><code>ARC(Automic Reference Counting)</code>，即自动引用计数；</li>
<li>这是<code>iOS5</code>推出的新特性，<code>iOS4.3</code>也支持<code>ARC</code>，只是不能使用<code>weak</code>。</li>
<li><code>ARC</code>不再需要使用类似<code>retain</code>、<code>release</code>的操作来持有或者释放对象，从而大大提高了开发效率；</li>
</ol>
<h5 id="1-ARC使用条件"><a href="#1-ARC使用条件" class="headerlink" title="1.ARC使用条件"></a>1.ARC使用条件</h5><ol>
<li><code>Xcode4.2</code>或以上版本</li>
<li>使用<code>LLVM</code>编辑器<code>3.0</code>或以上版本</li>
<li><code>Xcode</code>编译器选项中设置<code>ARC</code>有效</li>
</ol>
<h5 id="2-ARC基本原理"><a href="#2-ARC基本原理" class="headerlink" title="2.ARC基本原理"></a>2.ARC基本原理</h5><ol>
<li><code>ARC</code>下的编译器会在代码编译阶段合适的位置，自动加入<code>retain/release/autorelease</code>的操作;</li>
<li><code>ARC</code>的规则：只要还有一个强引用指针指向对象，对象就会保存在内存中；</li>
<li><code>ARC</code>中使用<code>strong</code>和<code>weak</code>关键字来修饰对象；<code>strong</code>表示强引用，对应<code>MRC</code>下的<code>retain</code>；<code>weak</code>表示弱引用，对应原来的<code>assign</code>，不同的是当对象被释放的时候，对象<code>weak</code>指针自动赋值为<code>nil</code>，从而不会引发野指针错误；</li>
</ol>
<h5 id="3-ARC所有权修饰符"><a href="#3-ARC所有权修饰符" class="headerlink" title="3.ARC所有权修饰符"></a>3.ARC所有权修饰符</h5><p><code>ARC</code>有效时，<code>OC</code>处理<code>id</code>类型和对象类型必须附加所有权修饰符。所有权修饰符一共有四种：</p>
<ul>
<li><code>__strong</code></li>
<li><code>__weak</code></li>
<li><code>__unsafe_unretained</code></li>
<li><code>__autoreleasing</code></li>
</ul>
<p><strong>__strong修饰符:</strong><br><code>__strong</code>是<code>id</code>类型和对象类型默认的所有权修饰，表示对对象的”强引用”；当对象没有任何一个强引用指向它的时候，对象将被释放；</p>
<p><strong>__weak修饰符:</strong></p>
<ol>
<li><code>__weak</code>与<code>__strong</code>修饰符的作用相反，表示弱引用，不会增加引用计数；</li>
<li>当对象被释放后，所有指向它的弱引用都会被置为<code>nil</code>，这样避免了野指针问题。</li>
<li><code>__weak</code>修饰符常用于解决循环引用问题；</li>
<li><code>__weak</code>只能用于<code>iOS5</code>以上版本，更早的版本只能使用<code>__unsafe_unretained</code>修饰符。</li>
</ol>
<p><strong>__unsafe_unretained修饰符</strong></p>
<ol>
<li><code>__unsafe_unretained</code>提供弱引用，与<code>__weak</code>作用类似；</li>
<li><code>__unsafe_unretained</code>不能在对象释放后自动置为<code>nil</code>，易产生野指针问题；</li>
<li><code>__unsafe_unretained</code>可用于<code>iOS5</code>之前版本，为兼容<code>ARC</code>弱引用而引入；</li>
</ol>
<p><strong>__autoreleasing修饰符</strong><br>将对象赋值给附有<code>__autoreleasing</code>修饰符的变量，<br>等同于在<code>MRC</code>下调用对象的<code>autorelease</code>方法，即对象被注册到<code>autoreleasepool</code></p>
<p><code>ARC</code>环境不能使用<code>NSAutoreleasePool</code>类也不能调用<code>autorelease</code>方法，代替它们实现对象自动释放的是<code>@autoreleasepool块</code>和<code>__autoreleasing</code>修饰符；两种环境下的使用情况类比如下图：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/autoreleasepool_mrc_and_arc.png" width="500" hegiht="313" align=center/></p>
<p>如图所示，<code>@autoreleasepool</code>块替换了<code>NSAutoreleasePoool</code>类对象的生成、持有及废弃这一过程。而附有<code>__autoreleasing</code>修饰符的变量替代了<code>autorelease</code>方法，将对象注册到了<code>autoreleasepool</code>;</p>
<p>但事实上，显式使用<code>__autoreleasing</code>修饰符的情况非常少见，这主要是因为<code>ARC</code>的很多情况下，即使是不显式的使用<code>__autoreleasing</code>，也能实现对象被注册到释放池中。换句话来说，<code>ARC</code>环境下对象会被自动加入释放池的情况包括以下几种情况：</p>
<ol>
<li>编译器会进行优化，检查方法名是否以<code>alloc/new/copy/mutableCopy</code>开始，如果不是则自动将返回对象注册到<code>Autoreleasepool</code>;</li>
<li>访问附有<code>__weak</code>修饰符的变量时，实际上必定要访问注册到<code>Autoreleasepool</code>的对象，即会自动加入<code>Autoreleasepool</code>;</li>
<li>id的指针或对象的指针(<code>id*</code>，<code>NSError**</code>)，在没有显式地指定修饰符时候，会被默认附加上<code>__autoreleasing</code>修饰符，加入<code>Autoreleasepool</code>；</li>
</ol>
<h5 id="4-ARC属性修饰符"><a href="#4-ARC属性修饰符" class="headerlink" title="4.ARC属性修饰符"></a>4.ARC属性修饰符</h5><p><code>ARC</code>中的所有权修饰与属性修饰符存在着对应关系，如果不一致还会引起编译错误。总结两者的对应关系如下：</p>
<table>
<thead>
<tr>
<th>属性修饰符</th>
<th>所有权修饰符</th>
</tr>
</thead>
<tbody><tr>
<td><code>assign</code></td>
<td><code>__unsafe_unretained</code></td>
</tr>
<tr>
<td><code>copy</code></td>
<td><code>__strong</code>(但是赋值的是被复制的对象)</td>
</tr>
<tr>
<td><code>retain</code></td>
<td><code>__strong</code></td>
</tr>
<tr>
<td><code>strong</code></td>
<td><code>__strong</code></td>
</tr>
<tr>
<td><code>unsafe_unretained</code></td>
<td><code>__unsafe_unretained</code></td>
</tr>
<tr>
<td><code>weak</code></td>
<td><code>__weak</code></td>
</tr>
</tbody></table>
<p>以上各种属性只有<code>copy</code>不是简单的赋值，它赋值的是通过<code>NSCopying</code>接口的<code>copyWithZone:</code>方法复制赋值源生成的对象。</p>
<h5 id="5-ARC管理内存的规则"><a href="#5-ARC管理内存的规则" class="headerlink" title="5.ARC管理内存的规则"></a>5.ARC管理内存的规则</h5><ol>
<li>不能使用<code>retain/release/retainCount/autorelease</code>内存管理方法;</li>
<li>不能使用<code>NSAllocateObject/NSDeallocateObject</code>方法;</li>
<li>必须遵守内存管理的方法命名规则;</li>
<li>不能显式调用<code>dealloc</code>方法，如<code>[super dealloc]</code>;</li>
<li>使用<code>@autoreleasepool</code>块代替<code>NSAutoreleasePool</code>;</li>
<li>不能使用区域(<code>NSZone</code>);</li>
<li><strong>对象类型变量不能作为C语言结构体(struct&#x2F;union)的成员；</strong></li>
<li>显式转换<code>id</code>和<code>void *</code></li>
</ol>
<h5 id="6-必须遵守内存管理的方法命名规则"><a href="#6-必须遵守内存管理的方法命名规则" class="headerlink" title="6.必须遵守内存管理的方法命名规则"></a>6.必须遵守内存管理的方法命名规则</h5><p><code>MRC</code>下，用于对象生成&#x2F;持有的方法必须遵守<code>alloc、new、copy、mutableCopy</code>的命名规则。以这些名称开始的方法在返回对象时，必须返回给调用方所应当持有的对象。这在<code>ARC</code>环境下的规则一样。只是<code>ARC</code>下关于<code>init</code>开发的方法规则要更加严格了:</p>
<ol>
<li>必须是实例方法，且返回对象;</li>
<li>返回对象应该是<code>id</code>类型或该方法声明类的对象，抑或该类的超类或子类;</li>
<li>该返回类型不注册到<code>autoreleasepool</code>上;</li>
<li>基本上，<code>init</code>方法只是对<code>alloc</code>方法返回值的对象进行初始化处理并返回对象;</li>
</ol>
<h5 id="7-显式转换id和void"><a href="#7-显式转换id和void" class="headerlink" title="7.显式转换id和void *"></a>7.显式转换id和void *</h5><p>这里说到的其实就是<code>Core Foundation</code>和<code>Foundation</code>两者之间的转换。<br><code>Core Foundation</code>是由C语言实现的，而<code>Foundation</code>由<code>Objective-C</code>实现，两者可以相互转换。</p>
<p><code>MRC</code>不存在显式转换的问题，因为本来就是手动管理内存。但是为了在<code>ARC</code>也能实现对<code>Core Foundation</code>对象的自动内存管理，我们就必须将其与<code>Objective-C</code>对象的转换。<code>Objective-C</code>中提供了三个关键字<code>__bridge</code>、<code>__bridge_retained</code>、<code>__bridge_transfer</code>来实现转换。</p>
<p><strong>情况1：__bridge转换</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MRC代码下，将id变量直接强制转换void*正常，但ARC下报错</span></span><br><span class="line"><span class="comment">id obj = [[NSObject alloc] init];</span></span><br><span class="line"><span class="comment">void *p = obj;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//ARC下代码使用__bridge实现单纯的赋值转换</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">void <span class="operator">*</span>p <span class="operator">=</span> (__bridge void <span class="operator">*</span>)(obj);</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li><code>__bridge</code>只能实现<code>Objective-C</code>对象和<code>Core Foundation</code>对象的相互转换，但是不修改对象(内存)管理权；</li>
<li>所以，其安全性与赋值给<code>__unsafe_unretained</code>修饰符相近，甚至会更低。如果管理时不注意赋值对象的所有者，就容易产生野指针错误导致程序崩溃；</li>
</ol>
<p><strong>情况2：__bridge_retained转换</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">void <span class="operator">*</span>p <span class="operator">=</span> (__bridge_retained void <span class="operator">*</span>)(obj);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*相当于MRC代码：</span></span><br><span class="line"><span class="comment">id obj = [[NSObject alloc] init];</span></span><br><span class="line"><span class="comment">void *p = obj;</span></span><br><span class="line"><span class="comment">[(id)p retain];</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li><code>__bridge_retained</code>转换可使要转换的变量也持有所赋值的对象，后续需要使用<code>CFRelease</code>或者相关方法来释放对象；</li>
<li>此操作类似于<code>retain</code>。上述代码中变量<code>obj</code>和变量<code>p</code>同时持有对象。</li>
</ol>
<p><strong>情况3：__bridge_transfer转换</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">id obj <span class="operator">=</span> (__bridge_transfer id)p;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*相当于MRC代码：</span></span><br><span class="line"><span class="comment">id obj = id(p)</span></span><br><span class="line"><span class="comment">[obj retain];</span></span><br><span class="line"><span class="comment">[(id)p release];</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li><code>__bridge_transfer</code>转换提供与<code>__bridge_retained</code>相反的动作，被转换的变量所持有的对象在该变量被赋值给转换的目标后随之释放。</li>
<li>此操作与<code>release</code>相似。</li>
</ol>
<h4 id="五、MRC和ARC的转换"><a href="#五、MRC和ARC的转换" class="headerlink" title="五、MRC和ARC的转换"></a>五、MRC和ARC的转换</h4><p><code>iOS5.0</code>以后出现的<code>ARC</code>，即自动引用计数(<code>Automatic Refrence Counting</code>)，减少了代码，省去了对象释放的麻烦。</p>
<p><strong>ARC项目：加入MRC：</strong><br><code>target</code> -&gt;<code>build phrases</code> -&gt;<code>compbile sources</code> ，点击<code>mrc</code>的文件将其设置为 <code>-fno-objc-arc</code></p>
<p><strong>MRC项目：加入ARC：</strong><br><code>target</code> -&gt;<code>build phrases</code> -&gt;<code>compbile sources</code> ，点击<code>arc</code>的文件将其设置为 <code>-fobjc-arc</code></p>
<p><code>iOS</code>通过引用计数来记录对象的引用，每次<code>runloop</code>完成一次循环的时候，都会检查对象的<code>retainCount</code>，如果说对象的<code>retainCount</code>为<code>0</code>，说明该对象没有地方需要引用了，就可以释放掉了；</p>
<h4 id="六、内存泄漏问题"><a href="#六、内存泄漏问题" class="headerlink" title="六、内存泄漏问题"></a>六、内存泄漏问题</h4><ol>
<li>内存泄露就是本该废弃的对象在超出其生命周期后继续存在；</li>
<li>内存泄露可导致内存浪费、程序运行速度减慢甚至系统崩溃等严重后果；</li>
</ol>
<p>总结常见的内存泄露的异常情况如下：</p>
<ol>
<li><code>Block</code>、<code>delegate</code>、<code>NSTimer</code>使用不当，造成循环引用;</li>
<li>非<code>OC</code>对象不当使用，如<code>CoreFoundation</code>方式申请的内存，忘记释放，需要<code>free</code>、<code>release</code>方法；</li>
<li>第三方框架不当使用，如<code>AFNetworking</code>循环引用(未使用单例或者没有调用销毁<code>NSURLSession</code>的方法;</li>
<li>自定义长时间执行任务的线程，却没有添加自动释放池；</li>
<li>循环操作创建大量临时对象，导致内存导致内存暴涨；</li>
<li>地图框架使用完，要及时移除相关组件；</li>
</ol>
<p><code>ARC</code>只适用于<code>OC</code>对象，若我们使用了<code>Core Foundation</code>或者<code>malloc</code>，此时还是手动管理内存的，还有一些循环引用的情况同样造成内存泄露；</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#define <span class="type">WS</span>(weakSelf)   __weak __typeof(<span class="operator">&amp;*</span><span class="keyword">self</span>)weakSelf <span class="operator">=</span> <span class="keyword">self</span>; <span class="comment">// 弱引用</span></span><br><span class="line"></span><br><span class="line">#define <span class="type">ST</span>(strongSelf)  __strong __typeof(<span class="operator">&amp;*</span><span class="keyword">self</span>)strongSelf <span class="operator">=</span> weakSelf; <span class="comment">//使用这个要先声明weakSelf</span></span><br></pre></td></tr></table></figure>


<h4 id="七、野指针问题"><a href="#七、野指针问题" class="headerlink" title="七、野指针问题"></a>七、野指针问题</h4><p>野指针指针就是指向一个已经删除对象或者访问受限内存区域的指针；</p>
<p>**注意：**野指针不是<code>nil</code>指针，而是指向”垃圾”内存（不可用内存）的指针;</p>
<p>总结<code>ARC</code>下常见的野指针异常情况如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/memory_wild_pointer_questions.png" width="500" hegiht="313" align=center/></p>
]]></content>
      <categories>
        <category>iOS底层</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS底层-自动释放池原理</title>
    <url>/2019/04/18/iOS%E5%BA%95%E5%B1%82-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><strong>主要内容：</strong></p>
<ol>
<li><code>AutoreleasePool</code>简介</li>
<li><code>AutoreleasePool</code>底层原理</li>
<li><code>Autorelease</code>与<code>NSThread</code>、<code>NSRunLoop</code>的关系<span id="more"></span></li>
<li><code>AutoreleasePool</code>在主线程上的释放时机</li>
<li><code>AutoreleasePool</code>在子线程上的释放时机</li>
<li><code>AutoreleasePool</code>需要手动添加的情况</li>
</ol>
<h4 id="一、Autorelease简介"><a href="#一、Autorelease简介" class="headerlink" title="一、Autorelease简介"></a>一、Autorelease简介</h4><p><code>iOS</code>开发中的<code>Autorelease</code>机制是为了延时释放对象。自动释放的概念看上去很像<code>ARC</code>，但实际上这更类似于<code>C</code>语言中自动变量的特性；</p>
<ul>
<li>自动变量：在超出变量作用域后将被废弃；</li>
<li>自动释放池：在超出释放池生命周期后，向其管理的对象实例的发送<code>release</code>消息；</li>
</ul>
<h5 id="1-1-MRC下使用自动释放池"><a href="#1-1-MRC下使用自动释放池" class="headerlink" title="1.1 MRC下使用自动释放池"></a>1.1 MRC下使用自动释放池</h5><p>在<code>MRC</code>环境中使用自动释放池需要用到<code>NSAutoreleasePool</code>对象，其生命周期就相当于<code>C</code>语言变量的作用域。对于所有调用过<code>autorelease</code>方法的对象，在废弃<code>NSAutoreleasePool</code>对象时，都将调用<code>release</code>实例方法。用源代码表示如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="comment">//第一步：生成并持有释放池NSAutoreleasePool对象;</span></span><br><span class="line"><span class="type">NSAutoreleasePool</span> <span class="operator">*</span>pool <span class="operator">=</span> [[<span class="type">NSAutoreleasePool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：调用对象的autorelease实例方法;</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：废弃NSAutoreleasePool对象;</span></span><br><span class="line">[pool drain];   <span class="comment">//向pool管理的所有对象发送消息，相当于[obj release]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obi已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))</span></span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br></pre></td></tr></table></figure>

<p>理解<code>NSAutoreleasePool</code>对象的生命周期，如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/autoreleasepool_NSAutoreleasePool_lifecycle.png" width="500" hegiht="313" align=center/>

<p><code>MRC</code>向一个对象发送一条<code>autorelease</code>消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池中每一个对象发送一条<code>release</code>消息，以此来释放对象<br>向一个对象发送<code>release</code>消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为<code>0</code>时，系统才会调用<code>dealloc</code>方法释放该对象和对象本身所拥有的实例。</p>
<h5 id="1-2-ARC下使用自动释放池"><a href="#1-2-ARC下使用自动释放池" class="headerlink" title="1.2 ARC下使用自动释放池"></a>1.2 ARC下使用自动释放池</h5><p><code>ARC</code>环境不能使用<code>NSAutoreleasePool</code>类也不能调用<code>autorelease</code>方法，代替它们实现对象自动释放的是<code>@autoreleasepool</code>块和<code>__autoreleasing</code>修饰符。比较两种环境下的代码差异如下图：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/autoreleasepool_mrc_and_arc.png" width="500" hegiht="313" align=center/></p>
<p>如图所示，<code>@autoreleasepool</code>块替换了<code>NSAutoreleasePoool</code>类对象的生成、持有及废弃这一过程。而附有<code>__autoreleasing</code>修饰符的变量替代了<code>autorelease</code>方法，将对象注册到了<code>Autoreleasepool</code>；由于<code>ARC</code>的优化，<code>__autorelease</code>是可以被省略的，所以简化后的<code>ARC</code>代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ARC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显式使用<code>__autoreleasing</code>修饰符的情况非常少见，这是因为<code>ARC</code>的很多情况下，即使是不显式的使用<code>__autoreleasing</code>，也能实现对象被注册到释放池中。主要包括以下几种情况：</p>
<ol>
<li>编译器会进行优化，检查方法名是否以<code>alloc/new/copy/mutableCopy</code>开始，如果不是则自动将返回对象注册到<code>Autoreleasepool</code>;</li>
<li>访问附有<code>__weak</code>修饰符的变量时，实际上必定要访问注册到<code>Autoreleasepool</code>的对象，即会自动加入<code>Autoreleasepool</code>;</li>
<li><code>id</code>的指针或对象的指针(<code>id*</code>，<code>NSError**</code>)，在没有显式地指定修饰符时候，会被默认附加上<code>__autoreleasing</code>修饰符，加入<code>Autoreleasepool</code></li>
</ol>
<p>**注意：**如果编译器版本为<code>LLVM.3.0</code>以上，即使<code>ARC</code>无效<code>@autoreleasepool</code>块也能够使用；如下源码所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [obj autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-NSAutoreleasePool与-autoreleasepool的区别"><a href="#3-NSAutoreleasePool与-autoreleasepool的区别" class="headerlink" title="3.NSAutoreleasePool与@autoreleasepool的区别"></a>3.NSAutoreleasePool与@autoreleasepool的区别</h5><ol>
<li><code>MRC</code>中使用<code>NSAutoreleasePool</code>，<code>ARC</code>中使用<code>@autoreleasepool</code>;</li>
<li><code>NSAutoreleasePool</code>对象作用于进行时，<code>@autoreleasepool</code>作用于编译阶段；</li>
</ol>
<h4 id="二、AutoRelease原理"><a href="#二、AutoRelease原理" class="headerlink" title="二、AutoRelease原理"></a>二、AutoRelease原理</h4><h5 id="2-1-使用-autoreleasepool"><a href="#2-1-使用-autoreleasepool" class="headerlink" title="2.1 使用@autoreleasepool{}"></a>2.1 使用@autoreleasepool{}</h5><p>我们在<code>main</code>函数中写入自动释放池相关的测试代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了探究释放池的底层实现，我们在终端使用<code>clang -rewrite-objc + 文件名</code>命令将上述<code>OC</code>代码转化为<code>C++</code>源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span></span><br><span class="line">    &#123;</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d<span class="number">37e0</span>d_mi_0);</span><br><span class="line">     &#125;<span class="comment">//大括号对应释放池的作用域</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在经过编译器<code>clang</code>命令转化后，我们看到的所谓的<code>@autoreleasePool</code>块，其实对应着<code>__AtAutoreleasePool</code>的结构体。</p>
<h5 id="2-2-分析结构体-AtAutoreleasePool的具体实现"><a href="#2-2-分析结构体-AtAutoreleasePool的具体实现" class="headerlink" title="2.2 分析结构体__AtAutoreleasePool的具体实现"></a>2.2 分析结构体__AtAutoreleasePool的具体实现</h5><p>在源码中找到<code>__AtAutoreleasePool</code>结构体的实现代码，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="type">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="type">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__AtAutoreleasePool</span> &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = <span class="built_in">objc_autoreleasePoolPush</span>();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;<span class="built_in">objc_autoreleasePoolPop</span>(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="type">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>__AtAutoreleasePool</code>结构体包含了：构造函数、析构函数和一个边界对象；</p>
<ol>
<li>构造函数内部调用：<code>objc_autoreleasePoolPush()</code>方法，返回边界对象<code>atautoreleasepoolobj</code></li>
<li>析构函数内部调用：<code>objc_autoreleasePoolPop()</code>方法，传入边界对象<code>atautoreleasepoolobj</code></li>
</ol>
<p>分析<code>main</code>函数中<code>__autoreleasepool</code>结构体实例的生命周期是这样的：</p>
<ol>
<li><code>__autoreleasepool</code>是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，</li>
<li>而其析构函数则是在程序执行到离开这个对象的作用域时调用。</li>
</ol>
<p>所以，我们可以将上面<code>main</code>函数的代码简化如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">        void <span class="operator">*</span>atautoreleasepoolobj <span class="operator">=</span> objc_autoreleasePoolPush();</span><br><span class="line">        <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0);</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop"><a href="#2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop" class="headerlink" title="2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop"></a>2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop</h5><p>进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对<code>AutoreleasePoolPage</code>对应静态方法<code>push</code>和<code>pop</code>的封装</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::<span class="built_in">push</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="type">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage::<span class="built_in">pop</span>(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-理解AutoreleasePoolPage"><a href="#2-4-理解AutoreleasePoolPage" class="headerlink" title="2.4 理解AutoreleasePoolPage"></a>2.4 理解AutoreleasePoolPage</h5><p><code>AutoreleasePoolPage</code>是一个<code>C++</code>中的类，打开<code>Runtime</code>的源码工程，在<code>NSObject.mm</code>文件中可以找到它的定义，摘取其中的关键代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大致在641行代码开始</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoreleasePoolPage</span> &#123;</span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)  <span class="comment">//空池占位</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> POOL_BOUNDARY nil                <span class="comment">//边界对象(即哨兵对象）</span></span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_key_t</span> <span class="type">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> <span class="type">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> <span class="type">const</span> SIZE = </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> <span class="type">const</span> COUNT = SIZE / <span class="built_in">sizeof</span>(id);</span><br><span class="line">    <span class="type">magic_t</span> <span class="type">const</span> magic;                  <span class="comment">//校验AutoreleasePagePoolPage结构是否完整</span></span><br><span class="line">    id *next;                             <span class="comment">//指向新加入的autorelease对象的下一个位置，初始化时指向begin()</span></span><br><span class="line">    <span class="type">pthread_t</span> <span class="type">const</span> thread;               <span class="comment">//当前所在线程，AutoreleasePool是和线程一一对应的</span></span><br><span class="line">    AutoreleasePoolPage * <span class="type">const</span> parent;   <span class="comment">//指向父节点page，第一个结点的parent值为nil</span></span><br><span class="line">    AutoreleasePoolPage *child;           <span class="comment">//指向子节点page，最后一个结点的child值为nil</span></span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> depth;                 <span class="comment">//链表深度，节点个数</span></span><br><span class="line">    <span class="type">uint32_t</span> hiwat;                       <span class="comment">//数据容纳的一个上限</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实，<strong>每个自动释放池都是是由若干个<code>AutoreleasePoolPage</code>组成的双向链表结构</strong>，如下图所示:<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/autoreleasepool_autoreleasepoolpage_struct.png" width="1000" hegiht="313" align=center/></p>
<p><code>AutoreleasePoolPage</code>中拥有<code>parent</code>和<code>child</code>指针，分别指向上一个和下一个<code>page</code>；当前一个<code>page</code>的空间被占满(每个<code>AutorelePoolPage</code>的大小为4096字节)时，就会新建一个<code>AutorelePoolPage</code>对象并连接到链表中，后来的  Autorelease对象也会添加到新的<code>page</code>中；</p>
<p>另外，当<code>next== begin()</code>时，表示<code>AutoreleasePoolPage</code>为空；当<code>next == end()</code>，表示<code>AutoreleasePoolPage</code>已满。</p>
<h5 id="2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用"><a href="#2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用" class="headerlink" title="2.5 理解哨兵对象&#x2F;边界对象(POOL_BOUNDARY)的作用"></a>2.5 理解哨兵对象&#x2F;边界对象(POOL_BOUNDARY)的作用</h5><p>在<code>AutoreleasePoolPage</code>的源码中，我们很容易找到边界对象(哨兵对象)的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_BOUNDARY nil</span></span><br></pre></td></tr></table></figure>
<p>边界对象其实就是<code>nil</code>的别名，而它的作用事实上也就是为了起到一个标识的作用。</p>
<p>每当自动释放池初始化调用<code>objc_autoreleasePoolPush</code>方法时，总会通过<code>AutoreleasePoolPage</code>的<code>push</code>方法，将<code>POOL_BOUNDARY</code>放到当前<code>page</code>的栈顶，并且返回这个边界对象；</p>
<p>而在自动释放池释放调用<code>objc_autoreleasePoolPop</code>方法时，又会将边界对象以参数传入，这样自动释放池就会向释放池中对象发送<code>release</code>消息，直至找到第一个边界对象为止。</p>
<h5 id="2-6-理解objc-autoreleasePoolPush方法"><a href="#2-6-理解objc-autoreleasePoolPush方法" class="headerlink" title="2.6 理解objc_autoreleasePoolPush方法"></a>2.6 理解objc_autoreleasePoolPush方法</h5><p>经过前面的分析，<code>objc_autoreleasePoolPush</code>最终调用的是    <code>AutoreleasePoolPage</code>的<code>push</code>方法，该方法的具体实现如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> inline void <span class="operator">*</span>push() &#123;</span><br><span class="line">   <span class="keyword">return</span> autoreleaseFast(<span class="type">POOL_BOUNDARY</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> inline id <span class="operator">*</span>autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">AutoreleasePoolPage</span> <span class="operator">*</span>page <span class="operator">=</span> hotPage();</span><br><span class="line">   <span class="keyword">if</span> (page <span class="operator">&amp;&amp;</span> <span class="operator">!</span>page-&gt;full()) &#123;</span><br><span class="line">       <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">       <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1</span>.        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针</span></span><br><span class="line">id <span class="operator">*</span>add(id obj) &#123;</span><br><span class="line">    id <span class="operator">*</span>ret <span class="operator">=</span> next;</span><br><span class="line">    <span class="operator">*</span>next <span class="operator">=</span> obj;</span><br><span class="line">    next<span class="operator">++</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotPage已满时调用</span></span><br><span class="line"><span class="keyword">static</span> id <span class="operator">*</span>autoreleaseFullPage(id obj, <span class="type">AutoreleasePoolPage</span> <span class="operator">*</span>page) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page <span class="operator">=</span> page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page <span class="operator">=</span> new <span class="type">AutoreleasePoolPage</span>(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotpage不存在时调用</span></span><br><span class="line"><span class="keyword">static</span> id <span class="operator">*</span>autoreleaseNoPage(id obj) &#123;</span><br><span class="line">    <span class="type">AutoreleasePoolPage</span> <span class="operator">*</span>page <span class="operator">=</span> new <span class="type">AutoreleasePoolPage</span>(<span class="literal">nil</span>);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="operator">!=</span> <span class="type">POOL_SENTINEL</span>) &#123;</span><br><span class="line">        page-&gt;add(<span class="type">POOL_SENTINEL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，每次调用<code>push</code>其实就是创建一个新的AutoreleasePool，在对应的<code>AutoreleasePoolPage</code>中插入一个<code>POOL_BOUNDARY</code> ，并且返回插入的<code>POOL_BOUNDARY</code> 的内存地址。<code>push</code>方法内部调用的是<code>autoreleaseFast</code>方法，并传入边界对象(<code>POOL_BOUNDARY</code>)；</p>
<p><code>hotPage</code>可以理解为当前正在使用的<code>AutoreleasePoolPage</code>；</p>
<p>自动释放池最终都会通过<code>page-&gt;add(obj)</code>方法将边界对象添加到释放池中，而这一过程在<code>autoreleaseFast</code>方法中被分为三种情况：</p>
<ol>
<li>当前<code>page</code>存在且不满，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中，即<code>next</code>指向的位置</li>
<li>当前<code>page</code>存在但是已满，调用<code>autoreleaseFullPage</code>初始化一个新的<code>page</code>，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中</li>
<li>当前<code>page</code>不存在时，调用<code>autoreleaseNoPage</code>创建一个<code>hotPage</code>，再调用<code>page-&gt;add(obj)</code> 方法将对象添加至<code>page</code>的栈中</li>
</ol>
<h5 id="2-7-objc-autoreleasePoolPop方法"><a href="#2-7-objc-autoreleasePoolPop方法" class="headerlink" title="2.7 objc_autoreleasePoolPop方法"></a>2.7 objc_autoreleasePoolPop方法</h5><p><code>AutoreleasePool</code>的释放调用的是<code>objc_autoreleasePoolPop</code>方法，此时需要传入边界对象作为参数。这个边界对象正是每次执行<code>objc_autoreleasePoolPush</code>方法返回的对象<code>atautoreleasepoolobj</code>；</p>
<p>同理，我们找到<code>objc_autoreleasePoolPop</code>最终调用的方法，即<code>AutoreleasePoolPage</code>的<code>pop</code>方法，该方法的具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span> *token)</span>   <span class="comment">//POOL_BOUNDARY的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    page = <span class="built_in">pageForPointer</span>(token);   <span class="comment">//通过POOL_BOUNDARY找到对应的page</span></span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  *stop != POOL_SENTINEL) &#123;</span><br><span class="line">        <span class="comment">// This check is not valid with DebugPoolAllocation off</span></span><br><span class="line">        <span class="comment">// after an autorelease with a pool page but no pool in place.</span></span><br><span class="line">        _objc_fatal(<span class="string">&quot;invalid or prematurely-freed autorelease pool %p; &quot;</span>, </span><br><span class="line">                    token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) <span class="built_in">printHiwat</span>();   <span class="comment">// 记录最高水位标记</span></span><br><span class="line"></span><br><span class="line">    page-&gt;<span class="built_in">releaseUntil</span>(stop);   <span class="comment">//向栈中的对象发送release消息，直到遇到第一个哨兵对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children</span></span><br><span class="line">    <span class="comment">// 删除空掉的节点</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        <span class="built_in">setHotPage</span>(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;<span class="built_in">empty</span>()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        page-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        <span class="built_in">setHotPage</span>(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;<span class="built_in">lessThanHalfFull</span>()) &#123;</span><br><span class="line">            page-&gt;child-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，首先根据传入的边界对象地址找到边界对象所处的<code>page</code>；然后选择当前<code>page</code>中最新加入的对象一直向前清理，可以向前跨越若干个<code>page</code>，直到边界所在的位置；清理的方式是向这些对象发送一次<code>release</code>消息，使其引用计数减一；</p>
<p>另外，清空<code>page</code>对象还会遵循一些原则：</p>
<ol>
<li>如果当前的<code>page</code>中存放的对象少于一半，则子<code>page</code>全部删除；</li>
<li>如果当前当前的<code>page</code>存放的多余一半（意味着马上将要满），则保留一个子<code>page</code>，节省创建新<code>page</code>的开销;</li>
</ol>
<h5 id="2-8-autorelease方法"><a href="#2-8-autorelease方法" class="headerlink" title="2.8 autorelease方法"></a>2.8 autorelease方法</h5><p>上述是对自动释放池整个生命周期的分析，现在我们来理解延时释放对象<code>autorelease</code>方法的实现，首先查看该方法的调用栈：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- [NSObject autorelease]</span><br><span class="line">└── <span class="function">id <span class="title">objc_object::rootAutorelease</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    └── id <span class="title">objc_object::rootAutorelease2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        └── <span class="type">static</span> id <span class="title">AutoreleasePoolPage::autorelease</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">            └── <span class="type">static</span> id <span class="title">AutoreleasePoolPage::autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">                ├── id *<span class="title">add</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">                ├── <span class="type">static</span> id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span></span></span><br><span class="line"><span class="function">                │   ├── <span class="title">AutoreleasePoolPage</span><span class="params">(AutoreleasePoolPage *newParent)</span></span></span><br><span class="line"><span class="function">                │   └── id *<span class="title">add</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">                └── <span class="type">static</span> id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">                    ├── <span class="title">AutoreleasePoolPage</span><span class="params">(AutoreleasePoolPage *newParent)</span></span></span><br><span class="line"><span class="function">                    └── id *<span class="title">add</span><span class="params">(id obj)</span></span></span><br></pre></td></tr></table></figure>
<p>如上所示，<code>autorelease</code>方法最终也会调用上面提到的 <code>autoreleaseFast</code>方法，将当前对象加到<code>AutoreleasePoolPage</code>中。关于<code>autoreleaseFast</code>的分析这里不再累述，我们主要来考虑一下两次调用的区别：</p>
<p><code>autorelease</code>函数和<code>push</code>函数一样，关键代码都是调用<code>autoreleaseFast</code>函数向自动释放池的链表栈中添加一个对象，不过<code>push</code>函数入栈的是一个边界对象，而<code>autorelease</code>函数入栈的是一个具体的Autorelease的对象。</p>
<h4 id="三、AutoreleasePool与NSThread、NSRunLoop的关系"><a href="#三、AutoreleasePool与NSThread、NSRunLoop的关系" class="headerlink" title="三、AutoreleasePool与NSThread、NSRunLoop的关系"></a>三、AutoreleasePool与NSThread、NSRunLoop的关系</h4><p>由于<code>AppKit</code>和<code>UIKit</code>框架的优化，我们很少需要显式的创建一个自动释放池块。这其中就涉及到<code>AutoreleasePool</code>与<code>NSThread</code>、<code>NSRunLoop</code>的关系。</p>
<h5 id="3-1-RunLoop和NSThread的关系"><a href="#3-1-RunLoop和NSThread的关系" class="headerlink" title="3.1 RunLoop和NSThread的关系"></a>3.1 RunLoop和NSThread的关系</h5><p><code>RunLoop</code>是用于控制线程生命周期并接收事件进行处理的机制，其实质是一个<code>do-While</code>循环。在苹果文档找到关于<a href="https://developer.apple.com/documentation/foundation/nsrunloop#//apple_ref/doc/constant_group/Run_Loop_Modes">NSRunLoop</a>的介绍如下：</p>
<blockquote>
<p>Your application neither creates or explicitly manages NSRunLoop objects. Each NSThread object—including the application’s main thread—has an NSRunLoop object automatically created for it as needed. If you need to access the current thread’s run loop, you do so with the class method currentRunLoop.</p>
</blockquote>
<p>总结<code>RunLoop</code>与<code>NSThread</code>(线程)之间的关系如下：</p>
<ol>
<li><code>RunLoop</code>与线程是一一对应关系，每个线程(包括主线程)都有一个对应的<code>RunLoop</code>对象；其对应关系保存在一个全局的<code>Dictionary</code>里；</li>
<li>主线程的<code>RunLoop</code>默认由系统自动创建并启动；而其他线程在创建时并没有<code>RunLoop</code>，若该线程一直不主动获取，就一直不会有<code>RunLoop</code>；</li>
<li>苹果不提供直接创建<code>RunLoop</code>的方法；所谓其他线程<code>Runloop</code>的创建其实是发生在第一次获取的时候，系统判断当前线程没有<code>RunLoop</code>就会自动创建；</li>
<li>当前线程结束时，其对应的<code>Runloop</code>也被销毁；</li>
</ol>
<h5 id="3-2-RunLoop和AutoreleasePool的关系"><a href="#3-2-RunLoop和AutoreleasePool的关系" class="headerlink" title="3.2 RunLoop和AutoreleasePool的关系"></a>3.2 RunLoop和AutoreleasePool的关系</h5><p>在<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html#//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p>
<blockquote>
<p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p>
</blockquote>
<p>如上所述，主线程的<code>NSRunLoop</code>在监测到事件响应开启每一次<code>event loop</code>之前，会自动创建一个<code>autorelease pool</code>，并且会在<code>event loop</code>结束的时候执行<code>drain</code>操作，释放其中的对象。</p>
<h5 id="3-3-Thread和AutoreleasePool的关系"><a href="#3-3-Thread和AutoreleasePool的关系" class="headerlink" title="3.3 Thread和AutoreleasePool的关系"></a>3.3 Thread和AutoreleasePool的关系</h5><p>在<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html#//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p>
<blockquote>
<p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects (see Threads). As new pools are created, they get added to the top of the stack. When pools are deallocated, they are removed from the stack. Autoreleased objects are placed into the top autorelease pool for the current thread. When a thread terminates, it automatically drains all of the autorelease pools associated with itself.</p>
</blockquote>
<p>如上所述， 包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</p>
<h4 id="四、AutoreleasePool在主线程上的释放时机"><a href="#四、AutoreleasePool在主线程上的释放时机" class="headerlink" title="四、AutoreleasePool在主线程上的释放时机"></a>四、AutoreleasePool在主线程上的释放时机</h4><h5 id="4-1-理解主线程上的自动释放过程"><a href="#4-1-理解主线程上的自动释放过程" class="headerlink" title="4.1 理解主线程上的自动释放过程"></a>4.1 理解主线程上的自动释放过程</h5><p>分析主线程<code>RunLoop</code>管理自动释放池并释放对象的详细过程，我们在如下<code>Demo</code>中的主线程中设置断点，并执行<code>lldb</code>命令：<code>po [NSRunLoop currentRunLoop]</code>，具体效果如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/autoreleasepool_mian_thread_release_time.png" width="1000" hegiht="313" align=center/></p>
<p>我们看到主线程<code>RunLoop</code>中有两个与自动释放池相关的<code>Observer</code>，它们的 <code>activities</code>分别为<code>0x1</code>和<code>0xa0</code>这两个十六进制的数，转为二进制分别为<code>1</code>和<code>10100000</code>，对应<code>CFRunLoopActivity</code>的类型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>),          <span class="comment">//0x1，启动Runloop循环</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>),            </span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>),        </span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>),  <span class="comment">//0xa0，即将进入休眠     </span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>),   </span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>),           <span class="comment">//0xa0，退出RunLoop循环  </span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFFU</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>结合<code>RunLoop</code>监听的事件类型，分析主线程上自动释放池的使用过程如下：</p>
<ol>
<li><code>App</code>启动后，苹果在主线程<code>RunLoop</code>里注册了两个<code>Observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>;</li>
<li>第一个<code>Observer</code>监视的事件是<code>Entry</code>(即将进入<code>Loop</code>)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code>创建自动释放池。<code>order = -2147483647</code>(即<code>32</code>位整数最小值)表示其优先级最高，可以保证创建释放池发生在其他所有回调之前;</li>
<li>第二个<code>Observer</code>监视了两个事件：<ol>
<li><code>BeforeWaiting</code>(准备进入休眠)时，调用<code>_objc_autoreleasePoolPop()</code>和<code>_objc_autoreleasePoolPush()</code>释放旧的池并创建新池；</li>
<li><code>Exit</code>(即将退出<code>Loop</code>) 时，调用 <code>_objc_autoreleasePoolPop()</code>来释放自动释放池。<code>order =  2147483647</code>(即<code>32</code>位整数的最大值)表示其优先级最低，保证其释放池子发生在其他所有回调之后;</li>
</ol>
</li>
<li>在主线程执行的代码，通常是写在诸如事件回调、<code>Timer</code>回调内的。这些回调会被 <code>RunLoop</code>创建好的<code>AutoreleasePool</code>环绕着，所以不会出现内存泄漏，开发者也不必显示创建<code>AutoreleasePool</code>了;</li>
</ol>
<p>最后，也可以结合图示理解主线程上自动释放对象的具体流程：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/autoreleasepool_system_release_rules.png" width="500" hegiht="313" align=center/></p>
<ol>
<li>程序启动到加载完成后，主线程对应的<code>RunLoop</code>会停下来等待用户交互</li>
<li>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</li>
<li><code>RunLoop</code>检测到事件后，就会创建自动释放池;</li>
<li>所有的延迟释放对象都会被添加到这个池子中;</li>
<li>在一次完整的运行循环结束之前，会向池中所有对象发送<code>release</code>消息，然后自动释放池被销毁;</li>
</ol>
<h5 id="4-2-测试主线程上的对象自动释放过程"><a href="#4-2-测试主线程上的对象自动释放过程" class="headerlink" title="4.2 测试主线程上的对象自动释放过程"></a>4.2 测试主线程上的对象自动释放过程</h5><p>下面的代码创建了一个<code>Autorelease</code>对象<code>string</code>，并且通过<code>weakString</code>进行弱引用(不增加引用计数，所以不会影响对象的生命周期)，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">TestMemoryVC</span> ()</span><br><span class="line"><span class="meta">@property</span> (nonatomic,<span class="keyword">weak</span>)<span class="type">NSString</span> <span class="operator">*</span>weakString;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">TestMemoryVC</span></span><br><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>string <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;%@&quot;</span>,@<span class="string">&quot;WUYUBEICHEN&quot;</span>];</span><br><span class="line">    <span class="keyword">self</span>.weakString <span class="operator">=</span> string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewWillAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewDidAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewDidAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//viewWillAppear:WUYUBEICHEN</span></span><br><span class="line"><span class="comment">//viewDidAppear:(null)</span></span><br></pre></td></tr></table></figure>
<p><strong>代码分析：</strong></p>
<ol>
<li><code>viewDidLoad</code>和<code>viewWillAppear</code>是在同一个 <code>runloop</code> 调用的，因此在 <code>viewWillAppear</code>中，这个<code>autorelease</code>的变量依然有值；</li>
<li>自动变量<code>string</code>在离开<code>viewDidLoad</code>作用域后，会依靠当前主线程上的<code>RunLoop</code>迭代自动释放；</li>
<li>最终<code>string</code>对象在<code>viewDidAppear</code>方法执行前被释放(即<code>RunLoop</code>完成此次迭代)。</li>
</ol>
<h4 id="五、AutoreleasePool子线程上的释放时机"><a href="#五、AutoreleasePool子线程上的释放时机" class="headerlink" title="五、AutoreleasePool子线程上的释放时机"></a>五、AutoreleasePool子线程上的释放时机</h4><p>子线程默认不开启<code>RunLoo</code>，那么其中的延时对象该如何释放呢？其实这依然要从<code>Thread</code>和<code>AutoreleasePool</code>的关系来考虑：</p>
<blockquote>
<p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.  </p>
</blockquote>
<p>也就是说，每一个线程都会维护自己的 <code>Autoreleasepool</code>栈，所以子线程虽然默认没有开启<code>RunLoop</code>，但是依然存在<code>AutoreleasePool</code>，在子线程退出的时候会去释放<code>autorelease</code>对象。</p>
<p>前面讲到过，<code>ARC</code>会根据一些情况进行优化，添加<code>__autoreleasing</code>修饰符，其实这就相当于对需要延时释放的对象调用了<code>autorelease</code>方法。从源码分析的角度来看，如果子线程中没有创建<code>AutoreleasePool</code> ，而一旦产生了<code>Autorelease</code>对象，就会调用<code>autoreleaseNoPage</code>方法自动创建<code>hotpage</code>，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。</p>
<h4 id="六、AutoreleasePool需要手动添加的情况"><a href="#六、AutoreleasePool需要手动添加的情况" class="headerlink" title="六、AutoreleasePool需要手动添加的情况"></a>六、AutoreleasePool需要手动添加的情况</h4><p>尽管<code>ARC</code>已经做了诸多优化，但是有些情况我们必须手动创建<code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047">苹果文档</a>中说明了三种情况，我们可能会需要手动添加自动释放池：</p>
<ol>
<li>编写的不是基于UI框架的程序，例如命令行工具；</li>
<li>通过循环方式创建大量临时对象；</li>
<li>使用非<code>Cocoa</code>程序创建的子线程；</li>
</ol>
<p>而在<code>ARC</code>环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>代码分析：</p>
<ol>
<li>上述代码中，<code>obj</code>因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的<code>RunLoop</code>管理的；</li>
<li>因为<code>for</code>循环在当前线程没有执行完毕，<code>Runloop</code>也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。</li>
<li>释放池中的对象将会在<code>viewDidAppear</code>方法执行前就被销毁。</li>
<li>在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">             <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">             <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>




<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool?language=occ">苹果文档NSAutoreleasePool</a></li>
<li><a href="https://developer.apple.com/documentation/foundation/nsrunloop#//apple_ref/doc/constant_group/Run_Loop_Modes">苹果文档NSRunLoop</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI">苹果文档Using Autorelease Pool Blocks</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS底层</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发-CPU架构问题</title>
    <url>/2019/02/18/iOS%E5%BC%80%E5%8F%91-CPU%E6%9E%B6%E6%9E%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>首先，之所以提到CPU架构的问题，其实是因为我们iOS开发使用的静态库与动态库与之紧密相连。每一个开发的App都要运行在模拟器或者真机上，在编译的时候，Xcode需要去分析当前运行平台的CPU架构，然后确定所使用的静态库是否支持这个CPU架构。如果不支持就会报错。</p>
<span id="more"></span>

<h1 id="一、什么是CPU架构"><a href="#一、什么是CPU架构" class="headerlink" title="一、什么是CPU架构"></a>一、什么是CPU架构</h1><p>“CPU架构是CPU厂商给属于同一系列的CPU产品定的一个规范，主要目的是为了区分不同类型CPU的重要标示。目前市面上的CPU分类主要分有两大阵营，一个是intel、AMD为首的复杂指令集CPU，另一个是以IBM、ARM为首的精简指令集CPU。两个不同品牌的CPU，其产品的架构也不相同，例如，Intel、AMD的CPU是X86架构的，而IBM公司的CPU是PowerPC架构，ARM公司是ARM架构”（摘自百度）<br>通常，我们知道电脑的CPU架构有X86和X64等，但是手机的主流CPU架构是ARM架构，因为采用ARM架构的CPU是一种微处理器，这种处理器功耗低，体积小，更适合手机使用，iPhone的CPU也是如此。</p>
<h1 id="二、iPhone移动设备默认指令集"><a href="#二、iPhone移动设备默认指令集" class="headerlink" title="二、iPhone移动设备默认指令集"></a>二、iPhone移动设备默认指令集</h1><p>那么，总结iPhone设备默认指令集的使用情况如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-664cd726a222f057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-11-08 下午1.57.51.png"></p>
<h1 id="三、有关指令集使用特点"><a href="#三、有关指令集使用特点" class="headerlink" title="三、有关指令集使用特点"></a>三、有关指令集使用特点</h1><ol>
<li>上述arm处理器指令集，在原则上它们都是向下兼容的。比如iPhone6s的CPU默认指令集是arm64,但是也同时支持armv7s等以前版本的指令集，只是效率变低了而已。</li>
<li>xcode模拟器其实是在电脑上的，所以iOS模拟器并没有使用arm指令集。它编译运行使用的是x86指令集(或者i386)。而在真机上使用的才是arm类型的指令集。</li>
<li>在Xcode中设置二进制包所支持的指令集，对于编译后的二进制包的大小影响显著，设置支持的指令集个数越少，安装包也越小。</li>
</ol>
<h1 id="四、Xcode中关于指令集的配置与使用"><a href="#四、Xcode中关于指令集的配置与使用" class="headerlink" title="四、Xcode中关于指令集的配置与使用"></a>四、Xcode中关于指令集的配置与使用</h1><p>具体在Xcode中的使用，我们在Xcode中选择将要设置的target，然后打开build setting, 可以看到有关指令集设置的Architectures选项。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-3dbf57149752a2ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-11-08 下午1.59.51.png"><br>在这里的关键设置有三个，可以通过这里设置Xcode生成二进制包的指令集</p>
<h2 id="1-Architectures"><a href="#1-Architectures" class="headerlink" title="1.Architectures:"></a>1.Architectures:</h2><p>作用：设置工程被编译后将支持哪些指令集，支持指令集是通过编译生成对应的二进制数据包实现的。<br>特点：设置支持的指令集数据越多，编译出的二进制包包含的指令集代码越多，这样就会使最后编译的包很大。</p>
<h2 id="2-valid-Architectures："><a href="#2-valid-Architectures：" class="headerlink" title="2.valid Architectures："></a>2.valid Architectures：</h2><p>作用：设置可能支持的指令集，这里的指令集选项和Architectures列表中指令集选项的交集，将决定最后Xcode生成二进制包所支持的指令集。<br>举例：Architectures支持armv7, Valid Architecture支持armv7、armv7s、armv64，那么Xcode只会生成一个armv7指令集的二进制包。</p>
<h2 id="3-build-Active-Architecture-only"><a href="#3-build-Active-Architecture-only" class="headerlink" title="3.build Active Architecture only"></a>3.build Active Architecture only</h2><p>作用：设置是否只编译当前使用设备所对应的arm指令集。也就是说当该项设置为YES的时候，上述规则(Architectures和valid Architectures交集决定二进制包所支持指令集)将被打破。<br>举列：设置该选项是YES,并且连接一个armv7指令集设备，无论前面两项如何设置，Xcode最终生成armv7指令集的二进制包。不过设置为YES生效有个前提条件就是，Xcode必须成功连接了调试的设备。</p>
<p>一般的情况下，build Active Architecture only选项默认在Debug模式下是YES, Release模式下是NO，但是我们在开发的时候，有时候也会遇到一些第三方文件找不到路径的问题，这时要求我们设置Debug模式下也为NO。</p>
<h1 id="五、遇到的问题"><a href="#五、遇到的问题" class="headerlink" title="五、遇到的问题"></a>五、遇到的问题</h1><p>在这里记录一个在开发中遇到的问题。曾经在使用CocoaPods管理第三方的时候，遇到了“library not found for -lXXX”的错误，当时使用了Masonry的库。Xcode报错如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-7aa56c2371dbf81d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-11-08 下午2.25.33.png"><br>其实这是因为CocoaPods在引入第三方类库的时候，默认build Active Architecture only在Debug模式下是YES导致的，修改为NO就可以了。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>CPU架构</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发-ReactiveCocoa基础篇</title>
    <url>/2019/03/03/iOS%E5%BC%80%E5%8F%91-ReactiveCocoa%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p><code>ReactiveCocoa</code>(简称<code>RAC</code>)，<code>Reactive</code>表示响应式，<code>Cocoa</code>是苹果整个框架的简称，许多苹果框架都以<code>Cocoa</code>结尾。所以<code>RAC</code>是<code>Github</code>上为我们提供函数响应式编程方法的<code>iOS</code>开发框架。</p>
<span id="more"></span>

<p><strong>主要内容：</strong></p>
<ol>
<li>了解函数响应式编程</li>
<li>ReactiveCocoa简介</li>
<li>ReactiveCocoa集成</li>
<li>理解什么是信号</li>
<li>从源码理解RAC的信号机制</li>
<li>本篇总结</li>
</ol>
<h1 id="一、了解函数响应式编程"><a href="#一、了解函数响应式编程" class="headerlink" title="一、了解函数响应式编程"></a>一、了解函数响应式编程</h1><p><img src="https://upload-images.jianshu.io/upload_images/1244124-613e9c9d4106f91b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>函数式编程(Funcational Programming)</strong><br>使用高阶函数编程，即函数可采用多种函数作为它们的参数和返回值。</p>
<p><strong>响应式编程(Reactive Programming)</strong><br>一种面向数据流和变化传播的编程范式</p>
<p><strong>函数响应式编程(Funcational Reacitve Programming)</strong><br>简称FRP，ReactiveCocoa就是一个典型的FRP框架，响应式的编程思想，函数式的代码形式。</p>
<h1 id="二、ReactiveCocoa简介"><a href="#二、ReactiveCocoa简介" class="headerlink" title="二、ReactiveCocoa简介"></a>二、ReactiveCocoa简介</h1><p>iOS开发中，我们需要使用按钮点击、代理、通知等这些方法来处理响应事件。而RAC框架使用Category为很多基本的UIKit控件添加信号Signal，这样我们可以通过信号来监听数据流与变化传播，把将监听的代码与处理代码放在一起，从而方便我们管理。利用此特点结合MVVM架构，RAC也有十分显著的作用。</p>
<h1 id="三、ReactiveCocoa集成"><a href="#三、ReactiveCocoa集成" class="headerlink" title="三、ReactiveCocoa集成"></a>三、ReactiveCocoa集成</h1><p>RAC.5.0相对于之前版本对于自身项目结构进行了较大调整，被拆分ReactiveCocoa、ReactiveSwift、ReactiveObjC、ReactiveObjCBridge四个库，我们需要根据不同的情况来集成。<br><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">GitHub地址：https://github.com/ReactiveCocoa/ReactiveCocoa</a><br>通常，我们都使用Cocoapods集成RAC，<strong>需要注意的是Podfile文件中必须使用user_framework!</strong>，然后，针对于不同的代码环境，有三种集成情况：</p>
<h2 id="1-纯OC工程"><a href="#1-纯OC工程" class="headerlink" title="1.纯OC工程"></a>1.纯OC工程</h2><p>ReactiveObjc库包含原RAC2的全部代码，在纯OC工程中使用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">platform :ios, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line">use_frameworks!     #必须添加</span><br><span class="line">target <span class="string">&#x27;ZSTest&#x27;</span> <span class="keyword">do</span>  #工程名</span><br><span class="line"><span class="meta">#pod &#x27;ReactiveObjC&#x27; #默认导入最新的RAC版本         </span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="2-纯Swift工程"><a href="#2-纯Swift工程" class="headerlink" title="2.纯Swift工程"></a>2.纯Swift工程</h2><p>纯Swfit工程继续使用ReactiveCocoa，但RAC依赖ReactiveSwift，所以相当于引入两个库。<br>集成方法同上，只不过将ReactiveObjc换成ReactiveCocoa。</p>
<h2 id="3-OC与Swift混编工程"><a href="#3-OC与Swift混编工程" class="headerlink" title="3.OC与Swift混编工程"></a>3.OC与Swift混编工程</h2><p>混编工程需要同时引入ReactiveCocoa与ReactiveObjCBridge，但是ReactiveObjCBridge库依赖于ReactiveObjc库，所以相当于同时引入四个库了。示例如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">platform :ios, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line">use_frameworks!     #必须添加</span><br><span class="line">target <span class="string">&#x27;ZSTest&#x27;</span> <span class="keyword">do</span>  #工程名</span><br><span class="line">pod <span class="string">&#x27;ReactiveCocoa&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;ReactiveObjC&#x27;</span>  </span><br><span class="line">pod <span class="string">&#x27;ReactiveObjCBridge&#x27;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h1 id="四、ReactiveCocoa信号理解"><a href="#四、ReactiveCocoa信号理解" class="headerlink" title="四、ReactiveCocoa信号理解"></a>四、ReactiveCocoa信号理解</h1><p>我觉得学习RAC的第一个关口就是理解信号RACSignal了，什么是信号也许是困惑我们的第一个问题。</p>
<p>作为RAC中最为核心的一个类，<strong>信号可以理解为传递数据变化信息的工具</strong>，信号会在数据发生变化时发送事件流给它的订阅者，然后订阅者执行响应方法。信号本身不具备发送信号的能力，而是交给一个订阅者去发出。</p>
<p>首先上一段代码，演示信号的一个基本使用。<br>测试场景：我们要对一个用于输入用户名的UITextFiled进行检测，每次输入内容变化的时候都打出输入框的内容，使用RAC来实现此操作的关键代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.userNameTxtField.rac_textSignal subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;测试：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.497956</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 测试：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498237</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 测试：<span class="number">12</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498375</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 测试：<span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>没错的，不使用代理方法，也没有action的响应处理，我们仅仅使用了一行方法就实现了对文本框输入内容的实时打印。由此，RAC的实用性可见一斑。</p>
<h1 id="五、ReactiveCocoa信号机制"><a href="#五、ReactiveCocoa信号机制" class="headerlink" title="五、ReactiveCocoa信号机制"></a>五、ReactiveCocoa信号机制</h1><p>我们会对上面的代码产生疑问，RAC是怎么做到上述代码功能的呢？而且我们常说的订阅者又在哪里呢？</p>
<p>其实RAC已经使用Category的形式为我们基本的UI控件创建了信号(<strong>如上例中的rac_textSignal</strong>)，所以这里我们才可以很方便的实现信号订阅，而且订阅者在整个过程中也是对于我们隐藏的。 现在我们使用自定义信号的方法，从创建信号到订阅信号细致的了解一下这个过程。首先上一段创建信号的测试代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建信号</span></span><br><span class="line">RACSignal *testSignal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="comment">//1.订阅者发送信号内容</span></span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号内容&quot;</span>];</span><br><span class="line">    <span class="comment">//2.订阅者发送信号完成的信息，不需要再发送数据时，最好发送信号完成，可以内部调起清理信号的操作。</span></span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="comment">//3.创建信号的Block参数，需要返回一个RACDisposable对象 ，可以返回nil。</span></span><br><span class="line">    <span class="comment">//RACDisposable对象用于取消订阅信号，此block在信号完成或者错误时调用。</span></span><br><span class="line">    RACDisposable *racDisposable = [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;信号Error或者Complete时销毁&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> racDisposable;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//订阅信号</span></span><br><span class="line">[testSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//新变化的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：subscribeNext:%@&quot;</span>,x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//信号错误，被取消订阅,被移除观察</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：Error:%@&quot;</span>,error.description);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="comment">//信号已经完成，被取消订阅，被移除观察</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：subscribeComplete&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印:</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.497956</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 订阅信号：subscribeNext:发送信号内容</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498237</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 订阅信号：subscribeComplete</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498375</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 信号Error或者Complete时销毁</span><br></pre></td></tr></table></figure>

<p>我们通过观察源码来理解整个过程:</p>
<h2 id="1-创建信号"><a href="#1-创建信号" class="headerlink" title="1.创建信号"></a>1.创建信号</h2><p>创建信号，我们需要使用RACSignal的类方法createSignal。该方法需要一个Block作为参数。查看源码，我们就会发现RACSignal最终是通过调用自己子类RACDynamicSignal的createSignal方法，将这个Block设置给了自己的didSubscribe属性的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RACSignal.m文件</span></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"> 	<span class="keyword">return</span> [RACDynamicSignal createSignal:didSubscribe];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RACDynamicSignal.h文件</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACDynamicSignal</span> ()</span></span><br><span class="line"><span class="comment">// The block to invoke for each subscriber.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACDisposable * (^didSubscribe)(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RACDynamicSignal.m文件</span></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"> 	RACDynamicSignal *signal = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"> 	signal-&gt;_didSubscribe = [didSubscribe <span class="keyword">copy</span>];</span><br><span class="line"> 	<span class="keyword">return</span> [signal setNameWithFormat:<span class="string">@&quot;+createSignal:&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>didSubscribe</strong>：这是创建信号时候需要传入的一个block，它的传入参数是订阅者subscriber，而返回值是需要是一个RACDisposable对象。创建信号后的didSubscrib是一个等待执行的block。</p>
<p><strong>RACSubscriber</strong>：表示订阅者，创建信号时订阅者发送信号，这里的订阅者是一个协议而非一个类。信号需要订阅者帮助其发送数据。查看RACSubscriber的协议，我可以看到以下几个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送信息</span></span><br><span class="line">- (<span class="type">void</span>)sendNext:(<span class="keyword">nullable</span> <span class="type">id</span>)value;</span><br><span class="line"><span class="comment">//发送错误消息</span></span><br><span class="line">- (<span class="type">void</span>)sendError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error;</span><br><span class="line"><span class="comment">//发送完成信息</span></span><br><span class="line">- (<span class="type">void</span>)sendCompleted;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="type">void</span>)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</span><br></pre></td></tr></table></figure>

<p>在创建一个信号的时候，订阅者使用sendNext发送信息。而且如果我们不再发送数据，最好在这里执行一次sendCompleted方法，这样的话，信号内部会自动调用对应的方法取消信号订阅。</p>
<p><strong>RACDisposable</strong>：这个类用于取消订阅信号和清理资源，在信号出现错误或者信号完成的时候，信号会自动调起RACDisposable对象的block方法。在代码中我们也可以看到，创建RACDisposable对象是使用disposableWithBlock方法设置了一个block操作，执行block操作之后，信号就不再被订阅了。</p>
<p><strong>总结：创建信号就是使用createSignal方法，创建一个信号，并为信号设置了一个didSubscribe属性(也就是一系列订阅者需要做的操作)。</strong></p>
<h2 id="2-订阅信号"><a href="#2-订阅信号" class="headerlink" title="2.订阅信号"></a>2.订阅信号</h2><p>进入订阅信号的源码我们看到如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(<span class="type">void</span> (^)(<span class="type">id</span> x))nextBlock error:(<span class="type">void</span> (^)(<span class="built_in">NSError</span> *error))errorBlock completed:(<span class="type">void</span> (^)(<span class="type">void</span>))completedBlock &#123;</span><br><span class="line"> 	<span class="built_in">NSCParameterAssert</span>(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line"> 	<span class="built_in">NSCParameterAssert</span>(errorBlock != <span class="literal">NULL</span>);</span><br><span class="line"> 	<span class="built_in">NSCParameterAssert</span>(completedBlock != <span class="literal">NULL</span>);</span><br><span class="line"> 	</span><br><span class="line"> 	RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:errorBlock completed:completedBlock];</span><br><span class="line"> 	<span class="keyword">return</span> [<span class="keyword">self</span> subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此方法中，我们可以看到订阅信号有两个过程：<br><strong>过程1：使用subscribeNext的方法参数，创建出一个订阅者subscriber。</strong><br><strong>过程2：信号对象执行了订阅操作subscribe，方法中传入参数是刚创建的订阅者。</strong></p>
<p><strong>注：这也就解释了我们常提起却看不见的订阅者存在哪里的问题。真实开发中我们只关心订阅者需要发送的值就行了，而不需要关心其内部订阅的过程。</strong></p>
<p>继续打开信号的subscribe方法，看到源码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="type">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"> 	<span class="built_in">NSCParameterAssert</span>(subscriber != <span class="literal">nil</span>);</span><br><span class="line"> 	RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"> 	subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="keyword">self</span> disposable:disposable];</span><br><span class="line"> 	<span class="keyword">if</span> (<span class="keyword">self</span>.didSubscribe != <span class="literal">NULL</span>) &#123;</span><br><span class="line"> 		RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line"> 			RACDisposable *innerDisposable = <span class="keyword">self</span>.didSubscribe(subscriber);</span><br><span class="line"> 			[disposable addDisposable:innerDisposable];</span><br><span class="line"> 		&#125;];</span><br><span class="line"> 		[disposable addDisposable:schedulingDisposable];</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们不难看出：<strong>除了对于订阅者和清理对象的再次封装外，最重要的就是创建信号时为信号设置Block(didSubscribe)被调用了，而且Block参数使用了我们创建的订阅者。</strong></p>
<h1 id="六、本篇总结"><a href="#六、本篇总结" class="headerlink" title="六、本篇总结"></a>六、本篇总结</h1><p>1.自创建信号会传入一个Block(didSubscribe)，Block中遵循协议的订阅者会调用sendNext方法发送消息。而在订阅信号subscribeNext时，会在内部创建一个订阅者，并将其传递给原先赋值的didSubscribe，并执行这个Block。</p>
<p>2.<strong>但是我们应该注意</strong>：上述的分析只是其中信号机制的一种情况罢了。RAC对于UI组件信号的封装可能有所不同，比如之前我们看到的输入框信号，执行订阅信号subscribeNext时并不立即执行打印，而是监听到输入时打印。这其实是该信号使用了concat又做了一系列的操作。<strong>对于不同的信号我们只需要理解上述分析中提到几个关键属性，就可以结合源码很好的理解信号机制的使用了。</strong></p>
<p>本篇的重点在于对RAC的基本介绍，是为了更好的理解信号机制，这仅相当于打开一个切入口来认识RAC。关于RAC的详细用法可以参考下一篇：<a href="https://www.jianshu.com/p/16b4b9d74b7c">ReactiveCocoa函数响应式编程-应用篇</a>，这里将总结RAC关于信号的各种用法。</p>
<p>其他参考链接：<br>1.<a href="http://www.cocoachina.com/ios/20150123/10994.html">ReactiveCocoa入门教程：第一部分</a><br>2.<a href="https://www.jianshu.com/p/87ef6720a096">最快让你上手ReactiveCocoa之基础篇</a><br>3.<a href="http://ios.jobbole.com/82356/">这样好用的ReactiveCocoa,根本停不下来</a><br>4.<a href="https://www.cnblogs.com/zhenw/p/6160931.html">函数式编程与面向对象的比较</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发-DTCoreText的集成与使用</title>
    <url>/2019/02/26/iOS%E5%BC%80%E5%8F%91-DTCoreText%E7%9A%84%E9%9B%86%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>主要内容：</p>
<ol>
<li><code>DTCoreText</code>简介</li>
<li><code>DTCoreText</code>的集成</li>
<li><code>DTCoreText</code>的使用<span id="more"></span></li>
<li><code>DTAttributedLabel</code></li>
<li><code>DTAttributedTextView</code></li>
<li><code>DTAttributedTextCell</code></li>
<li>可能遇到的错误</li>
</ol>
<h4 id="一、DTCoreText简介"><a href="#一、DTCoreText简介" class="headerlink" title="一、DTCoreText简介"></a>一、DTCoreText简介</h4><p><code>DTCoreText</code>是可以将<code>HTML</code>字符串转化为富文本使用的工具，既保证原生实现又能适应灵活的样式修改，而且相比于使用<code>WebView</code>显示内容在性能上也有很大优势，本篇就这一技术的使用进行总结。</p>
<p><code>DTCoreText</code>相关资源如下：</p>
<ol>
<li><a href="https://github.com/Cocoanetics/DTCoreText">DTCoreText源码下载</a></li>
<li><a href="https://docs.cocoanetics.com/DTCoreText/">DTCoreText官方文档</a></li>
<li><a href="https://docs.cocoanetics.com/DTCoreText/docs/Setup%20Guide.html">DTCoreText集成文档</a></li>
<li><a href="https://github.com/DreamcoffeeZS/DTCoreTextDemo.git">本文DTCoreText测试工程</a></li>
</ol>
<p>温馨提示：文中代码量比较大，看起来可能比较费劲，所以先将本文的<a href="https://github.com/DreamcoffeeZS/DTCoreTextDemo.git">Demo链接</a>放在这里，结合代码看更方便，毕竟代码才是硬道理嘛！</p>
<h4 id="二、DTCoreText的集成"><a href="#二、DTCoreText的集成" class="headerlink" title="二、DTCoreText的集成"></a>二、DTCoreText的集成</h4><p>在项目中使用<code>DTCoreText</code>需要它的两个静态库：<code>DTCoreText.framework</code>和<code>DTFoundation.framework</code>，但是从<code>Github</code>下载的文件却不能直接使用。</p>
<p>起初，我是直接从网上其他地方下载打包好的静态库来使用的，但这样会遗漏掉更新。所以，这里总结了集成<code>DTCoreText</code>的具体步骤。</p>
<h5 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1.下载源码"></a>1.下载源码</h5><p>创建一个文件夹<code>DTCoreText</code>，使用终端命令下载源码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --recursive [https://github.com/Cocoanetics/DTCoreText.git](https://github.com/Cocoanetics/DTCoreText.git) Externals/DTCoreText</span><br></pre></td></tr></table></figure>
<h5 id="2-设置编译配置"><a href="#2-设置编译配置" class="headerlink" title="2.设置编译配置"></a>2.设置编译配置</h5><p>修改<code>DTCoreText</code>工程的编译配置，然后运行工程就得到适合不同平台的静态库；</p>
<p>为了获取到适合<code>iOS</code>设备使用的<code>SDK</code>，选择工程<code>Target</code>为<code>DTCoreText(iOS)</code>，并依次选择<code>DTCoreText(iOS)</code> -&gt; <code>Deployment Info</code> -&gt; 选择需要最低支持的系统版本；<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/dtcoretext_targets_deployment_Info.png" width="600" align=center/></p>
<h5 id="3-设置Scheme"><a href="#3-设置Scheme" class="headerlink" title="3.设置Scheme"></a>3.设置Scheme</h5><p>选择<code>Product</code> -&gt; <code>Scheme</code> -&gt; <code>Edit Scheme</code>，修改编译环境修改为<code>Release</code>模式：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/dtcoretext_scheme_release.png" width="600" align=center/></p>
<h5 id="4-模拟器和真机分别编译"><a href="#4-模拟器和真机分别编译" class="headerlink" title="4.模拟器和真机分别编译"></a>4.模拟器和真机分别编译</h5><p>使用<code>commadn+B</code>执行代码编译，注意一定要选择正确的<code>Target</code>，既然是用于<code>iOS</code>，就应该选择<code>DTCoreText (iOS)</code>这个<code>Target</code>进行编译</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/dtcoretext_compile_generic_ios.png" width="600" align=center/>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/dtcoretext_compile_ios_simulator.png" width="600" align=center/>

<h5 id="5-打开编译缓存，获取静态库"><a href="#5-打开编译缓存，获取静态库" class="headerlink" title="5.打开编译缓存，获取静态库"></a>5.打开编译缓存，获取静态库</h5><p>在<code>Xcode</code>依次打开<code>File</code> -&gt; <code>File Setting</code> -&gt; <code>DerivedData</code>，然后点击之后的路径箭头可以找到<code>DTCoreText</code>的编译缓存文件夹：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/dtcoretext_compile_derived_data.png" width="600" align=center/></p>
<p>然后我们再依次打开<code>Build</code>-&gt;<code>Products</code>，将会看到适合模拟器和真机使用的两个静态库文件夹：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/dtcoretext_build_products.png" width="600" align=center/></p>
<h5 id="6-合并静态库"><a href="#6-合并静态库" class="headerlink" title="6.合并静态库"></a>6.合并静态库</h5><p>经过上述步骤，我分别得到了适合模拟器和真机使用的静态库，现在我们把它们合并。首先我们把<code>Products</code>文件拷贝到一个合适的位置，然后在控制台执行合并静态库的命令如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/dtcoretext_lipo_create_terminal.png" width="600" align=center/></p>
<p>如图，我们使用<code>lipo</code>命令合并了适合模拟器和真机使用的可执行文件：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/dtcoretext_lipo_create_result.png" width="300" align=center/></p>
<p>然后，我们需要将两个文件分别对应拷贝到<code>Release-iphones</code>文件夹中的<code>DTCoreText.framework</code>和<code>DTFoundation.framework</code>中，这样最终我们就得到想要的静态库。</p>
<h4 id="三、DTCoreText的使用"><a href="#三、DTCoreText的使用" class="headerlink" title="三、DTCoreText的使用"></a>三、DTCoreText的使用</h4><p>在这之前我们准备一段测试用的<code>Html</code>如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">_html <span class="operator">=</span> @<span class="string">&quot;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;&lt;strong&gt;标题1&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span align=<span class="subst">\&quot;</span>left<span class="subst">\&quot;</span> style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;详细介绍详细介绍详细介绍详细介绍详细介绍详细介绍。&lt;/span&gt;&lt;br/&gt;&lt;img src=<span class="subst">\&quot;</span>http://cn-qinqimaifang-uat.oss-cn-hangzhou.aliyuncs.com/img/specialist/upload/spcetiicwlz1v_54e2e00fa8a6faf66168571654dbfee2.jpg<span class="subst">\&quot;</span> _src=<span class="subst">\&quot;</span>http://cn-qinqimaifang-uat.oss-cn-hangzhou.aliyuncs.com/img/specialist/upload/spcetiicwlz1v_54e2e00fa8a6faf66168571654dbfee2.jpg<span class="subst">\&quot;</span>&gt;&lt;br/&gt;&lt;br/&gt;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;百度:&lt;a href=<span class="subst">\&quot;</span>http://www.baidu.com.cn<span class="subst">\&quot;</span>&gt;my testlink&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;电话：&lt;a href=<span class="subst">\&quot;</span>tel:4008001234<span class="subst">\&quot;</span>&gt;my phoneNum&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;我邮箱:&lt;a href=<span class="subst">\&quot;</span>mailto:dreamcoffeezs@163.com<span class="subst">\&quot;</span>&gt;my mail&lt;/a&gt;&lt;/span&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>关于<code>DTCoreText</code>，我们主要用到它的三个控件，分别是<code>DTAttributedLabel</code>，<code>DTAttributedTextView</code>和<code>DTAttributedTextCell</code>，下面对它们的使用进行具体说明。</p>
<h4 id="四、使用DTAttributedLabel"><a href="#四、使用DTAttributedLabel" class="headerlink" title="四、使用DTAttributedLabel"></a>四、使用DTAttributedLabel</h4><p>顾名思义，我们会把<code>DTAttributedLabel</code>当做一个<code>UILabel</code>来使用，但事实上<code>DTAttributedLabel</code>并不属于<code>UILabel</code>的子类，下面针对<code>DTAttributedLabel</code>使用的三个问题进行介绍。</p>
<h5 id="1-显示基本文本"><a href="#1-显示基本文本" class="headerlink" title="1.显示基本文本"></a>1.显示基本文本</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建DTAttributedLabel</span></span><br><span class="line">_attributedLabel <span class="operator">=</span> [[<span class="type">DTAttributedLabel</span> alloc] initWithFrame:<span class="type">CGRectZero</span>];</span><br><span class="line">_attributedLabel.delegate <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.attributedLabel];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Html转化富文本</span></span><br><span class="line"><span class="type">NSData</span> <span class="operator">*</span>data <span class="operator">=</span> [_html dataUsingEncoding:<span class="type">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="type">NSAttributedString</span> <span class="operator">*</span>attributedString <span class="operator">=</span> [[<span class="type">NSAttributedString</span> alloc] initWithHTMLData:data documentAttributes:<span class="type">NULL</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.计算Frame</span></span><br><span class="line"><span class="comment">//预设一个最大的Frame,限宽不限高，方便以后计算布局</span></span><br><span class="line">_viewMaxRect <span class="operator">=</span>  <span class="type">CGRectMake</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="type">ZSToolScreenWidth</span> <span class="operator">-</span> <span class="number">15</span><span class="operator">*</span><span class="number">2</span>, <span class="type">CGFLOAT_HEIGHT_UNKNOWN</span>);        </span><br><span class="line"><span class="type">DTCoreTextLayouter</span> <span class="operator">*</span>layouter <span class="operator">=</span> [[<span class="type">DTCoreTextLayouter</span> alloc] initWithAttributedString:attributedString];</span><br><span class="line"><span class="type">NSRange</span> entireStringRange <span class="operator">=</span> <span class="type">NSMakeRange</span>(<span class="number">0</span>, [attributedString length]);</span><br><span class="line"><span class="type">DTCoreTextLayoutFrame</span> <span class="operator">*</span>layoutFrame <span class="operator">=</span> [layouter layoutFrameWithRect:_viewMaxRect range:entireStringRange];</span><br><span class="line"><span class="type">CGSize</span> textSize <span class="operator">=</span> [layoutFrame frame].size;</span><br><span class="line"><span class="keyword">self</span>.attributedLabel.frame <span class="operator">=</span> <span class="type">CGRectMake</span>(_viewMaxRect.origin.x, _viewMaxRect.origin.y, _viewMaxRect.size.width, textSize.height);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//4.设置富文本</span></span><br><span class="line"><span class="keyword">self</span>.attributedLabel.attributedString <span class="operator">=</span> [<span class="keyword">self</span> getAttributedStringWithHtml:<span class="keyword">self</span>.html];</span><br></pre></td></tr></table></figure>

<h5 id="2-显示图片"><a href="#2-显示图片" class="headerlink" title="2.显示图片"></a>2.显示图片</h5><p>既然是富文本，<code>DTAttributedLabel</code>也会显示图片。但是如果我们的<code>Html</code>字符串里图片链接没有包含大小，图片并不能正常显示。为了显示图片我们需要懒加载获取宽高再刷新显示，这就需要用到<code>DTAttributedLabel</code>的代理方法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#pragma mark <span class="operator">-</span> <span class="type">Delegate：DTAttributedTextContentViewDelegate</span></span><br><span class="line"><span class="comment">//DTCoretText在解析Html的时候，如果遇到网络图片会插入一个占位符</span></span><br><span class="line"><span class="comment">//对于图片类型(DTImageTextAttachmentd)的占位符，我们使用DTLazyImageView来显示</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIView</span> <span class="operator">*</span>)attributedTextContentView:(<span class="type">DTAttributedTextContentView</span> <span class="operator">*</span>)attributedTextContentView viewForAttachment:(<span class="type">DTTextAttachment</span> <span class="operator">*</span>)attachment frame:(<span class="type">CGRect</span>)frame&#123;</span><br><span class="line">    <span class="keyword">if</span>([attachment isKindOfClass:[<span class="type">DTImageTextAttachment</span> <span class="keyword">class</span>]])&#123;</span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>imageURL <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;%@&quot;</span>, attachment.contentURL];</span><br><span class="line">        <span class="type">DTLazyImageView</span> <span class="operator">*</span>imageView <span class="operator">=</span> [[<span class="type">DTLazyImageView</span> alloc] initWithFrame:frame];</span><br><span class="line">        imageView.delegate <span class="operator">=</span> <span class="keyword">self</span>;<span class="comment">//图片懒加载代理</span></span><br><span class="line">        imageView.contentMode <span class="operator">=</span> <span class="type">UIViewContentModeScaleAspectFit</span>;</span><br><span class="line">        imageView.image <span class="operator">=</span> [(<span class="type">DTImageTextAttachment</span> <span class="operator">*</span>)attachment image];</span><br><span class="line">        imageView.url <span class="operator">=</span> attachment.contentURL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理gif图片</span></span><br><span class="line">        <span class="keyword">if</span> ([imageURL containsString:@<span class="string">&quot;gif&quot;</span>]) &#123;</span><br><span class="line">           dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), <span class="operator">^</span>&#123;</span><br><span class="line">                <span class="type">NSData</span> <span class="operator">*</span>gifData <span class="operator">=</span> [<span class="type">NSData</span> dataWithContentsOfURL:attachment.contentURL];</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), <span class="operator">^</span>&#123;</span><br><span class="line">                    imageView.image <span class="operator">=</span> <span class="type">DTAnimatedGIFFromData</span>(gifData);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> imageView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark  <span class="type">Delegate：DTLazyImageViewDelegate</span></span><br><span class="line"><span class="comment">//懒加载图片代理</span></span><br><span class="line"><span class="operator">-</span> (void)lazyImageView:(<span class="type">DTLazyImageView</span> <span class="operator">*</span>)lazyImageView didChangeImageSize:(<span class="type">CGSize</span>)size &#123;</span><br><span class="line">    <span class="type">NSURL</span> <span class="operator">*</span>url <span class="operator">=</span> lazyImageView.url;</span><br><span class="line">    <span class="type">CGSize</span> imageSize <span class="operator">=</span> size;</span><br><span class="line">    <span class="type">NSPredicate</span> <span class="operator">*</span>pred <span class="operator">=</span> [<span class="type">NSPredicate</span> predicateWithFormat:@<span class="string">&quot;contentURL == %@&quot;</span>, url];</span><br><span class="line">    <span class="type">BOOL</span> didUpdate <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//update all attachments that match this URL (possibly multiple images with same size)</span></span><br><span class="line">    <span class="comment">//更新所有匹配URL的占位符视图 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">DTTextAttachment</span> <span class="operator">*</span>oneAttachment <span class="keyword">in</span> [<span class="keyword">self</span>.attributedLabel.layoutFrame textAttachmentsWithPredicate:pred])&#123;</span><br><span class="line">        <span class="comment">//update attachments that have no original size, that also sets the display size</span></span><br><span class="line">        <span class="comment">//更新没有自带尺寸的占位视图(如网络图片) </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">CGSizeEqualToSize</span>(oneAttachment.originalSize, <span class="type">CGSizeZero</span>))&#123;</span><br><span class="line">            <span class="comment">//原始图片不带宽高，被识别后修改Html</span></span><br><span class="line">            oneAttachment.originalSize <span class="operator">=</span> imageSize;</span><br><span class="line">          <span class="comment">//使用新拿到的图片尺寸更新HTML字符串 </span></span><br><span class="line">            [<span class="keyword">self</span> configNoSizeImageView:url.absoluteString size:imageSize];</span><br><span class="line">            didUpdate <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (didUpdate)&#123;    </span><br><span class="line">        <span class="comment">//重新显示富文本</span></span><br><span class="line">        <span class="type">CGSize</span> textSize <span class="operator">=</span> [<span class="keyword">self</span> getAttributedTextHeightHtml:<span class="keyword">self</span>.html with_viewMaxRect:_viewMaxRect];</span><br><span class="line">        <span class="keyword">self</span>.attributedLabel.frame <span class="operator">=</span> <span class="type">CGRectMake</span>(_viewMaxRect.origin.x, _viewMaxRect.origin.y, _viewMaxRect.size.width, textSize.height);</span><br><span class="line">        <span class="keyword">self</span>.attributedLabel.attributedString <span class="operator">=</span> [<span class="keyword">self</span> getAttributedStringWithHtml:<span class="keyword">self</span>.html];</span><br><span class="line">        <span class="keyword">self</span>.attributedLabel.layouter <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">        [<span class="keyword">self</span>.attributedLabel relayoutText];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark <span class="operator">-</span> <span class="keyword">private</span> <span class="type">Methods</span></span><br><span class="line"><span class="comment">//使用得到的新图片尺寸，更新HtmlString字符串</span></span><br><span class="line"><span class="operator">-</span> (void)configNoSizeImageView:(<span class="type">NSString</span> <span class="operator">*</span>)url size:(<span class="type">CGSize</span>)size&#123;</span><br><span class="line">    <span class="comment">//_viewMaxRect是预设的最大Frame</span></span><br><span class="line">    <span class="type">CGFloat</span> imgSizeScale <span class="operator">=</span> size.height<span class="operator">/</span>size.width;</span><br><span class="line">    <span class="type">CGFloat</span> widthPx <span class="operator">=</span> _viewMaxRect.size.width;</span><br><span class="line">    <span class="type">CGFloat</span> heightPx <span class="operator">=</span> widthPx <span class="operator">*</span> imgSizeScale;</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>imageInfo <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;_src=<span class="subst">\&quot;</span>%@<span class="subst">\&quot;</span>&quot;</span>,url];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>sizeString <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;style=<span class="subst">\&quot;</span>width:%.fpx; height:%.fpx;<span class="subst">\&quot;</span>&quot;</span>,widthPx,heightPx];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>newImageInfo <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;_src=<span class="subst">\&quot;</span>%@<span class="subst">\&quot;</span>%@&quot;</span>,url,sizeString];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.html containsString:imageInfo]) &#123;</span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>newHtml <span class="operator">=</span> [<span class="keyword">self</span>.html stringByReplacingOccurrencesOfString:imageInfo withString:newImageInfo];</span><br><span class="line">        <span class="keyword">self</span>.html <span class="operator">=</span> newHtml;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用HtmlString,和预设的Frame，计算富文本视图自适应后的高度</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">CGSize</span>)getAttributedTextHeightHtml:(<span class="type">NSString</span> <span class="operator">*</span>)htmlString with_viewMaxRect:(<span class="type">CGRect</span>)_viewMaxRect&#123;</span><br><span class="line">    <span class="comment">//获取富文本</span></span><br><span class="line">    <span class="type">NSAttributedString</span> <span class="operator">*</span>attributedString <span class="operator">=</span>  [<span class="keyword">self</span> getAttributedStringWithHtml:htmlString];</span><br><span class="line">    <span class="comment">//获取布局器</span></span><br><span class="line">    <span class="type">DTCoreTextLayouter</span> <span class="operator">*</span>layouter <span class="operator">=</span> [[<span class="type">DTCoreTextLayouter</span> alloc] initWithAttributedString:attributedString];</span><br><span class="line">    <span class="type">NSRange</span> entireString <span class="operator">=</span> <span class="type">NSMakeRange</span>(<span class="number">0</span>, [attributedString length]);</span><br><span class="line">    <span class="comment">//获取Frame</span></span><br><span class="line">    <span class="type">DTCoreTextLayoutFrame</span> <span class="operator">*</span>layoutFrame <span class="operator">=</span> [layouter layoutFrameWithRect:_viewMaxRect range:entireString];</span><br><span class="line">    <span class="comment">//得到大小</span></span><br><span class="line">    <span class="type">CGSize</span> sizeNeeded <span class="operator">=</span> [layoutFrame frame].size;</span><br><span class="line">    <span class="keyword">return</span> sizeNeeded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-响应事件"><a href="#3-响应事件" class="headerlink" title="3.响应事件"></a>3.响应事件</h5><p>如果我们希望在<code>DTAttributedLabel</code>上操作点击事件，那么对应的我们也应该在<code>Html</code>中使用超链接<code>A</code>标签。这里我们需要用到如下的代理方法如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">UIView</span> <span class="operator">*</span>)attributedTextContentView:(<span class="type">DTAttributedTextContentView</span> <span class="operator">*</span>)attributedTextContentView</span><br><span class="line">                          viewForLink:(<span class="type">NSURL</span> <span class="operator">*</span>)url</span><br><span class="line">                           identifier:(<span class="type">NSString</span> <span class="operator">*</span>)identifier</span><br><span class="line">                                frame:(<span class="type">CGRect</span>)frame&#123;</span><br><span class="line">    <span class="comment">//此方法需要我们在这里返回一个可以点击响应的控件如Button,然后就可以很方便的处理响应事件了，其中：</span></span><br><span class="line">    <span class="comment">//url:Html中的超链接(可以根据需要设置http、tel、mailto等)</span></span><br><span class="line">    <span class="comment">//identifier:属于该视图的唯一性标识</span></span><br><span class="line">    <span class="comment">//frame:超链接字符串所在的位置,需要将自定义响应按钮设置为此Frame</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：如果我们需要显示一些输入框之类的视图，也可以借助此方法。</strong></p>
<p>最终效果图：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/dtcoretext_DTAttributedLabel_result.png" width="375" align=center/></p>
<h4 id="五、DTAttributedTextView"><a href="#五、DTAttributedTextView" class="headerlink" title="五、DTAttributedTextView"></a>五、DTAttributedTextView</h4><p>其实，<code>DTAttributedTextView</code>和<code>DTAttributedLabel</code>的用法几乎一样；</p>
<p>从其源码上就能看出，<code>DTAttributedLabel</code>继承于<code>DTAttributedTextContentView</code>的，而<code>DTAttributedTextView</code>包含<code>DTAttributedTextContentView</code>属性。可以说<code>DTAttributedTextView</code>就是借助<code>DTAttributedLabel</code>实现的视图。</p>
<p><code>DTAttributedTextView</code>是支持滑动显示的富文本视图，在使用时计算富文本的<code>Frame</code>也就没那么必要了，一般我们都会指定它的<code>Frame</code>，其在这里的用法就不累述了。</p>
<h4 id="六、DTAttributedTextCell"><a href="#六、DTAttributedTextCell" class="headerlink" title="六、DTAttributedTextCell"></a>六、DTAttributedTextCell</h4><p>如果我们需要在单元格上显示富文本，<code>DTCoretText</code>也为我们提供了特有的类来解决这个问题，那就是<code>DTAttributedTextCell</code>。通过这个单元格类，我们可以方便的设置富文本以及获取单元格高度。以下是使用<code>DTAttributedTextCell</code>显示富文本的核心代码：</p>
<h5 id="1-声明控制器内属性"><a href="#1-声明控制器内属性" class="headerlink" title="1. 声明控制器内属性"></a>1. 声明控制器内属性</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">TestTableViewController</span> ()<span class="operator">&lt;</span><span class="type">UITableViewDataSource</span>,<span class="type">UITableViewDelegate</span>,<span class="type">DTAttributedTextContentViewDelegate</span>,<span class="type">DTLazyImageViewDelegate</span><span class="operator">&gt;</span></span><br><span class="line"><span class="meta">@property</span>(nonatomic,strong)<span class="type">UITableView</span> <span class="operator">*</span>tableView;</span><br><span class="line"><span class="comment">//普通单元格与富文本单元格</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="keyword">copy</span>) <span class="type">NSString</span> <span class="operator">*</span>cellID_Normal;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, <span class="keyword">copy</span>) <span class="type">NSString</span> <span class="operator">*</span>cellID_DTCoreText;</span><br><span class="line"><span class="comment">//类似tabelView的缓冲池，用于存放图片大小</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong) <span class="type">NSCache</span> <span class="operator">*</span>imageSizeCache;</span><br><span class="line"><span class="meta">@property</span> (nonatomic,strong)<span class="type">NSCache</span> <span class="operator">*</span>cellCache;</span><br><span class="line"><span class="comment">//表视图数据源</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong) <span class="type">NSArray</span>  <span class="operator">*</span>dataSource;</span><br><span class="line"><span class="comment">//当前表视图是否在滑动</span></span><br><span class="line"><span class="meta">@property</span> (nonatomic,assign)<span class="type">BOOL</span> isScrolling;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<h5 id="2-表视图代理方法返回单元格及其高度"><a href="#2-表视图代理方法返回单元格及其高度" class="headerlink" title="2.表视图代理方法返回单元格及其高度"></a>2.表视图代理方法返回单元格及其高度</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代理方法：返回单元格</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UITableViewCell</span> <span class="operator">*</span>)tableView:(<span class="type">UITableView</span> <span class="operator">*</span>)tableView cellForRowAtIndexPath:(<span class="type">NSIndexPath</span> <span class="operator">*</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">switch</span> (indexPath.section) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">            <span class="comment">//普通单元格</span></span><br><span class="line">            <span class="type">UITableViewCell</span> <span class="operator">*</span>cell <span class="operator">=</span> [tableView dequeueReusableCellWithIdentifier:_cellID_Normal];</span><br><span class="line">            cell.textLabel.text <span class="operator">=</span> <span class="keyword">self</span>.dataSource[indexPath.section][indexPath.row];</span><br><span class="line">            <span class="keyword">return</span> cell;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">            <span class="comment">//自定义方法，创建富文本类型的单元格</span></span><br><span class="line">            <span class="type">ZSDTCoreTextCell</span> <span class="operator">*</span>dtCell <span class="operator">=</span> (<span class="type">ZSDTCoreTextCell</span> <span class="operator">*</span>) [<span class="keyword">self</span> tableView:tableView prepareCellForIndexPath:indexPath];</span><br><span class="line">            <span class="keyword">return</span> dtCell;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回单元格高度</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">CGFloat</span>)tableView:(<span class="type">UITableView</span> <span class="operator">*</span>)tableView heightForRowAtIndexPath:(nonnull <span class="type">NSIndexPath</span> <span class="operator">*</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">switch</span> (indexPath.section) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">          <span class="comment">//返回富文本类型单元格的方法</span></span><br><span class="line">            <span class="type">ZSDTCoreTextCell</span> <span class="operator">*</span>cell <span class="operator">=</span> (<span class="type">ZSDTCoreTextCell</span> <span class="operator">*</span>)[<span class="keyword">self</span> tableView:tableView prepareCellForIndexPath:indexPath];</span><br><span class="line">            <span class="keyword">return</span> [cell requiredRowHeightInTableView:tableView];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-懒加载处理无宽高属性的图片"><a href="#3-懒加载处理无宽高属性的图片" class="headerlink" title="3.懒加载处理无宽高属性的图片"></a>3.懒加载处理无宽高属性的图片</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#pragma mark <span class="operator">-</span> <span class="type">DTAttributedTextContentViewDelegate</span></span><br><span class="line"><span class="comment">//对于没有在Html标签里设置宽高的图片，在这里为其设置占位</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIView</span> <span class="operator">*</span>)attributedTextContentView:(<span class="type">DTAttributedTextContentView</span> <span class="operator">*</span>)attributedTextContentView viewForAttachment:(<span class="type">DTTextAttachment</span> <span class="operator">*</span>)attachment frame:(<span class="type">CGRect</span>)frame&#123;</span><br><span class="line">    <span class="keyword">if</span>([attachment isKindOfClass:[<span class="type">DTImageTextAttachment</span> <span class="keyword">class</span>]])&#123;</span><br><span class="line">        <span class="comment">//自定义的ZSDTLazyImageView继承于DTLazyImageView，增加了一个属性textContentView</span></span><br><span class="line">        <span class="comment">//用于更新图片大小</span></span><br><span class="line">        <span class="type">ZSDTLazyImageView</span> <span class="operator">*</span>imageView <span class="operator">=</span> [[<span class="type">ZSDTLazyImageView</span> alloc] initWithFrame:frame];</span><br><span class="line">        imageView.delegate <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">        imageView.image <span class="operator">=</span> [(<span class="type">DTImageTextAttachment</span> <span class="operator">*</span>)attachment image];</span><br><span class="line">        imageView.textContentView <span class="operator">=</span> attributedTextContentView;</span><br><span class="line">        imageView.url <span class="operator">=</span> attachment.contentURL;</span><br><span class="line">        <span class="keyword">return</span> imageView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于无宽高的图片懒加载，缓存记录其大小,然后执行表视图更新</span></span><br><span class="line"><span class="operator">-</span> (void)lazyImageView:(<span class="type">ZSDTLazyImageView</span> <span class="operator">*</span>)lazyImageView didChangeImageSize:(<span class="type">CGSize</span>)size&#123;</span><br><span class="line">    <span class="type">BOOL</span> needUpdate <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">    <span class="type">NSURL</span> <span class="operator">*</span>url <span class="operator">=</span> lazyImageView.url;</span><br><span class="line">    <span class="type">NSPredicate</span> <span class="operator">*</span>pred <span class="operator">=</span> [<span class="type">NSPredicate</span> predicateWithFormat:@<span class="string">&quot;contentURL == %@&quot;</span>, url];</span><br><span class="line">    <span class="comment">/* update all attachments that matchin this URL (possibly multiple</span></span><br><span class="line"><span class="comment">        images with same size)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">DTTextAttachment</span> <span class="operator">*</span>oneAttachment <span class="keyword">in</span> [lazyImageView.textContentView.layoutFrame textAttachmentsWithPredicate:pred])&#123;</span><br><span class="line">        <span class="comment">// update attachments that have no original size, that also sets the display size</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">CGSizeEqualToSize</span>(oneAttachment.originalSize, <span class="type">CGSizeZero</span>))&#123;</span><br><span class="line">            oneAttachment.originalSize <span class="operator">=</span> size;</span><br><span class="line">            <span class="type">NSValue</span> <span class="operator">*</span>sizeValue <span class="operator">=</span> [_imageSizeCache objectForKey:oneAttachment.contentURL];</span><br><span class="line">            <span class="keyword">if</span> (<span class="operator">!</span>sizeValue) &#123;</span><br><span class="line">                <span class="comment">//将图片大小记录在缓存中，但是这种图片的原始尺寸可能很大，所以这里设置图片的最大宽</span></span><br><span class="line">                <span class="comment">//并且计算高</span></span><br><span class="line">                <span class="type">CGFloat</span> aspectRatio <span class="operator">=</span> size.height <span class="operator">/</span> size.width;</span><br><span class="line">                <span class="type">CGFloat</span> width <span class="operator">=</span> <span class="type">ZSToolScreenWidth</span> <span class="operator">-</span> <span class="number">15</span><span class="operator">*</span><span class="number">2</span>;</span><br><span class="line">                <span class="type">CGFloat</span> height <span class="operator">=</span> width <span class="operator">*</span> aspectRatio;</span><br><span class="line">                <span class="type">CGSize</span> newSize <span class="operator">=</span> <span class="type">CGSizeMake</span>(width, height);</span><br><span class="line">                [_imageSizeCache setObject:[<span class="type">NSValue</span> valueWithCGSize:newSize]forKey:url];</span><br><span class="line">            &#125;</span><br><span class="line">            needUpdate <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needUpdate)&#123;</span><br><span class="line">        <span class="comment">//有新的图片尺寸被缓存记录的时候，需要刷新表视图</span></span><br><span class="line">        [<span class="keyword">self</span> reloadCurrentCell];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-创建富文本单元格的方法"><a href="#4-创建富文本单元格的方法" class="headerlink" title="4.创建富文本单元格的方法"></a>4.创建富文本单元格的方法</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#pragma mark <span class="operator">-</span> <span class="keyword">private</span> <span class="type">Methods</span></span><br><span class="line"><span class="comment">//创建富文本单元格，并更新单元格上的数据</span></span><br><span class="line"><span class="comment">//ZSDTCoreTextCell是自定义的继承于DTCoreTextCell的单元格</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">ZSDTCoreTextCell</span> <span class="operator">*</span>)tableView:(<span class="type">UITableView</span> <span class="operator">*</span>)tableView prepareCellForIndexPath:(<span class="type">NSIndexPath</span> <span class="operator">*</span>)indexPath&#123;</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>key <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;dtCoreTextCellKEY%ld-%ld&quot;</span>, (long)indexPath.section, (long)indexPath.row];</span><br><span class="line">    <span class="type">ZSDTCoreTextCell</span> <span class="operator">*</span>cell <span class="operator">=</span> [_cellCache objectForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>cell)&#123;</span><br><span class="line">        cell <span class="operator">=</span> [[<span class="type">ZSDTCoreTextCell</span> alloc] initWithStyle:<span class="type">UITableViewCellStyleDefault</span> reuseIdentifier:_cellID_DTCoreText];</span><br><span class="line">        cell.attributedTextContextView.edgeInsets <span class="operator">=</span> <span class="type">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">        [cell setSelectionStyle:<span class="type">UITableViewCellSelectionStyleNone</span>];</span><br><span class="line">        cell.accessoryType <span class="operator">=</span> <span class="type">UITableViewCellAccessoryNone</span>;</span><br><span class="line">        cell.hasFixedRowHeight <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">        cell.textDelegate <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">        cell.attributedTextContextView.shouldDrawImages <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">        <span class="comment">//记录在缓存中</span></span><br><span class="line">        [_cellCache setObject:cell forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.设置数据</span></span><br><span class="line">    <span class="comment">//2.1为富文本单元格设置Html数据</span></span><br><span class="line">    [cell setHTMLString:<span class="keyword">self</span>.dataSource[indexPath.section][indexPath.row]];</span><br><span class="line">    <span class="comment">//2.2为每个占位图(图片)设置大小，并更新</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">DTTextAttachment</span> <span class="operator">*</span>oneAttachment <span class="keyword">in</span> cell.attributedTextContextView.layoutFrame.textAttachments) &#123;</span><br><span class="line">        <span class="type">NSValue</span> <span class="operator">*</span>sizeValue <span class="operator">=</span> [_imageSizeCache objectForKey:oneAttachment.contentURL];</span><br><span class="line">        <span class="keyword">if</span> (sizeValue) &#123;</span><br><span class="line">            cell.attributedTextContextView.layouter<span class="operator">=</span><span class="literal">nil</span>;</span><br><span class="line">            oneAttachment.displaySize <span class="operator">=</span> [sizeValue <span class="type">CGSizeValue</span>];</span><br><span class="line">            [cell.attributedTextContextView relayoutText];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [cell.attributedTextContextView relayoutText];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-处理表视图的刷新"><a href="#5-处理表视图的刷新" class="headerlink" title="5.处理表视图的刷新"></a>5.处理表视图的刷新</h5><p>如果当前表视图在滑动就不执行刷新，因为滑动时候会自动调用表视图的刷新方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)reloadCurrentCell&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isScrolling) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前表视图没有在滑动，就手动刷新当前在屏幕显示的单元格</span></span><br><span class="line">    <span class="type">NSArray</span> <span class="operator">*</span>indexPaths <span class="operator">=</span> [<span class="keyword">self</span>.tableView indexPathsForVisibleRows];</span><br><span class="line">    <span class="keyword">if</span>(indexPaths)&#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), <span class="operator">^</span>&#123;</span><br><span class="line">            [<span class="keyword">self</span>.tableView reloadRowsAtIndexPaths:indexPaths withRowAnimation:<span class="type">UITableViewRowAnimationNone</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)scrollViewDidEndScrollingAnimation:(<span class="type">UIScrollView</span> <span class="operator">*</span>)scrollView&#123;</span><br><span class="line">    _isScrolling <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)scrollViewDidScroll:(<span class="type">UIScrollView</span> <span class="operator">*</span>)scrollView&#123;</span><br><span class="line">    _isScrolling <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-set方法创建表视图与数据源"><a href="#6-set方法创建表视图与数据源" class="headerlink" title="6.set方法创建表视图与数据源"></a>6.set方法创建表视图与数据源</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#pragma mark <span class="operator">-</span> <span class="keyword">set</span><span class="operator">/</span><span class="keyword">get</span>方法</span><br><span class="line"><span class="operator">-</span> (<span class="type">UITableView</span> <span class="operator">*</span>)tableView&#123;</span><br><span class="line">    <span class="keyword">if</span> (_tableView <span class="operator">==</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        _tableView <span class="operator">=</span> [[<span class="type">UITableView</span>  alloc] initWithFrame:<span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="type">ZSToolScreenWidth</span>, <span class="type">ZSToolScreenHeight</span><span class="operator">-</span><span class="number">64</span>) style:<span class="type">UITableViewStylePlain</span>];</span><br><span class="line">        _tableView.dataSource <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">        _tableView.delegate <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">        [_tableView registerClass:[<span class="type">UITableViewCell</span> <span class="keyword">class</span>] forCellReuseIdentifier:_cellID_Normal];</span><br><span class="line">        <span class="comment">//[_tableView registerClass:[ZSDTCoreTextCell class] forCellReuseIdentifier:_cellID_DTCoreText];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _tableView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">NSArray</span> <span class="operator">*</span>)dataSource&#123;</span><br><span class="line">    <span class="keyword">if</span>(_dataSource <span class="operator">==</span> <span class="literal">nil</span>)&#123;</span><br><span class="line">        <span class="type">NSMutableArray</span> <span class="operator">*</span>noramDataArray <span class="operator">=</span> @[].mutableCopy;</span><br><span class="line">        <span class="type">NSMutableArray</span> <span class="operator">*</span>htmlDataArray <span class="operator">=</span> @[].mutableCopy;</span><br><span class="line">        <span class="type">NSArray</span> <span class="operator">*</span>images <span class="operator">=</span> @[@<span class="string">&quot;https://i0.hdslb.com/bfs/archive/d5ad3cf95d32f3d2f2e3471a39120237200d84d8.jpg&quot;</span>,</span><br><span class="line">                           @<span class="string">&quot;https://i0.hdslb.com/bfs/archive/71d2fed927d9351e759f408ca7d66c556c37a6b4.jpg&quot;</span>,</span><br><span class="line">                           @<span class="string">&quot;https://i0.hdslb.com/bfs/archive/7f520b31b67cd5d89dd30b61b40711327bb00288.png&quot;</span>,</span><br><span class="line">                           @<span class="string">&quot;https://i0.hdslb.com/bfs/archive/6edbe81bf74c106087ad139aca169d6e8d9d963b.jpg&quot;</span>,</span><br><span class="line">                           @<span class="string">&quot;https://i0.hdslb.com/bfs/archive/805aa8f7ae722fcc277f425bb9927e29ec1d2468.jpg&quot;</span>,</span><br><span class="line">                           @<span class="string">&quot;https://i0.hdslb.com/bfs/archive/a7c61d94c583363a970d2a2e339eea97f8f32317.jpg&quot;</span>,</span><br><span class="line">                           @<span class="string">&quot;https://i0.hdslb.com/bfs/archive/b447ee1fd63b4cf6f4465a5621cc12898867d26b.jpg&quot;</span>];</span><br><span class="line">        <span class="keyword">for</span>(int i <span class="operator">=</span> <span class="number">0</span>;i<span class="operator">&lt;</span><span class="number">1000</span>;i<span class="operator">++</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i <span class="operator">&lt;</span><span class="number">6</span>)&#123;</span><br><span class="line">                [noramDataArray addObject:[<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;测试普通单元格:%d&quot;</span>,i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里提供的Html图片链接，没有宽高属性，代码中已经演示了如何处理</span></span><br><span class="line">            int k <span class="operator">=</span> i <span class="operator">%</span> <span class="number">6</span>;</span><br><span class="line">            <span class="type">NSString</span> <span class="operator">*</span>htmlString <span class="operator">=</span>[<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;&lt;strong&gt;测试富文本单元格%d：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;记住！砍价是由你自己先砍，砍不动时再由砍价师继续砍；由砍价师多砍下的部分，才按照下列标准收费：&lt;/span&gt;&lt;br/&gt;&lt;span style=<span class="subst">\&quot;</span>color:#333;font-size:15px;<span class="subst">\&quot;</span>&gt;&lt;img src=%@ _src=%@&gt;&lt;/span&gt;&quot;</span>,i,images[k],images[k]];</span><br><span class="line">            [htmlDataArray addObject:htmlString];</span><br><span class="line">        &#125;</span><br><span class="line">        _dataSource <span class="operator">=</span> @[noramDataArray,htmlDataArray];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>DTAttributedTextCell</code>的最终效果图如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/dtcoretext_DTAttributedTextCell_result.png" width="375" align=center/></p>
<h4 id="七、可能遇到的错误"><a href="#七、可能遇到的错误" class="headerlink" title="七、可能遇到的错误"></a>七、可能遇到的错误</h4><p>原本上，在项目中使用只需将<code>Release-iphones</code>的<code>DTCoreText.framework</code>和<code>DTFoundation.framework</code>中拖入工程就可以使用了。</p>
<p>然而，我在编译工程却会遇到这样一个错误：<code>&quot;image not found&quot;</code></p>
<p>解决方法如下图：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/dtcoretext_image_not_found.png" width="600" align=center/></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>UI问题</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发-ReactiveCocoa应用篇</title>
    <url>/2019/03/02/iOS%E5%BC%80%E5%8F%91-ReactiveCocoa%E5%BA%94%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<p>使用RAC其实就是一个创建信号订阅信号的过程。上篇<a href="https://www.jianshu.com/p/ba90d649ecb8">ReactiveCocoa函数响应式编程-基础篇</a>，主要简单介绍了RAC的信号机制，本篇则以信号为核心，就信号常用的类、操作信号的方法，替换响应处理等方面总结RAC的使用。</p>
<span id="more"></span>

<p><strong>主要内容</strong></p>
<ol>
<li>RAC中常用的类</li>
<li>RAC中常用的宏</li>
<li>RAC中信号的常用操作</li>
<li>RAC常用的处理事件响应的方法本篇总结</li>
</ol>
<p><strong>本篇还提供了关于RAC使用的两个测试工程，结合代码学习更加直观</strong>：<br><a href="https://github.com/DreamcoffeeZS/ReactiveCocoaDemo">项目1</a>：<br>1.测试RAC对信号的各类操作。<br>2.使用RAC改进一个普通的登录界面。<br><a href="https://github.com/DreamcoffeeZS/MVVMReactiveCocoa">项目2</a>：<br>MVVM架构结合RAC响应式编程的开发示例。实现登录界面和的分页数据界面。效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/1244124-34473c827d2898b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="RAC&amp;&amp;MVVM实现一个登录界面和一个分页数据表视图界面"></p>
<h1 id="一、RAC中常用的类"><a href="#一、RAC中常用的类" class="headerlink" title="一、RAC中常用的类"></a>一、RAC中常用的类</h1><h2 id="1-RACSubject"><a href="#1-RACSubject" class="headerlink" title="1.RACSubject"></a>1.RACSubject</h2><p>RACSubject是信号RACSignal的一个子类，但它的底部实现与RACSignal有所不同。其订阅信号subscribeNext的方法只是使用nextBlock创建了一个订阅者并保存起来待用，多次调用subscribeNext会保存多个订阅者。<strong>只有发送信号sendNext方法执行时，订阅者才会执行nextBlock里的内容，多个订阅者会执行多次</strong>。<br>使用示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建信号</span></span><br><span class="line"><span class="comment">//创建RACSubject不需要block参数</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.订阅信号</span></span><br><span class="line"><span class="comment">//这里信号被订阅两次，那么订阅者也创建了两次，保存在RACSubject的subscribers属性数组中。</span></span><br><span class="line"><span class="comment">//那么每当信号有新值发出的时候，每个订阅者都会执行。    </span></span><br><span class="line">[subject subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">    <span class="comment">//block在信号发出新值时调用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第一个订阅者:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第二个订阅者:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.发送信号</span></span><br><span class="line">[subject sendNext:<span class="string">@&quot;6”];</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">13</span>:<span class="number">07</span>:<span class="number">51.425569</span>+<span class="number">0800</span> ZSTest[<span class="number">2840</span>:<span class="number">124915</span>] 第一个订阅者:<span class="number">6</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">13</span>:<span class="number">07</span>:<span class="number">51.426113</span>+<span class="number">0800</span> ZSTest[<span class="number">2840</span>:<span class="number">124915</span>] 第二个订阅者:<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>应用示例：<strong>替换代理</strong><br>我们测试这样一个功能：在当前视图控制器A中点击按钮调转到下一视图控制器B，在B的文本框中输入内容，点击编辑完成按钮回到A，显示B中输入的内容到A的UILabel上。通常我们使用代理来解决这样的问题，那么现在我们可以利用RACSubject的特性来代替常用的代理的功能，其实就跟我们使用block回调一样。具体代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.下一视图控制中添加RACSubject属性。</span></span><br><span class="line"><span class="comment">//SecondViewController.h文件</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SecondViewController</span> : <span class="title">BaseViewController</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSubject *racSubject;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.点击编辑完成按钮时，检查代理信号并发送消息，这里传递出一个字典(包含输入的文字)</span></span><br><span class="line"><span class="comment">//SecondViewController.m文件</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)completeBtnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.racSubject)&#123;</span><br><span class="line">        [<span class="keyword">self</span>.racSubject sendNext:@&#123;<span class="string">@&quot;text&quot;</span>:<span class="keyword">self</span>.txtField.text&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.当前视图控制器A的跳转按钮响应方法中，创建secondVC，并为其添加信号属性和订阅信号。</span></span><br><span class="line"><span class="comment">//TestViewCotroller.m文件</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)testBtnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    SecondViewController *secondVC = [[SecondViewController alloc] initWithNibName:<span class="string">@&quot;SecondViewController&quot;</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">   <span class="comment">//为secondVC设置RACSubject属性，并订阅信号</span></span><br><span class="line">    secondVC.racSubject = [RACSubject subject];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//定阅信号的block会更新文字的显示</span></span><br><span class="line">    [secondVC.racSubject subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *infoDic =(<span class="built_in">NSDictionary</span> *)x;</span><br><span class="line">        weakSelf.showLabel.text =  infoDic[<span class="string">@&quot;text&quot;</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController pushViewController:secondVC animated:<span class="literal">YES</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-RACTuple与RACSequence"><a href="#2-RACTuple与RACSequence" class="headerlink" title="2.RACTuple与RACSequence"></a>2.RACTuple与RACSequence</h2><p><strong>RACTuple</strong>：类似OC的数组，是RAC中用来封装值的元组类，可以配合RACTupleUnpack解元组。<br><strong>RACSequeue</strong>：数组和字典经过rac_sequence方法会被转化为RACSequeue类型，并进一步转为我们常用的信号。订阅此类信号的时候，信号就会被激活并遍历其中的所有值。</p>
<p>使用示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *characters = @[<span class="string">@&quot;A&quot;</span>,<span class="string">@&quot;C&quot;</span>,<span class="string">@&quot;B&quot;</span>,<span class="string">@&quot;E&quot;</span>,<span class="string">@&quot;D&quot;</span>];</span><br><span class="line">    [characters.rac_sequence.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;char:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="type">char</span>:A</span><br><span class="line"><span class="type">char</span>:C</span><br><span class="line"><span class="type">char</span>:B</span><br><span class="line"><span class="type">char</span>:E</span><br><span class="line"><span class="type">char</span>:D</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历字典</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *myInfoDic = @&#123;<span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;zs&quot;</span>,<span class="string">@&quot;nickname&quot;</span>:<span class="string">@&quot;FengZi&quot;</span>,<span class="string">@&quot;age&quot;</span>:<span class="string">@&quot;18&quot;</span>&#125;;\</span><br><span class="line">[myInfoDic.rac_sequence.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//解元组，注意一一对应</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *key,<span class="built_in">NSString</span> *value) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;myInfoDic:%@-%@&quot;</span>,key,value);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line">myInfoDic:name-zs</span><br><span class="line">myInfoDic:nickname-FengZi</span><br><span class="line">myInfoDic:age<span class="number">-18</span></span><br></pre></td></tr></table></figure>



<h2 id="3-RACMulticastConnection"><a href="#3-RACMulticastConnection" class="headerlink" title="3.RACMulticastConnection"></a>3.RACMulticastConnection</h2><p>RACMulticastConnection用于解决一个信号被多次订阅后，创建信号中的block被重复调用的问题，所以在实际开发中，使用RACMulticastConnection可以解决网络重复请求的问题。<br>测试1:普通的信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;发送信号A&quot;</span>);</span><br><span class="line">   [subscriber sendNext:<span class="string">@&quot;发送信号A&quot;</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalA subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;第一次订阅：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"> [signalA subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;第二次订阅：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.702607</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 发送信号A</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.702856</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第一次订阅：发送信号A</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.703069</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 发送信号A</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.703325</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第二次订阅：发送信号A</span><br></pre></td></tr></table></figure>

<p>测试2：使用RACMulticastConnection</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建信号</span></span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;发送信号B&quot;</span>);</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号B&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.连接信号：publish或者muticast方法</span></span><br><span class="line"><span class="comment">//连接后的信号使用订阅方法时，并不能激活信号，而是将其订阅者保存到数组中。</span></span><br><span class="line"><span class="comment">//在连接对象执行connect方法时，信号中的订阅者会统一调用sendNext方法。</span></span><br><span class="line">RACMulticastConnection *signalBconnect = [signalB publish];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.订阅信号</span></span><br><span class="line"><span class="comment">//使用signalBconnect而不再是signalB</span></span><br><span class="line">[signalBconnect.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第一次订阅：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signalBconnect.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第二次订阅：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.连接后激活信号</span></span><br><span class="line">[signalBconnect connect];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.704209</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 发送信号B</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.704368</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第一次订阅：发送信号B</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.704543</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第二次订阅：发送信号B</span><br></pre></td></tr></table></figure>

<h2 id="4-RACCommand：用于处理事件的类"><a href="#4-RACCommand：用于处理事件的类" class="headerlink" title="4.RACCommand：用于处理事件的类"></a>4.RACCommand：用于处理事件的类</h2><p>RACCommand可以把事件如何处理，如何传递都封装到类中，之后就可以方便的调起它的执行方法。在实际开发中，我们可以用它来封装一个网络操作。<br>注意：<br>1.创建方法中block返回一个信号，且不能为nil，但是可以使用[RACSignal empty]表示空信号<br>2.RACCommand必须被强引用，否则容易被释放</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建RACCommand：initWithSignalBlock</span></span><br><span class="line"><span class="keyword">self</span>.command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(<span class="type">id</span>  _Nullable input) &#123;</span><br><span class="line">    <span class="comment">//我们常在这里创建一个网络请求的信号，也就是封装一个请求数据的操作。</span></span><br><span class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@&quot;网络请求的信号&quot;</span>];</span><br><span class="line">        <span class="comment">//数据传递完成，必须调用sendComplleted.,否则永远处于执行中。</span></span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> signal;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.订阅RACCommand中的信号，要等到RACCommand执行后，才能收到消息</span></span><br><span class="line">[<span class="keyword">self</span>.command.executionSignals subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//这里是一个信号中信号</span></span><br><span class="line">    [x subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;收到信号：%@&quot;</span>,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进订阅方法：switchToLatest可以直接获取信号中信号</span></span><br><span class="line">[<span class="keyword">self</span>.command.executionSignals.switchToLatest subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;改进-收到信号：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.监听RACCommand命令是否执行完毕的信号</span></span><br><span class="line"><span class="comment">//默认会监测一次，所以可以使用skip表示跳过第一次信号。</span></span><br><span class="line"><span class="comment">//这里可以用于App网络请求时，控制加载提示视图的隐藏或者显示</span></span><br><span class="line">[[<span class="keyword">self</span>.command.executing skip:<span class="number">1</span>] subscribeNext:^(<span class="built_in">NSNumber</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="keyword">if</span>([x boolValue] == <span class="literal">YES</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;RACCommand命令正在执行...&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;RACCommand命令不在执行中！！！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.执行RACComand</span></span><br><span class="line"><span class="comment">//方法：- (RACSignal *)execute:(id)input</span></span><br><span class="line">[<span class="keyword">self</span>.command execute:<span class="string">@&quot;&quot;</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.571968</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] RACCommand命令正在执行...</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.572526</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] 收到信号：网络请求的信号</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.572662</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] 改进-收到信号：网络请求的信号</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.573506</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] RACCommand命令不在执行中！！！</span><br></pre></td></tr></table></figure>

<h1 id="二、RAC常用的宏定义"><a href="#二、RAC常用的宏定义" class="headerlink" title="二、RAC常用的宏定义"></a>二、RAC常用的宏定义</h1><h2 id="1-RAC-对象，对象属性-：绑定属性"><a href="#1-RAC-对象，对象属性-：绑定属性" class="headerlink" title="1.RAC(对象，对象属性)：绑定属性"></a>1.RAC(对象，对象属性)：绑定属性</h2><p>输入框背景色绑定了映射后的validUserNameSignal信号，信号变化时背景色更新</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RAC(<span class="keyword">self</span>.userNameTxtField,backgroundColor) = [validUserNameSignal map:^<span class="type">id</span> _Nullable(<span class="built_in">NSNumber</span> *userNameValid) &#123;</span><br><span class="line">    <span class="keyword">return</span> [userNameValid boolValue] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="2-RACObserve-被观察的对象，被观察对象的属性-：代替KVO监听某个对象的某个属性"><a href="#2-RACObserve-被观察的对象，被观察对象的属性-：代替KVO监听某个对象的某个属性" class="headerlink" title="2.RACObserve(被观察的对象，被观察对象的属性) ：代替KVO监听某个对象的某个属性"></a>2.RACObserve(被观察的对象，被观察对象的属性) ：代替KVO监听某个对象的某个属性</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[RACObserve(<span class="keyword">self</span>.view, backgroundColor) subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;测试：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//颜色变化时将打印</span></span><br><span class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line"><span class="keyword">self</span>.view.backgroundColor =[<span class="built_in">UIColor</span> redColor];</span><br></pre></td></tr></table></figure>

<h2 id="3-RACTuplePack与RACTupleUnpack"><a href="#3-RACTuplePack与RACTupleUnpack" class="headerlink" title="3.RACTuplePack与RACTupleUnpack"></a>3.RACTuplePack与RACTupleUnpack</h2><p><strong>RACTuplePack</strong>：将数据封装成元组<br><strong>RACTupleUnpack</strong>：将元组解包为数据</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用RACTuplePack封装元组</span></span><br><span class="line">RACTuple *racTuple = RACTuplePack(<span class="string">@&quot;字符串1&quot;</span>,<span class="string">@&quot;字符串2&quot;</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;测试racTuple:%@&quot;</span>,racTuple);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用RACTupleUnpack解元组</span></span><br><span class="line">RACTupleUnpack(<span class="built_in">NSString</span> *str1,<span class="built_in">NSString</span> *str2) = racTuple;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;测试RACTupleUnpack：%@-%@&quot;</span>,str1,str2);</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-26</span> <span class="number">19</span>:<span class="number">27</span>:<span class="number">27.568399</span>+<span class="number">0800</span> ZSTest[<span class="number">23113</span>:<span class="number">380213</span>] 测试racTuple:&lt;RACTwoTuple: <span class="number">0x60400000ed70</span>&gt; (</span><br><span class="line">    <span class="string">&quot;\U5b57\U7b26\U4e321&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\U5b57\U7b26\U4e322&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-26</span> <span class="number">19</span>:<span class="number">27</span>:<span class="number">27.568623</span>+<span class="number">0800</span> ZSTest[<span class="number">23113</span>:<span class="number">380213</span>] 测试RACTupleUnpack：字符串<span class="number">1</span>-字符串<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="4-weakify、-strongify"><a href="#4-weakify、-strongify" class="headerlink" title="4.@weakify、@strongify"></a>4.@weakify、@strongify</h2><p>RAC中使用@weakify、@strongify解决Block循环引用的问题。<strong>在block内部使用@strongify(self)后就可以使用self操作属性了，但是一定注意这两个宏定义一定要配合使用</strong>，<a href="https://www.jianshu.com/p/701da54bd78c">可参考源码分析</a>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line"><span class="comment">//RAC处理手势，点击页面，隐藏键盘</span></span><br><span class="line">[<span class="keyword">self</span>.tapGesture.rac_gestureSignal subscribeNext:^(__kindof <span class="built_in">UIGestureRecognizer</span> * _Nullable x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="comment">//经过宏定义处理后就可以使用self了，但此self非彼self。具体可查看源码分析</span></span><br><span class="line">    [<span class="keyword">self</span>.view endEditing:<span class="literal">YES</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>







<h1 id="三、RAC中关于信号的常用操作"><a href="#三、RAC中关于信号的常用操作" class="headerlink" title="三、RAC中关于信号的常用操作"></a>三、RAC中关于信号的常用操作</h1><p>本节整理了以下几种常用信号操作：<br>1.信号映射：map与flattenMap<br>2.信号过滤：filter、ignore、 distinctUntilChanged<br>3.信号合并： combineLatest、reduce、merge、zipWith<br>4.信号连接：concat、then<br>5.信号操作时间：timeout、interval、dely<br>6.信号取值：take、takeLast、takeUntil、<br>7.信号跳过：skip<br>8.信号发送顺序：donext、cocompleted<br>9.获取信号中的信号：switchToLatest<br>10.信号错误重试：retry<br>11.信号节流：throttle<br>12.信号操作多线程：deliverON、subscribeOn</p>
<h2 id="1-信号映射：map与flattenMap"><a href="#1-信号映射：map与flattenMap" class="headerlink" title="1.信号映射：map与flattenMap"></a>1.信号映射：map与flattenMap</h2><p><strong>map</strong>：将信号内容修改为另一种新值。改变了传递的值<br><strong>flattenMap</strong>：将源信号映射修改为另一种新的信号。修改了信号本身</p>
<h3 id="1-1、map"><a href="#1-1、map" class="headerlink" title="1.1、map"></a>1.1、map</h3><p>将信号文本值修改为文本长度</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//block中return的是你希望接收到的值</span></span><br><span class="line">[[<span class="keyword">self</span>.txtField.rac_textSignal map:^<span class="type">id</span> _Nullable(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> @(value.length);<span class="comment">//必须返回一个对象</span></span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">     <span class="comment">//输入abcd，打印了输入字符的长度</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;打印x:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">41.831785</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">42.575238</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">43.602008</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">44.054940</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2、flattenMap"><a href="#1-2、flattenMap" class="headerlink" title="1.2、flattenMap"></a>1.2、flattenMap</h3><p>flattenMap的block返回的是你想要的信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个普通信号</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号：1&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个发送信号的信号，信号的信号</span></span><br><span class="line">RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:signal];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//订阅信号中的信号</span></span><br><span class="line">[signalOfSignals subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//不使用flattenMap，会打印出内部信号</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅signalOfSignals：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[signalOfSignals flattenMap:^__kindof RACSignal * _Nullable(<span class="type">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">   &#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//使用flattenMap，会打印内部信号的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;使用flattenMap后订阅signalOfSignals：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">42.920455</span>+<span class="number">0800</span> ZSTest[<span class="number">1363</span>:<span class="number">61658</span>] 订阅signalOfSignals：&lt;RACDynamicSignal: <span class="number">0x60400023a320</span>&gt; name: </span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">42.920791</span>+<span class="number">0800</span> ZSTest[<span class="number">1363</span>:<span class="number">61658</span>] 使用flattenMap后订阅signalOfSignals：发送信号：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>特别说明：信号中信号常出现在我们封装一个网络请求为信号的时候，这时候注意flattenMap的使用。</strong></p>
<h2 id="2-信号过滤：filter、ignore、-distinctUntilChanged"><a href="#2-信号过滤：filter、ignore、-distinctUntilChanged" class="headerlink" title="2.信号过滤：filter、ignore、 distinctUntilChanged"></a>2.信号过滤：filter、ignore、 distinctUntilChanged</h2><h3 id="2-1、filter"><a href="#2-1、filter" class="headerlink" title="2.1、filter"></a>2.1、filter</h3><p>过滤信号，符合条件的信号才能发出消息。<br>示例：输入1234，当输入到4(文本长度大于3)的时候才开始打印如下的信息</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.txtField.rac_textSignal filter:^<span class="type">BOOL</span>(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.length &gt; <span class="number">3</span>;</span><br><span class="line">    &#125;] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;打印x：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">39</span>:<span class="number">23.371432</span>+<span class="number">0800</span> ZSTest[<span class="number">1428</span>:<span class="number">68939</span>] 打印x：<span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2、ignore"><a href="#2-2、ignore" class="headerlink" title="2.2、ignore"></a>2.2、ignore</h3><p>忽略信号，针对信号值的某一种状态进行忽略，忽略时不会发送消息。<br>示例：监听每次的输入，但是当文本框内的内容是”a”时不会打印</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.txtField.rac_textSignal ignore:<span class="string">@&quot;a&quot;</span>] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;ignore测试打印：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="2-3、distinctUntilChanged"><a href="#2-3、distinctUntilChanged" class="headerlink" title="2.3、distinctUntilChanged"></a>2.3、distinctUntilChanged</h3><p>当上次的值与当前值有变化时才会发出消息，否则信息被忽略</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了方便测试，我们监测控制器的currentText属性来修改Label的文本值。</span></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[[RACObserve(<span class="keyword">self</span>, currentText) distinctUntilChanged] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;使用%@更新testLabel的值&quot;</span>,x);</span><br><span class="line">    weakSelf.testLabel.text = x;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//currentTxt未被赋初值，所以第一次打印null,我们自己修改三次值，只打印两次</span></span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">控制台打印:</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">54.617385</span>+<span class="number">0800</span> ZSTest[<span class="number">3598</span>:<span class="number">220992</span>] 使用(null)更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">54.618026</span>+<span class="number">0800</span> ZSTest[<span class="number">3598</span>:<span class="number">220992</span>] 使用hello更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">54.618380</span>+<span class="number">0800</span> ZSTest[<span class="number">3598</span>:<span class="number">220992</span>] 使用world更新testLabel的值 </span><br></pre></td></tr></table></figure>



<h2 id="3-信号合并：combineLatest、reduce、merge、zipWith"><a href="#3-信号合并：combineLatest、reduce、merge、zipWith" class="headerlink" title="3.信号合并：combineLatest、reduce、merge、zipWith"></a>3.信号合并：combineLatest、reduce、merge、zipWith</h2><p>为了便于测试，这里先创建两个RACSubject类型的信号用于测试，此类信号只有发送信号sendNext方法执行时，订阅者才会执行nextBlock里的内容;</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSubject *signalOne = [RACSubject subject];</span><br><span class="line">[signalOne subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号one：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSubject *signalTwo = [RACSubject subject];</span><br><span class="line">[signalTwo subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号Two：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="3-1、combineLatest：合并信号"><a href="#3-1、combineLatest：合并信号" class="headerlink" title="3.1、combineLatest：合并信号"></a>3.1、combineLatest：合并信号</h3><p>合并信号的效果就是，这多个信号都至少有过一次订阅信号sendNext的操作，才会触发合并的信号。下面的测试如果只有signalOne执行sendNext方法，那么combineLatest后的信号不会被触发。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[signalOne,signalTwo]] subscribeNext:^(RACTuple * _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//解元组：合并信号得到的是一个元组,里面存放的是两个信号发送的消息</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *str1,<span class="built_in">NSString</span> *str2) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;combineLatest:str1-%@,str2-%@&quot;</span>,str1,str2);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOne sendNext:<span class="string">@&quot;1&quot;</span>];</span><br><span class="line">[signalTwo sendNext:<span class="string">@&quot;2”];</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">53.198724</span>+<span class="number">0800</span> ZSTest[<span class="number">2172</span>:<span class="number">143774</span>] 订阅信号one：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">53.199673</span>+<span class="number">0800</span> ZSTest[<span class="number">2172</span>:<span class="number">143774</span>] 订阅信号Two：<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">53.200075</span>+<span class="number">0800</span> ZSTest[<span class="number">2172</span>:<span class="number">143774</span>] combineLatest:&lt;RACTuple: <span class="number">0x60000000d9a0</span>&gt; (</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="3-2、reduce：聚合信号"><a href="#3-2、reduce：聚合信号" class="headerlink" title="3.2、reduce：聚合信号"></a>3.2、reduce：聚合信号</h3><p>combineLatest合并后的信号订阅后，得到的是一个元组(包含每个被合并信号的新值)。然而在开发中，我们往往需要检测多个信号合并后的效果(比如用户名和密码信号有效时，登录按钮才可以点击)，这里就用到了reduce来实现信号聚合。<br>reduce聚合操作中的block参数个数随合并信号的数量而定，有多少个信号被合并，blcok中的参数就有多少个。这些参数一一对应被合并的信号，是它们对应的新值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[signalOne,signalTwo] reduce:^<span class="type">id</span>(<span class="built_in">NSString</span> *strOne,<span class="built_in">NSString</span> *strTwo)&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@-%@&quot;</span>,strOne,strTwo];</span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;combineLatest-reduce：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signalOne sendNext:<span class="string">@&quot;1&quot;</span>];</span><br><span class="line">[signalTwo sendNext:<span class="string">@&quot;2&quot;</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">08.977580</span>+<span class="number">0800</span> ZSTest[<span class="number">2288</span>:<span class="number">149816</span>] 订阅信号one：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">08.978566</span>+<span class="number">0800</span> ZSTest[<span class="number">2288</span>:<span class="number">149816</span>] 订阅信号Two：<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">08.979587</span>+<span class="number">0800</span> ZSTest[<span class="number">2288</span>:<span class="number">149816</span>] combineLatest-reduce：<span class="number">1</span><span class="number">-2</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3、merge：合并信号"><a href="#3-3、merge：合并信号" class="headerlink" title="3.3、merge：合并信号"></a>3.3、merge：合并信号</h3><p>当合并后的信号被订阅时，就会订阅里面所有的信号<br>测试1：将多个信号合并之后，当其中任何一个信号发送消息时，都能被监测到。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSignal *mergeSignal = [signalOne merge:signalTwo];</span><br><span class="line">[mergeSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;mergeSignal：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//只调用其中一个信号,就会触发merge合并的信号</span></span><br><span class="line">[signalOne sendNext:<span class="string">@&quot;测试信号1&quot;</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">34.342899</span>+<span class="number">0800</span> ZSTest[<span class="number">2577</span>:<span class="number">160009</span>] 订阅信号one：测试信号<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">34.343124</span>+<span class="number">0800</span> ZSTest[<span class="number">2577</span>:<span class="number">160009</span>] mergeSignal：测试信号<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>测试2：当合并后的信号被订阅时，就会订阅里面所有的信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signal1&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signal2&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *mergeSignals = [signal1 merge:signal2];</span><br><span class="line">    [mergeSignals subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;mergeSignals：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">29.623099</span>+<span class="number">0800</span> ZSTest[<span class="number">4444</span>:<span class="number">270816</span>] mergeSignals：signal1</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">29.623721</span>+<span class="number">0800</span> ZSTest[<span class="number">4444</span>:<span class="number">270816</span>] mergeSignals：signal2</span><br></pre></td></tr></table></figure>

<h3 id="3-4、zipWith：压缩信号"><a href="#3-4、zipWith：压缩信号" class="headerlink" title="3.4、zipWith：压缩信号"></a>3.4、zipWith：压缩信号</h3><p>1.zipWith把两个信号压缩成为一个信号。<br>2.只有当两个信号同时发出信号时，两个信号的内容才会被合并为一个元组，触发压缩流的next事件。比如：当一个界面多个请求的时候，要等所有请求完成才更新UI。元组内元素顺序只与压缩信号的顺序有关，与发送信号的顺序无关。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSignal *zipSignal = [signalOne zipWith:signalTwo];</span><br><span class="line">[zipSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//解元组：合并信号得到的是一个元组,里面存放的是两个信号发送的消息</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *str1,<span class="built_in">NSString</span> *str2) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;zipSignal：str1-%@,str2-%@&quot;</span>,str1,str2);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOne sendNext:<span class="string">@&quot;测试zipSignalMsgOne&quot;</span>];</span><br><span class="line">[signalTwo sendNext:<span class="string">@&quot;测试zipSignalMsgTwo&quot;</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">58.989780</span>+<span class="number">0800</span> ZSTest[<span class="number">2926</span>:<span class="number">177798</span>] 订阅信号one：测试zipSignalMsgOne</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">58.990012</span>+<span class="number">0800</span> ZSTest[<span class="number">2926</span>:<span class="number">177798</span>] 订阅信号Two：测试zipSignalMsgTwo</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">58.991056</span>+<span class="number">0800</span> ZSTest[<span class="number">2926</span>:<span class="number">177798</span>] zipSignal：str1-测试zipSignalMsgOne,str2-测试zipSignalMsgTwo</span><br></pre></td></tr></table></figure>



<h2 id="4-信号拼接：concat、then"><a href="#4-信号拼接：concat、then" class="headerlink" title="4.信号拼接：concat、then"></a>4.信号拼接：concat、then</h2><h3 id="4-1、concat"><a href="#4-1、concat" class="headerlink" title="4.1、concat"></a>4.1、concat</h3><p>1.使用concat可以按序拼接多个信号，拼接后的信号按序执行。<br>2.使用concat连接信号后，每个信号无需再单独订阅，其内部会按序自动订阅<br>3.前面的信号必须执行sendCompleted，后面的信号才会被激活</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSignal *signalOne = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signalOne&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">RACSignal *signalTwo = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signalTwo&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalThree = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;signalThree&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">   </span><br><span class="line"><span class="comment">//拼接了三个信号，订阅之后，三个信号依次激活</span></span><br><span class="line">RACSignal *concatSignal = [[signalOne concat:signalThree] concat:signalTwo];</span><br><span class="line">[concatSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;信号被激活:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">47.565105</span>+<span class="number">0800</span> ZSTest[<span class="number">6018</span>:<span class="number">274201</span>] 信号被激活:signalOne</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">47.565403</span>+<span class="number">0800</span> ZSTest[<span class="number">6018</span>:<span class="number">274201</span>] 信号被激活:signalThree</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">47.565609</span>+<span class="number">0800</span> ZSTest[<span class="number">6018</span>:<span class="number">274201</span>] 信号被激活:signalTwo</span><br></pre></td></tr></table></figure>

<h3 id="4-2、then-连接信号"><a href="#4-2、then-连接信号" class="headerlink" title="4.2、then:连接信号"></a>4.2、then:连接信号</h3><p>使用then连接信号，上一个信号完成后，才会连接then返回的信号，所以then连接的上一个信号必须使用sendCompleted，否则后续信号无法执行。<br><strong>then连接的多个信号与concat不同的是：之前的信号会被忽略掉，即订阅信号只会接收到最后一个信号的值</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[[[RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;信号1&quot;</span>);</span><br><span class="line">        [subscriber sendNext:<span class="string">@&quot;发送信号1&quot;</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;] then:^RACSignal *&#123;</span><br><span class="line">        <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;信号2&quot;</span>);</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送信号2&quot;</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;]then:^RACSignal * _Nonnull&#123;</span><br><span class="line">        <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;信号3&quot;</span>);</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送信号3&quot;</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;] subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">        <span class="comment">//只能接收到最后一个信号的值</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.819003</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 信号<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.819762</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 信号<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.820008</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 信号<span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.820139</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 订阅信号：发送信号<span class="number">3</span></span><br></pre></td></tr></table></figure>



<h2 id="5-信号操作时间：timeout、interval、dely"><a href="#5-信号操作时间：timeout、interval、dely" class="headerlink" title="5.信号操作时间：timeout、interval、dely"></a>5.信号操作时间：timeout、interval、dely</h2><h3 id="5-1、interval"><a href="#5-1、interval" class="headerlink" title="5.1、interval"></a>5.1、interval</h3><p>创建定时器信号，每固定时间发送一次信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSignal *intervalSignal = [RACSignal interval:<span class="number">1</span> onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//只知道使用take结束定时器这一种方法，不知道还有没有其他方法</span></span><br><span class="line">[[intervalSignal take:<span class="number">5</span>]subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//订阅定时器信号，启动定时器，只打印5次</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;interval,定时器打印&quot;</span>);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>

<h3 id="5-2、timeout"><a href="#5-2、timeout" class="headerlink" title="5.2、timeout"></a>5.2、timeout</h3><p>可以设置超时操作，让一个信号在规定时间之后自动报错<br><strong>创建信号时不能使用sendCompleted，因为这样的话一旦发送了消息就取消订阅了。</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSignal *timeOutSignal = [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;timeOutSignal发送信号&quot;</span>];</span><br><span class="line">    <span class="comment">//[subscriber sendCompleted];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] timeout:<span class="number">5</span> onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line">   </span><br><span class="line">[timeOutSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timeOutSignal:%@&quot;</span>,x);</span><br><span class="line"> &#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//5秒后执行打印：</span></span><br><span class="line">    <span class="comment">//timeOutSignal:出现Error-Error Domain=RACSignalErrorDomain Code=1 &quot;(null)&quot;</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timeOutSignal:出现Error-%@&quot;</span>,error);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timeOutSignal:complete&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="5-3、delay"><a href="#5-3、delay" class="headerlink" title="5.3、delay"></a>5.3、delay</h3><p>延迟发送sendNext</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSignal *delaySignal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;delaySignal-sendNext&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">   </span><br><span class="line"><span class="comment">//10秒后才收到消息，执行打印</span></span><br><span class="line">[[delaySignal delay:<span class="number">10</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;delaySignal:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>



<h3 id="6-信号取值take、takeLast、takeUntil"><a href="#6-信号取值take、takeLast、takeUntil" class="headerlink" title="6.信号取值take、takeLast、takeUntil"></a>6.信号取值take、takeLast、takeUntil</h3><p>首先创建一个signal来测试这三个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息1&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息2&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息3&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息4&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="6-1、take：从开始共取N次的next值"><a href="#6-1、take：从开始共取N次的next值" class="headerlink" title="6.1、take：从开始共取N次的next值"></a>6.1、take：从开始共取N次的next值</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[signal take:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号:%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">09.865290</span>+<span class="number">0800</span> ZSTest[<span class="number">3835</span>:<span class="number">237999</span>] 订阅信号:发送消息<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">09.865617</span>+<span class="number">0800</span> ZSTest[<span class="number">3835</span>:<span class="number">237999</span>] 订阅信号:发送消息<span class="number">2</span> </span><br></pre></td></tr></table></figure>

<h3 id="6-2、takeLast：从最后共取值N次next的值"><a href="#6-2、takeLast：从最后共取值N次next的值" class="headerlink" title="6.2、takeLast：从最后共取值N次next的值"></a>6.2、takeLast：从最后共取值N次next的值</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[signal takeLast:<span class="number">3</span>]subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">51.343909</span>+<span class="number">0800</span> ZSTest[<span class="number">3933</span>:<span class="number">241042</span>] 订阅信号：发送消息<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">51.344063</span>+<span class="number">0800</span> ZSTest[<span class="number">3933</span>:<span class="number">241042</span>] 订阅信号：发送消息<span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">51.344177</span>+<span class="number">0800</span> ZSTest[<span class="number">3933</span>:<span class="number">241042</span>] 订阅信号：发送消息<span class="number">4</span> </span><br></pre></td></tr></table></figure>

<h3 id="6-3、takeUntil-RACSignal"><a href="#6-3、takeUntil-RACSignal" class="headerlink" title="6.3、takeUntil:(RACSignal *)"></a>6.3、takeUntil:(RACSignal *)</h3><p>使用RACSubject类型的信号来测试，直到某个信号执行完成  ,才获取信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSubject *signalA = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">[signalA subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号A：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">//[RACObserve(self, currentText)发送消息知道signalA信号结束</span></span><br><span class="line">[[RACObserve(<span class="keyword">self</span>, currentText) takeUntil:signalA] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;使用%@更新testLabel的值&quot;</span>,x);</span><br><span class="line">    weakSelf.testLabel.text = x;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;2&quot;</span>;</span><br><span class="line">[signalA sendCompleted];<span class="comment">//信号A结束之后，监听testLabel文本的信号也不在发送消息了</span></span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@&quot;3&quot;</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;代码执行到此行。。。。&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.907925</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用(null)更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.908531</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用<span class="number">0</span>更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.908957</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用<span class="number">1</span>更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.909194</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用<span class="number">2</span>更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.909725</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 代码执行到此行。。。。</span><br></pre></td></tr></table></figure>

<h2 id="7-信号跳过：skip"><a href="#7-信号跳过：skip" class="headerlink" title="7.信号跳过：skip"></a>7.信号跳过：skip</h2><p>使用skip跳过几个信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;第一次发送消息&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;第二次发送消息&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;第三次发送消息&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;第四次发送消息&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[signal skip:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">48</span>:<span class="number">06.479104</span>+<span class="number">0800</span> ZSTest[<span class="number">4284</span>:<span class="number">259095</span>] 第三次发送消息</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">48</span>:<span class="number">06.479376</span>+<span class="number">0800</span> ZSTest[<span class="number">4284</span>:<span class="number">259095</span>] 第四次发送消息</span><br></pre></td></tr></table></figure>



<h2 id="8-信号发送顺序：doNext、doCompleted"><a href="#8-信号发送顺序：doNext、doCompleted" class="headerlink" title="8.信号发送顺序：doNext、doCompleted"></a>8.信号发送顺序：doNext、doCompleted</h2><p>发送信号前与发送信号后操作：doNext、doCompleted<br><strong>doNext</strong>：在订阅者发送消息sendNext之前执行<br><strong>doCompleted</strong>：在订阅者发送完成sendCompleted之后执行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号：1&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[[signal doNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;执行doNext&quot;</span>);</span><br><span class="line">&#125;] doCompleted:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;执行doComplete&quot;</span>);</span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;订阅信号：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">42.881535</span>+<span class="number">0800</span> ZSTest[<span class="number">2656</span>:<span class="number">81106</span>] 执行doNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">42.881841</span>+<span class="number">0800</span> ZSTest[<span class="number">2656</span>:<span class="number">81106</span>] 订阅信号：发送信号：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">42.882583</span>+<span class="number">0800</span> ZSTest[<span class="number">2656</span>:<span class="number">81106</span>] 执行doComplete</span><br></pre></td></tr></table></figure>

<h2 id="9-获取信号中的信号：switchToLatest"><a href="#9-获取信号中的信号：switchToLatest" class="headerlink" title="9.获取信号中的信号：switchToLatest"></a>9.获取信号中的信号：switchToLatest</h2><p>switchToLatest只能用于信号中的信号(否则崩溃)，获取最新发送的信号。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个普通信号</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送信号：1&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个发送信号的信号，信号的信号</span></span><br><span class="line">RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:signal];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//订阅最近发出的信号</span></span><br><span class="line">[signalOfSignals.switchToLatest subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//控制台打印：switchToLatest打印：发送信号：1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;switchToLatest打印：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>特别说明：<br><strong>可以看出switchToLatest和flattenMap的功能很相似，但是它们有一主要区别：</strong></p>
<h2 id="10-信号错误重试：retry"><a href="#10-信号错误重试：retry" class="headerlink" title="10.信号错误重试：retry"></a>10.信号错误重试：retry</h2><p>retry：只要失败就重新执行信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> signalANum = <span class="number">0</span>;</span><br><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (signalANum == <span class="number">5</span>) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@&quot;signalANum is 5&quot;</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;signalANum错误！！!&quot;</span>);</span><br><span class="line">        [subscriber sendError:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    signalANum++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">  </span><br><span class="line">[[signalA retry] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;StringA-Next：%@&quot;</span>,x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//特别注意：这里并没有打印</span></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;signalA-Errror&quot;</span>);</span><br><span class="line">&#125;] ;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">38.996888</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.063427</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.064203</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.064567</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.064819</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.065199</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] StringA-Next：signalANum is <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="11-信号节流：throttle"><a href="#11-信号节流：throttle" class="headerlink" title="11.信号节流：throttle"></a>11.信号节流：throttle</h2><p>当某个信号发送比较频繁时，可以使用throttle节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;发送消息11&quot;</span>];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息21&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息22&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息31&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息32&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息33&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">4</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息41&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息42&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息43&quot;</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;发送消息44&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;    </span><br><span class="line">&#125;] throttle:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Next:%@&quot;</span>,x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">48.411464</span>+<span class="number">0800</span> ZSTest[<span class="number">2063</span>:<span class="number">62521</span>] Next:发送消息<span class="number">11</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">52.426162</span>+<span class="number">0800</span> ZSTest[<span class="number">2063</span>:<span class="number">62521</span>] Next:发送消息<span class="number">44</span></span><br></pre></td></tr></table></figure>

<h2 id="12-信号关于线程的操作"><a href="#12-信号关于线程的操作" class="headerlink" title="12.信号关于线程的操作"></a>12.信号关于线程的操作</h2><p><strong>副作用</strong>：关于信号与线程,我们把在创建信号时block中的代码称之为副作用。<br><strong>deliverON</strong>：切换到指定线程中，可用于回到主线中刷新UI,内容传递切换到指定线程中，<br><strong>subscribeOn</strong>：内容传递和副作用都会切换到指定线程中。<br><strong>deliverOnMainThread</strong>：能保证原信号subscribeNext，sendError，sendCompleted都在主线程MainThread中执行。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试1：系统并行队列中异步执行,未使用deliverON切换线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;测试1-endNext&quot;</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试1-当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试1-Next:%@&quot;</span>,x);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试1-Next当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;) ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//测试2：系统并行队列中异步执行,使用deliverON切换线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;测试2-endNext&quot;</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试2-当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试2-Next:%@&quot;</span>,x);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试2-Next当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;) ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//测试3：系统并行队列中异步执行,使用subscribeOn切换线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@&quot;测试3-sendNext&quot;</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试3-sendNext当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;] subscribeOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试3-Next:%@&quot;</span>,x);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;测试3-Next当前线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;) ;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.025872</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">1</span>-Next:测试<span class="number">1</span>-endNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.026152</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">1</span>-Next当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046e640</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.026746</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">1</span>-sendNext当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046e640</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.027784</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">2</span>-sendNext当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046e640</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.073294</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">2</span>-Next:测试<span class="number">2</span>-sendNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.073890</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">2</span>-Next当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006a280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.074181</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">3</span>-Next:测试<span class="number">3</span>-sendNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.074511</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">3</span>-Next当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006a280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.074646</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">3</span>-sendNext当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006a280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>分析：<br><strong>测试1：未切换线程，发送消息与接收消息都在异步线程中</strong><br><strong>测试2：使用deliverON，发送消息还在原来的线程，但是接收消息切换到主线程。</strong><br><strong>测试2：使用subscribeON，发送消息和接收消息都被切换到了主线程中执行。</strong></p>
<h1 id="四、RAC常用的处理事件响应的方法"><a href="#四、RAC常用的处理事件响应的方法" class="headerlink" title="四、RAC常用的处理事件响应的方法"></a>四、RAC常用的处理事件响应的方法</h1><h2 id="1-代替代理的使用"><a href="#1-代替代理的使用" class="headerlink" title="1.代替代理的使用"></a>1.代替代理的使用</h2><p>基础篇里已经有一种使用RACSubject替换代理的方法，这里是另一种形式的替换。在视图控制中添加自定义视图CustomView，其上有一按钮testBtn添加了响应方法testBtnClick:。此时可以使用RAC在不使用代理的情况下，在视图控制中监听自定义视图中按钮的点击:<br><strong>关键方法：rac_signalForSelector</strong><br>使用说明：<br>1.通过rac_signalForSelector方法，以按钮响应方法为参数，得到一个信号。<br>2.订阅信号，在按钮点击时会发出信号。经过测试，即使testBtnClick方法没有在自定义视图的.h文件中声明，执行也是正常的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[_customView  rac_signalForSelector:<span class="keyword">@selector</span>(testBtnClick:)] subscribeNext:^(RACTuple * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;testBtn点击了。。。&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="2-代替按钮等控制视图的响应事件"><a href="#2-代替按钮等控制视图的响应事件" class="headerlink" title="2.代替按钮等控制视图的响应事件"></a>2.代替按钮等控制视图的响应事件</h2><p>创建一个类似按钮的响应控件，我们可以不必再为其添加响应方法。使用RAC可以将按钮点击事件转化为信号，点击按钮会发送信号，执行订阅方法。<br><strong>关键方法：rac_signalForControlEvents</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[testBtn rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(__kindof <span class="built_in">UIControl</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;testBtn点击了。。。&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="3-代替KVO，监听对象属性变化"><a href="#3-代替KVO，监听对象属性变化" class="headerlink" title="3.代替KVO，监听对象属性变化"></a>3.代替KVO，监听对象属性变化</h2><p><strong>关键方法：rac_valuesAndChangesForKeyPath</strong><br>使用说明：<br>1.自定义视图_customView属性frame的变化被转化信号，frame发生变化的时候，会发送信号。<br>2.observer可以为nil,但是会报警告。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[_customView rac_valuesAndChangesForKeyPath:<span class="string">@&quot;frame&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> observer: <span class="literal">nil</span>] subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;CustomView的Frame值变化了：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">_customView.frame = <span class="built_in">CGRectZero</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-监听文本输入变化"><a href="#4-监听文本输入变化" class="headerlink" title="4.监听文本输入变化"></a>4.监听文本输入变化</h2><p><strong>关键方法：rac_textSignal</strong><br>UITextField与UITextView输入视图内容的变化，我们也可以采用RAC的方法来监听</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[_testTxtView rac_textSignal] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前文本输入内容：%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="5-代替通知的使用"><a href="#5-代替通知的使用" class="headerlink" title="5.代替通知的使用"></a>5.代替通知的使用</h2><p><strong>关键方法：rac_addObserverForName</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//步骤1： 添加通知</span></span><br><span class="line">[[[<span class="built_in">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class="string">@&quot;SecondVCNotificaitonName&quot;</span> object:<span class="literal">nil</span>] subscribeNext:^(<span class="built_in">NSNotification</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *objectDic = (<span class="built_in">NSDictionary</span> *)x.object;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;获取到通知里的文本：%@&quot;</span>,objectDic[<span class="string">@&quot;text&quot;</span>]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤2：发起通知</span></span><br><span class="line"><span class="comment">//SecondVC中点击按钮，将输入框中的文本封装成字典，将其作为参数发起通知</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)completeBtnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@&quot;SecondVCNotificaitonName&quot;</span> object:@&#123;<span class="string">@&quot;text&quot;</span>:<span class="keyword">self</span>.txtField.text&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-多请求汇总处理"><a href="#6-多请求汇总处理" class="headerlink" title="6.多请求汇总处理"></a>6.多请求汇总处理</h2><p><strong>关键方法：rac_liftSelector：withSignals：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下载任务1</span></span><br><span class="line">RACSignal *downLoad1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&#123;<span class="string">@&quot;data2&quot;</span>:<span class="string">@&quot;value1&quot;</span>&#125;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载任务2</span></span><br><span class="line">RACSignal *downLoad2  = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&#123;<span class="string">@&quot;data2&quot;</span>:<span class="string">@&quot;value2&quot;</span>&#125;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//多信号对应多参数，注意顺序与格式</span></span><br><span class="line">[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(handleAllTasksWithT1:withT2:) withSignals:downLoad1,downLoad2, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//集中处理所有的请求</span></span><br><span class="line">- (<span class="type">void</span>)handleAllTasksWithT1:(<span class="type">id</span>)data1 withT2:(<span class="type">id</span>)data2&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;下载任务全部完成：%@，%@&quot;</span>,data1,data2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、本篇总结"><a href="#五、本篇总结" class="headerlink" title="五、本篇总结"></a>五、本篇总结</h1><p>写到这里，其实RAC还是有好多东西没有在这里涉及，本篇也只是对于它最常用的部分进行了归纳总结，尤其是我对于RAC在MVVM架构中的使用还不太熟练。RAC的学习，这仅仅是一个开始，继续努力吧！</p>
<p>参考链接：<br>1.<a href="http://ios.jobbole.com/86357/">RAC核心元素与信号流</a><br>2.<a href="https://www.jianshu.com/p/a4fefb434652">iOS常用API整理</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发-多Target配置</title>
    <url>/2019/02/20/iOS%E5%BC%80%E5%8F%91-%E5%A4%9ATarget%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>我们在iOS开发中可能会遇到同时开发多个类似项目的情况。这些项目大同小异，有诸多代码可以共用，如果每个项目都分别开发，这在后期的迭代中会十分繁琐。为了解决这个问题，使用多Target开发是一种比较好的选择，本文就这一技术实现进行简要总结。</p>
<span id="more"></span>
<h1 id="一、理解项目中的Porject与Target"><a href="#一、理解项目中的Porject与Target" class="headerlink" title="一、理解项目中的Porject与Target"></a>一、理解项目中的Porject与Target</h1><p>使用Xcode来开发项目，其中的Project是一个整体项目相当于一个仓库，包括了所有的代码和资源文件。而Target相当于一个具体的产品，包含了对于代码，资源文件的具体使用规则和配置。一个Project可以包含多个Target，也就是说通过不同Target我们可以生成不同的APP。</p>
<h1 id="二、多Target开发项目的实践步骤"><a href="#二、多Target开发项目的实践步骤" class="headerlink" title="二、多Target开发项目的实践步骤"></a>二、多Target开发项目的实践步骤</h1><p>使用多Target来创建项目，就以我当前正在开发的亲戚买房APP为例。需求是这样的：亲戚买房是一个为买房人提供砍价服务的APP，APP的用户需要区分为用户，专家和砍价师三个用户群体。所以这里以Customer，Consul，Bargain三个Target来开发应用</p>
<h2 id="1-以QQMF-亲戚买房-为名创建一个新的工程如下"><a href="#1-以QQMF-亲戚买房-为名创建一个新的工程如下" class="headerlink" title="1.以QQMF(亲戚买房)为名创建一个新的工程如下:"></a>1.以QQMF(亲戚买房)为名创建一个新的工程如下:</h2><p><img src="http://upload-images.jianshu.io/upload_images/1244124-72d370487e724419.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 上午11.25.03.png"></p>
<h2 id="2-创建三种Target"><a href="#2-创建三种Target" class="headerlink" title="2.创建三种Target"></a>2.创建三种Target</h2><p>创建新Target的方式有两种：<br>第一种：依次选择File-&gt;New-&gt;Target，然后选择一个模板(通常是Single View App)来创建。只是这样创建的target带有Appdelegate和main等文件，在这里并不会用到这些文件，所以我们采用第二种方式创建。<br>第二种：<br>在Targets中点击已有的Target，右键选择Duplicate可以复制生成一个<strong>copy的新Target，并且在文件目录中生成对应的</strong>copy-Info.plist文件。这样生成的target与被拷贝的target相似度很大，减少了过多的修改。通常为了减少后期的修改，我们也会首先在原有的Target中修改一些配置之后再Duplicate。<br><img src="http://upload-images.jianshu.io/upload_images/1244124-355533856df44b16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 上午11.27.06.png"></p>
<p>执行了Duplicate操作之后的效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-b78642363f7d0a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 上午11.29.38.png"></p>
<h2 id="3-修改Targe和plist文件的名称为自己需要的名称"><a href="#3-修改Targe和plist文件的名称为自己需要的名称" class="headerlink" title="3.修改Targe和plist文件的名称为自己需要的名称"></a>3.修改Targe和plist文件的名称为自己需要的名称</h2><p>在Target里可以直接修改Target的名称，在文件目录下也可以直接修改plist文件的名称。如果我们不想文件结构那么乱，也可以像其他文件一样移动plist文件的位置并重新引用到工程中，如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-ae5e46a7d2c3f927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.35.12.png"><br>特别注意：我们在移动文件的时候可能需要重新引用文件到工程中，此时add文件的时候一定要注意选择Target，如果是共用文件一定要勾选对应的Target，类似AppDelegate这样文件的操作如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-8a3839defed21646.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.29.01.png"></p>
<h2 id="4-修改Xcode左上角的Target名称"><a href="#4-修改Xcode左上角的Target名称" class="headerlink" title="4.修改Xcode左上角的Target名称"></a>4.修改Xcode左上角的Target名称</h2><p>选中Xcode左上角的创建工程时的Target(QQMF)，选择Manage schemes<br><img src="http://upload-images.jianshu.io/upload_images/1244124-63a550909a0a2bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.38.06.png"><br>在如下的schemes中修改Target的名称，这里也可以删除多余的最初的QQMF<br><img src="http://upload-images.jianshu.io/upload_images/1244124-a9d8cd9d9082380d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 上午11.47.18.png"></p>
<p>特别说明：QQMF是我们创建工程自带的Target,其实也可以修改它的名字以供自定义使用，而这里我们是直接删掉了它，这样之后，项目自带的info.plist也是没用的了，也可以删掉。</p>
<h2 id="5-设置Target与plist文件对应"><a href="#5-设置Target与plist文件对应" class="headerlink" title="5.设置Target与plist文件对应"></a>5.设置Target与plist文件对应</h2><p>切换到Target目录下，我们可以在这里删掉用不到的QQMF，选择其中一个Target之后并选择general，然后可以看到每个Target的右侧都有对应的choose info.plist file选项，点击可以选择与Target对应的plist文件。这也就相当于不同的Target项目对应了不同的plist配置。<br><img src="http://upload-images.jianshu.io/upload_images/1244124-3d5dfd16700ceb2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午2.01.27.png"></p>
<h2 id="6-为每个Target设置Display-Name，Bundle-Identifier等信息"><a href="#6-为每个Target设置Display-Name，Bundle-Identifier等信息" class="headerlink" title="6.为每个Target设置Display Name，Bundle Identifier等信息"></a>6.为每个Target设置Display Name，Bundle Identifier等信息</h2><p>点击Target-&gt;选择General，我们分别设置不同项目的名称和BundleID信息，以及证书等<br><img src="http://upload-images.jianshu.io/upload_images/1244124-3db248a3e49c6a4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午2.28.17.png"></p>
<h2 id="7-同一份代码区分不同Target的操作"><a href="#7-同一份代码区分不同Target的操作" class="headerlink" title="7.同一份代码区分不同Target的操作"></a>7.同一份代码区分不同Target的操作</h2><p>使用多Target是为了共用一部分代码，但是有些共用的文件在不同的Target下是有细微不同的，那么我们在具体实现的时候就需要作出区分。这里解决的方法是针对不同的Target定义宏。<br>首先选择一个Target,如Customer，依次选择Build Settings -&gt;搜索PreprocessorMacros,  在找到PreprocessorMacros之后，我们分别在Debug和Release中设置TargetType&#x3D;1如下图进行设置：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-afb7d7a92379c410.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.45.35.png"></p>
<p>其他的Target也是同样的设置方式，只是要区分TargetType的值，分别是2，3(TargetType及其值都是自定义的)。然后就是在代码中的使用如下图，分别选择Xcode左上角不同的Target运行，查看控制台验证是否成功。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-f24686677a7e4cdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.55.02.png"></p>
<h2 id="8-解决使用Cocoapods的问题"><a href="#8-解决使用Cocoapods的问题" class="headerlink" title="8.解决使用Cocoapods的问题"></a>8.解决使用Cocoapods的问题</h2><p>因为存在多个Target，我们需要区别的设置不同target需要的第三方库，如下图。这里可能出现的问题是如果有很多类似AFNetworking这样的被多个Target需要的类库，我们在删除和增加的时候就会频繁的操作而且会代码冗余。<br><img src="http://upload-images.jianshu.io/upload_images/1244124-f010d430c1b3426b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午7.22.34.png"><br>解决上述问题的比较优雅的做法是如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-9d2efd2a48a3c8f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午7.39.25.png"></p>
<h2 id="三、遇到的问题"><a href="#三、遇到的问题" class="headerlink" title="三、遇到的问题"></a>三、遇到的问题</h2><ol>
<li>问题：invalid token at start of a preprocessor expression<br>原因：这是我在pch文件中判断target类型出现的错误，这句话的大致意思是：在预编译阶段，代码并未运行，无法判断宏定义的值。最后查找到原因是我在上述步骤设置宏定义的时候，手误设置了TargetType&#x3D;&#x3D;1，这本是一句需要执行才能得到结果的代码。所以无法在#if的条件编译中通过。<br>解决：在条件编译中不使用代码运行时才生成的量即可。</li>
</ol>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS高级-MachO文件结构</title>
    <url>/2021/11/03/iOS%E9%AB%98%E7%BA%A7-MachO%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong>主要内容：</strong></p>
<ol>
<li>理解可执行文件</li>
<li>理解<code>Mach-O</code>文件</li>
<li><code>Mach-O</code>文件结构<span id="more"></span></li>
<li><code>Mach Header</code></li>
<li><code>Load Commands</code></li>
<li><code>Data</code></li>
<li>理解大小端模式</li>
<li>理解通用二进制文件</li>
</ol>
<h4 id="一、理解可执行文件"><a href="#一、理解可执行文件" class="headerlink" title="一、理解可执行文件"></a>一、理解可执行文件</h4><h5 id="1-可执行文件"><a href="#1-可执行文件" class="headerlink" title="1.可执行文件"></a>1.可执行文件</h5><ol>
<li><code>进程</code>，其实就是<code>可执行文件</code>在内存中加载得到的结果；</li>
<li><code>可执行文件</code>必须是操作系统可理解的格式，而且不同系统的<code>可执行文件</code>的格式也是不同的；</li>
</ol>
<h5 id="2-不同平台的可执行文件"><a href="#2-不同平台的可执行文件" class="headerlink" title="2.不同平台的可执行文件"></a>2.不同平台的可执行文件</h5><ul>
<li><code>Linux：ELF</code>文件</li>
<li><code>Windows</code>：<code>PE32／PE32+</code>文件</li>
<li><code>OS和iOS</code>：<code>Mach-O(Mach Object)</code>文件</li>
</ul>
<h4 id="二、理解Mach-O文件"><a href="#二、理解Mach-O文件" class="headerlink" title="二、理解Mach-O文件"></a>二、理解Mach-O文件</h4><p>作为<code>iOS</code>，<code>iPadOS</code>、<code>macOS</code>平台的可执行文件格式，<code>Mach-O</code>文件涉及App启动运行、<code>bitcode</code>分析、 <code>crash</code>符号化等诸多多个功能：</p>
<h5 id="1-Mach-O文件"><a href="#1-Mach-O文件" class="headerlink" title="1. Mach-O文件"></a>1. Mach-O文件</h5><ol>
<li><code>Mach-O</code>文件是<code>iOS</code>，<code>iPadOS</code>、<code>macOS</code>平台的可执行文件格式。对应系统通过应用二进制接口(<code>application binary interface</code>，缩写为<code>ABI</code>)来运行该格式的文件；</li>
<li><code>Mach-O</code>格式用来替代<code>BSD</code>系统中的<code>a.out</code>格式，保存了在编译和链接过程中产生的<code>机器代码和数据</code>，从而为静态链接和动态链接的代码提供单一文件格式。</li>
<li><code>Mach-O</code>提供了更强的扩展性，以及更快的符号表信息访问速度；</li>
</ol>
<h5 id="2-Mach-O格式的常见文件类型"><a href="#2-Mach-O格式的常见文件类型" class="headerlink" title="2.Mach-O格式的常见文件类型"></a>2.Mach-O格式的常见文件类型</h5><ol>
<li><code>Executable</code>：可执行文件(<code>.out</code> <code>.o</code>)；</li>
<li><code>Dylib</code>：动态链接库；</li>
<li><code>Bundle</code>：不能被链接，只能在运行时使用<code>dlopen()</code>加载；</li>
<li><code>Image</code>：包含<code>Executable</code>、<code>Dylib</code>和<code>Bundle</code>；</li>
<li><code>Framework</code>：包含<code>Dylib</code>、资源文件和头文件的文件夹；</li>
</ol>
<h4 id="三、Mach-O文件结构"><a href="#三、Mach-O文件结构" class="headerlink" title="三、Mach-O文件结构"></a>三、Mach-O文件结构</h4><h5 id="1-查看Mach-O的两种方法"><a href="#1-查看Mach-O的两种方法" class="headerlink" title="1.查看Mach-O的两种方法"></a>1.查看Mach-O的两种方法</h5><ol>
<li>使用<code>MachOView</code>软件，可直接查看<code>MachO</code>文件的结构；</li>
<li>使用终端命令<code>objdump</code>；</li>
</ol>
<h5 id="2-查看Mach-O文件结构"><a href="#2-查看Mach-O文件结构" class="headerlink" title="2.查看Mach-O文件结构"></a>2.查看Mach-O文件结构</h5><p>使用<code>MachOView</code>查看<code>Mach-O</code>，效果如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a8b3e13b48e48bb8896b325d4b2bf82~tplv-k3u1fbpfcp-watermark.image" alt="MachO-文件结构2.png"></p>
<p><code>Mach-O</code>文件中包含三个主要的部分：</p>
<ol>
<li><code>Header</code>：头部，描述<code>CPU</code>类型、文件类型、加载命令的条数大小等信息；</li>
<li><code>Load Commands</code>：加载命令，其条数和大小已经在<code>header</code>中被提供；</li>
<li><code>Data</code>：数据段；</li>
</ol>
<p>其他的信息还有：</p>
<ol>
<li><code>Dynamic Loader Info</code>：动态库加载信息</li>
<li><code>Function Starts</code>：入口函数</li>
<li><code>Symbol Table</code>：符号表</li>
<li><code>Dynamic Symbol Table</code>： 动态库符号表</li>
<li><code>String Table</code>：字符串表</li>
</ol>
<h4 id="四、Mach-Header-可执行文件头"><a href="#四、Mach-Header-可执行文件头" class="headerlink" title="四、Mach Header(可执行文件头)"></a>四、Mach Header(可执行文件头)</h4><h5 id="1-功能总结"><a href="#1-功能总结" class="headerlink" title="1.功能总结"></a>1.功能总结</h5><ol>
<li><code>Header</code>是链接器加载时最先读取的内容，因为它决定了一些<code>基础架构</code>、<code>系统类型</code>等信息；</li>
<li><code>Header</code>包含整个<code>Mach-O</code>文件的关键信息，如<code>CPU类型</code>、<code>文件类型</code>、<code>加载命令的条数大小</code>等信息，使得系统能够迅速定位<code>Mach-O</code>文件的运行环境；</li>
<li><code>Header</code>针对<code>32</code>位和<code>64</code>位架构的<code>CPU</code>，分别对应<code>mach_header</code>和<code>mach_header_64</code>的结构体；</li>
</ol>
<h5 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h5><p><code>Header</code>被定义在<code>loader.h</code>文件中，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mach_header_64</span> &#123;</span><br><span class="line">    uint32_t    magic;          <span class="comment">// 32位或者64位，系统内核用来判断是否是mach-o格式</span></span><br><span class="line">    cpu_type_t  cputype;        <span class="comment">// CPU架构类型，比如ARM</span></span><br><span class="line">    cpu_subtype_t   cpusubtype; <span class="comment">// CPU的具体类型，例如arm64、armv7</span></span><br><span class="line">    uint32_t    filetype;       <span class="comment">// mach-o文件类型, 可执行文件、目标文件或者静态库和动态库</span></span><br><span class="line">    uint32_t    ncmds;          <span class="comment">// LoadCommands加载命令的条数（加载命令紧跟header之后）</span></span><br><span class="line">    uint32_t    sizeofcmds;     <span class="comment">// 全部LoadCommands加载命令的大小</span></span><br><span class="line">    uint32_t    flags;          <span class="comment">// 标志位标识二进制文件支持的功能，主要是和系统加载、链接有关</span></span><br><span class="line">    uint32_t    reserved;       <span class="comment">// 保留字段(相比于32位多出的字段)</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>由于<code>可执行文件</code>、<code>目标文件</code>或者<code>静态库</code>和<code>动态库</code>等都是<code>Mach-O</code>格式，所以才需要<code>filetype</code>来说明。常用的文件类型有以下几种：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#define <span class="type">MH_OBJECT</span>   <span class="number">0x1</span>     <span class="comment">/* 目标文件*/</span></span><br><span class="line">#define <span class="type">MH_EXECUTE</span>  <span class="number">0x2</span>     <span class="comment">/* 可执行文件*/</span></span><br><span class="line">#define <span class="type">MH_DYLIB</span>    <span class="number">0x6</span>     <span class="comment">/* 动态库*/</span></span><br><span class="line">#define <span class="type">MH_DYLINKER</span> <span class="number">0x7</span>     <span class="comment">/* 动态链接器*/</span></span><br><span class="line">#define <span class="type">MH_DSYM</span>     <span class="number">0xa</span>     <span class="comment">/* 存储二进制文件符号信息，用于debug分析*/</span></span><br></pre></td></tr></table></figure>

<h5 id="3-MachOView演示"><a href="#3-MachOView演示" class="headerlink" title="3.MachOView演示"></a>3.MachOView演示</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaa795545a904c93a9b0d1cc3e7061d3~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="五、Load-Commands"><a href="#五、Load-Commands" class="headerlink" title="五、Load Commands"></a>五、Load Commands</h4><h5 id="1-功能总结-1"><a href="#1-功能总结-1" class="headerlink" title="1.功能总结"></a>1.功能总结</h5><ol>
<li><code>Load Commands</code>是加载命令的列表，用于描述<code>Data</code>在二进制文件和虚拟内存中的布局信息；</li>
<li><code>Load Commands</code>记录了很多信息，例如动态链接器的位置、程序的入口、依赖库的信息、代码的位置、符号表的位置等；</li>
<li><code>Load commands</code>由内核定义，不同版本的<code>command</code>数量不同，其条数和大小记录在<code>header</code>中；</li>
<li><code>Load commands</code>的<code>type</code>是以<code>LC_</code>为前缀常量，譬如<code>LC_SEGMENT</code>、<code>LC_SYMTAB</code>等；</li>
</ol>
<h5 id="2-代码分析"><a href="#2-代码分析" class="headerlink" title="2..代码分析"></a>2..代码分析</h5><p><code>Load Command</code>被定义在<code>loader.h</code>文件中，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">load_command</span> &#123;</span><br><span class="line">    uint32_t cmd;       <span class="comment">/* 加载命令的类型 */</span></span><br><span class="line">    uint32_t cmdsize;   <span class="comment">/* 加载命令的大小 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个<code>Load Command</code>都有独立的结构，但是所有结构的前两个字段是固定的。比如<code>LC_SEGMENT_64</code>，这是一个读取<code>segment</code>、<code>section</code>有关命令，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_command_64</span> &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    uint32_t    cmd;          <span class="comment">// 表示加载命令类型</span></span><br><span class="line">    uint32_t    cmdsize;      <span class="comment">// 表示加载命令大小（还包括了紧跟其后的nsects个section的大小）</span></span><br><span class="line">    char        segname[<span class="number">16</span>];  <span class="comment">// 16个字节的段名字</span></span><br><span class="line">    uint64_t    vmaddr;       <span class="comment">// 段的虚拟内存起始地址</span></span><br><span class="line">    uint64_t    vmsize;       <span class="comment">// 段的虚拟内存大小</span></span><br><span class="line">    uint64_t    fileoff;      <span class="comment">// 段在文件中的偏移量</span></span><br><span class="line">    uint64_t    filesize;     <span class="comment">// 段在文件中的大小</span></span><br><span class="line">    vm_prot_t   maxprot;      <span class="comment">// 段页面所需要的最高内存保护（4 = r，2 = w，1 = x）</span></span><br><span class="line">    vm_prot_t   initprot;     <span class="comment">// 段页面初始的内存保护</span></span><br><span class="line">    uint32_t    nsects;       <span class="comment">// 段中section数量</span></span><br><span class="line">    uint32_t    flags;        <span class="comment">// 标志位</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="六、Data"><a href="#六、Data" class="headerlink" title="六、Data"></a>六、Data</h4><h5 id="1-功能总结-2"><a href="#1-功能总结-2" class="headerlink" title="1.功能总结"></a>1.功能总结</h5><ol>
<li><code>Data</code>中存储了实际的数据与代码，主要包含方法、符号表、动态符号表、动态库加载信息(重定向、符号绑定等)等；</li>
<li><code>Data</code>中的排布完全按照<code>Load Command</code>中的描述；</li>
<li><code>Data</code>由<code>Segment</code>（段）和 <code>Section</code> （节）的方式来组成，通常，<code>Data</code>拥有多个<code>segment</code>，每个<code>segment</code>可以有零到多个<code>section</code>节；</li>
<li>不同的<code>segment</code>都有一段<code>虚拟地址</code>映射到进程的地址空间；</li>
</ol>
<p>几乎所有的<code>Mach-O</code>文件都包含<code>3</code>个<code>segment</code></p>
<ol>
<li><strong>__TEXT</strong>：代码段，只读可执行，存储<code>函数的二进制代码(__text)</code>，<code>常量字符串(__cstring)</code>，<code>OC的类/方法名</code>等信息</li>
<li><strong>__DATA</strong>：数据段， 可读可写，存储<code>OC的字符串(__cfstring)</code>，以及<code>运行时的元数据：class/protocol/method</code>，以及全局变量，静态变量等；</li>
<li><strong>__LINKEDIT</strong>：只读，存储启动<code>App</code>需要的信息，如 <code>bind &amp; rebase 的地址</code>、函数的名称和地址等信息​；</li>
</ol>
<h5 id="2-源码分析-1"><a href="#2-源码分析-1" class="headerlink" title="2.源码分析"></a>2.源码分析</h5><p>在<code>Data</code>区中，<code>Section</code>占了很大的比例，而且在<code>Mach-O</code>中集中体现在<code>__TEXT</code>和<code>__DATA</code>两段里。</p>
<p><code>Section</code>被定义在<code>loader.h</code>文件中，具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">section_64</span> &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    char        sectname[<span class="number">16</span>];   <span class="comment">// 当前section的名称</span></span><br><span class="line">    char        segname[<span class="number">16</span>];    <span class="comment">// section所在的segment名称</span></span><br><span class="line">    uint64_t    addr;       <span class="comment">// 内存中起始位置</span></span><br><span class="line">    uint64_t    size;       <span class="comment">// section大小</span></span><br><span class="line">    uint32_t    offset;     <span class="comment">// section的文件偏移</span></span><br><span class="line">    uint32_t    align;    <span class="comment">// 字节大小对齐</span></span><br><span class="line">    uint32_t    reloff;     <span class="comment">// 重定位入口的文件偏移</span></span><br><span class="line">    uint32_t    nreloc;   <span class="comment">// 重定位入口数量</span></span><br><span class="line">    uint32_t    flags;      <span class="comment">// 标志，section的类型和属性</span></span><br><span class="line">    uint32_t    reserved1;  <span class="comment">// 保留（用于偏移量或索引）</span></span><br><span class="line">    uint32_t    reserved2;  <span class="comment">// 保留（用于count或sizeof）</span></span><br><span class="line">    uint32_t    reserved3;  <span class="comment">// 保留</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="七、理解大小端模式"><a href="#七、理解大小端模式" class="headerlink" title="七、理解大小端模式"></a>七、理解大小端模式</h4><p>分析<code>Mach-O文</code>件时，经常会看到内存地址相关的内容，这里就涉及到了大小端模式的概念；</p>
<ol>
<li>小端模式：数据的低字节，保存在内存的低地址；</li>
<li>大端模式：数据的低字节，保存在内存的高地址；</li>
</ol>
<p><code>iOS</code>设备的处理器是基于<code>ARM</code>架构的，默认是采用<strong>小端模式</strong>(低字节放低位）读取数据的，而网络和蓝牙传输数据通常是用的<strong>大端模式</strong>(低字节放高位)：</p>
<p>下面以<code>unsigned int value = 0x12345678</code>为例，分别看看在两种字节序下其存储情况，我们可以用<code>unsigned char buf[4]</code>来表示<code>value</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Little</span><span class="operator">-</span><span class="type">Endian</span>: 低地址存放低位，如下：</span><br><span class="line">低地址 <span class="operator">------------------&gt;</span> 高地址</span><br><span class="line"><span class="number">0x78</span>    <span class="number">0x56</span>    <span class="number">0x34</span>    <span class="number">0x12</span></span><br><span class="line"></span><br><span class="line"><span class="type">Big</span><span class="operator">-</span><span class="type">Endian</span>: 低地址存放高位，如下：</span><br><span class="line">低地址 <span class="operator">-----------------&gt;</span> 高地址</span><br><span class="line"><span class="number">0x12</span>    <span class="number">0x34</span>    <span class="number">0x56</span>    <span class="number">0x78</span></span><br></pre></td></tr></table></figure>

<p>内存地址</p>
<p>小端模式存放内容</p>
<p>大端模式存放内容</p>
<p>0x4000</p>
<p>0x78</p>
<p>0x12</p>
<p>0x4001</p>
<p>0x56</p>
<p>0x34</p>
<p>0x4002</p>
<p>0x34</p>
<p>0x56</p>
<p>0x4003</p>
<p>0x12</p>
<p>0x78</p>
<h4 id="八、理解通用二进制文件"><a href="#八、理解通用二进制文件" class="headerlink" title="八、理解通用二进制文件"></a>八、理解通用二进制文件</h4><h5 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h5><ol>
<li>通用二进制文件的存储结构，是将多种架构的<code>Mach-O</code>文件打包在一起，<code>CPU</code>在读取该二进制文件时可以自动检测并选用合适的架构；</li>
<li>通用二进制文件会同时存储多种架构，所以比单一架构的二进制文件大很多，会占用大量的磁盘空间。但由于系统运行时会自动选择最合适的，不相关的架构代码，不会占用内存空间，所以执行效率提高了；</li>
<li>通用二进制格式也被称为胖二进制格式；</li>
</ol>
<h5 id="2-通用二进制格式分析"><a href="#2-通用二进制格式分析" class="headerlink" title="2.通用二进制格式分析"></a>2.通用二进制格式分析</h5><p>通用二进制格式的定义在<code>&lt;mach-o/fat.h&gt;</code>中:</p>
<ol>
<li>下载<a href="https://opensource.apple.com/tarballs/xnu/">xnu</a>后，依次在 <code>xnu -&gt; EXTERNAL_HEADERS -&gt;mach-o</code>中找到该文件。</li>
<li>通用二进制文件有两个重要结构体：<code>fat_header</code>、<code>fat_arch</code>；</li>
</ol>
<p>两个结构体的定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> - magic：可以让系统内核读取该文件时知道是通用二进制文件</span></span><br><span class="line"><span class="comment"> - nfat_arch：表明下面有多个fat_arch结构体，即通用二进制文件包含多少个Mach-O</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fat_header</span> &#123;</span><br><span class="line">    uint32_t    magic;      <span class="comment">/* FAT_MAGIC */</span></span><br><span class="line">    uint32_t    nfat_arch;  <span class="comment">/* number of structs that follow */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> fat_arch是描述Mach-O</span></span><br><span class="line"><span class="comment"> - cputype 和 cpusubtype：说明Mach-O适用的平台</span></span><br><span class="line"><span class="comment"> - offset（偏移）、size（大小）、align（页对齐）描述了Mach-O二进制位于通用二进制文件的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fat_arch</span> &#123;</span><br><span class="line">    cpu_type_t  cputype;    <span class="comment">/* cpu specifier (int) */</span></span><br><span class="line">    cpu_subtype_t   cpusubtype; <span class="comment">/* machine specifier (int) */</span></span><br><span class="line">    uint32_t    offset;     <span class="comment">/* file offset to this object file */</span></span><br><span class="line">    uint32_t    size;       <span class="comment">/* size of this object file */</span></span><br><span class="line">    uint32_t    align;      <span class="comment">/* alignment as a power of 2 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a href="https://opensource.apple.com/tarballs/xnu/">xnu</a></li>
<li><a href="https://opensource.apple.com/source/xnu/xnu-4903.221.2/EXTERNAL_HEADERS/mach-o/">Mach-O官方源码</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS高级</category>
      </categories>
      <tags>
        <tag>Mach-O</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS高级-MachO符号分类</title>
    <url>/2021/11/06/iOS%E9%AB%98%E7%BA%A7-MachO%E7%AC%A6%E5%8F%B7%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p><strong>主要内容：</strong></p>
<ol>
<li>理解<code>Symbol</code>的概念</li>
<li>查看<code>Symbol</code>的方式</li>
<li>符号表<code>Symbol Table</code><span id="more"></span></li>
<li>重定位符号</li>
<li>全局符号与本地符号</li>
<li>导出符号</li>
<li>间接符号</li>
<li>弱符号</li>
<li>未初始化的全局符号</li>
<li>重新导出符号</li>
<li><code>Swift</code>符号</li>
</ol>
<h4 id="一、理解Symbol的概念"><a href="#一、理解Symbol的概念" class="headerlink" title="一、理解Symbol的概念"></a>一、理解Symbol的概念</h4><p><code>Mahc-O</code>文件中的符号表<code>Symbol Table</code>，在<code>Mach-O</code>的整个链接和运行过程中起着重要作用；</p>
<h5 id="1-符号的概念"><a href="#1-符号的概念" class="headerlink" title="1.符号的概念"></a>1.符号的概念</h5><ol>
<li><code>Symbol</code>：包含了名称(<code>String</code>)和类型等信息的数据结构，对应的是一个函数或者数据的地址；</li>
<li><code>Symbol Table</code>：保存符号信息的表；</li>
<li><code>String Table</code>：保存符号名称的表；</li>
<li><code>Indirect Symbol Table</code>：间接符号表，保存使用的外部符号，更准确一点就是使用的外部动态库的符号，它是<code>Symbol Table</code>的子集；</li>
</ol>
<h5 id="2-符号与链接"><a href="#2-符号与链接" class="headerlink" title="2.符号与链接"></a>2.符号与链接</h5><p>链接的作用：链接器把多个<code>.m文件</code>编译产生的<code>.o</code>文件和(<code>dylib</code>、<code>a</code>、<code>tbd</code>）文件，合成一个<code>Mach-O</code>格式的可执行文件；</p>
<p>链接阶段的重要目的：符号解析和重定位</p>
<ul>
<li>符号解析：将每个<code>符号</code>引用和对应的<code>符号</code>定义关联起来；</li>
<li>重定位：将每个<code>符号</code>定义与一个<code>内存位置</code>关联起来，然后修改所有对这些符号的引用；</li>
</ul>
<p>举例：二进制文件<code>main</code>中用到了二进制<code>A</code>中的函数<code>a</code>，则<code>main</code>就可以读取二进制<code>A</code>维护的符号表，进而在<code>A</code>找到函数<code>a</code>的实现；</p>
<h5 id="3-符号与调试"><a href="#3-符号与调试" class="headerlink" title="3.符号与调试"></a>3.符号与调试</h5><p><code>Xcode</code>调试时，需要通过符号表将<code>符号</code>和<code>源文件</code>映射起来，而如果将<code>调试符号</code>裁剪掉(如图，将<code>Deployment Postprocessing</code>设置为<code>YES</code>)，就会使得断点失效。<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_deployment_postprocessing.png" width="600" align=center/></p>
<p>注意：<code>Release</code>模式下是可以裁剪掉符号的，因为<code>release</code>模式下默认有<code>dsym</code>文件，调试器仍然可以从中获取到信息正常工作；</p>
<h4 id="二、查看Symbol的方式"><a href="#二、查看Symbol的方式" class="headerlink" title="二、查看Symbol的方式"></a>二、查看Symbol的方式</h4><h5 id="1-使用MachOView查看"><a href="#1-使用MachOView查看" class="headerlink" title="1.使用MachOView查看"></a>1.使用MachOView查看</h5><p>使用<code>MachOView</code>查看<code>Mach-O</code>文件，效果如下：</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_view_macho1.png" width="600" align=center/>

<h5 id="2-使用objdump命令查看"><a href="#2-使用objdump命令查看" class="headerlink" title="2.使用objdump命令查看"></a>2.使用objdump命令查看</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看重定位符号表</span></span><br><span class="line">objdump <span class="operator">-</span>—macho <span class="operator">-</span>—reloc .o文件</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看符号表</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>syms .o文件或<span class="type">MachO文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看导出符号</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>exports<span class="operator">-</span>trie .o文件或<span class="type">Mach</span><span class="operator">-</span><span class="type">O文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看间接符号表</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">indirect</span><span class="operator">-</span>symbols .o文件或<span class="type">Mach</span><span class="operator">-</span><span class="type">O文件</span></span><br></pre></td></tr></table></figure>


<h4 id="三、符号表Symbol-Table"><a href="#三、符号表Symbol-Table" class="headerlink" title="三、符号表Symbol Table"></a>三、符号表Symbol Table</h4><h5 id="1-符号表在Mach-O中的位置"><a href="#1-符号表在Mach-O中的位置" class="headerlink" title="1.符号表在Mach-O中的位置"></a>1.符号表在Mach-O中的位置</h5><p>下面的图，能够更加直观的展示<code>符号表</code>在<code>Mach-O</code>文件中的位置：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_view_macho2.png" width="600" align=center/></p>
<p>这里需要注意两个重要的<code>Load Commands</code>：</p>
<ul>
<li><code>LC_SYMTAB</code> ：描述当前<code>Mach-O</code>中的符号表信息；</li>
<li><code>LC_DYSYMTAB</code> ：描述动态连接器使用其他符号表的信息；</li>
</ul>
<p>其中<code>LC_SYMTAB</code>对应的数据结构<code>symtab_command</code>，其源码如下：<br> <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">symtab_command</span> &#123;</span><br><span class="line">    <span class="comment">// 共有属性。指明当前描述的加载命令，当前被设置为LC_SYMTAB</span></span><br><span class="line">    uint32_t cmd ;</span><br><span class="line">    <span class="comment">// 共有属性。指明加载命令的大小，当前被设置为sizeof(symtab_command)</span></span><br><span class="line">    uint32_t cmdsize;</span><br><span class="line">    <span class="comment">// 表示从文件开始到symbol table所在位置的偏移量。symbol table用[nlist]来表示</span></span><br><span class="line">    uint32_t symoff;</span><br><span class="line">    <span class="comment">// 符号表内符号的数量</span></span><br><span class="line">    uint32_t nsyms;</span><br><span class="line">    <span class="comment">// 表示从文件开始到string table所在位置的偏移量。</span></span><br><span class="line">    uint32_t stroff;</span><br><span class="line">    <span class="comment">// 表示string table大小(以byteカ单位)</span></span><br><span class="line">    uint32_t strsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>LC_SYMTAB</code>的使用场景：</p>
<ol>
<li>静态链接器、动态链接器链接文件时；</li>
<li>调试器寻找调试信息时；</li>
</ol>
<h5 id="2-符号表的源码分析"><a href="#2-符号表的源码分析" class="headerlink" title="2.符号表的源码分析"></a>2.符号表的源码分析</h5><p><code>Symbol Table</code>中存储着符号，而<code>Symbol</code>则是一个数据结构，包含了名称(<code>String</code>)和类型等元数据，符号对应一个函数或者数据的地址，其在代码的定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">nlist_64</span> &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        uint32_t  n_strx; <span class="comment">/* index into the string table */</span></span><br><span class="line">    &#125; n_un;</span><br><span class="line">    uint8_t n_type;        <span class="comment">/* type flag, see below */</span></span><br><span class="line">    uint8_t n_sect;        <span class="comment">/* section number or NO_SECT */</span></span><br><span class="line">    uint16_t n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">    uint64_t n_value;      <span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码中<code>n_strx</code>字段存储的就是符号在<code>String Table</code>的下标，符号表与符号的关系可用下图表示：</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_relation_table_symbol.png" width="600" align=center/>


<h4 id="四、重定位符号"><a href="#四、重定位符号" class="headerlink" title="四、重定位符号"></a>四、重定位符号</h4><p>概念理解：</p>
<ol>
<li>在链接生成<code>Mach-O</code>可执行文件之前，编译生成<code>.o</code>目标文件会对符号进行归类，而其中使用到的外部符号会暂存到重定位符号表中；</li>
<li>等到真正链接生成<code>Mach-O</code>文件时，这些符号会统一存到<code>Symbol Table</code>中；</li>
</ol>
<p>查看重定位符号的命令：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">objdump <span class="operator">-</span>—macho <span class="operator">-</span>—reloc .o目标文件</span><br></pre></td></tr></table></figure>

<p>以下是验证过程：</p>
<h5 id="1-准备测试文件"><a href="#1-准备测试文件" class="headerlink" title="1.准备测试文件"></a>1.准备测试文件</h5><p>创建一个<code>main.m</code>文件，写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">	<span class="type">NSLog</span>(@<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用命令分别生成<code>.o目标文件</code>与<code>Mach-O可执行文件</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span>fmodules <span class="operator">-</span>c main.m <span class="operator">-</span>o main.o   <span class="comment">//得到目标文件</span></span><br><span class="line">xcrun clang main.o <span class="operator">-</span>o main  <span class="comment">//得到Mach-O可执行文件</span></span><br></pre></td></tr></table></figure>
<h5 id="2-对比-Text代码段"><a href="#2-对比-Text代码段" class="headerlink" title="2.对比__Text代码段"></a>2.对比__Text代码段</h5><p>使用<code>objdump</code>命令，分别查看目标文件与可执行文件中的<code>__TEXT</code>段，对比之下会发现：<code>前者</code>的符号调用<code>callq _NSLog</code>是没有地址的。</p>
<p>控制台中显示效果如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_relocation_compare_text.png" width="600" align=center/></p>
<h5 id="3-查看重定位符号表"><a href="#3-查看重定位符号表" class="headerlink" title="3.查看重定位符号表"></a>3.查看重定位符号表</h5><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_relocation_check.png" width="600" align=center/>

<h5 id="4-重定位符号表中的字段说明"><a href="#4-重定位符号表中的字段说明" class="headerlink" title="4.重定位符号表中的字段说明"></a>4.重定位符号表中的字段说明</h5><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_relocation_table_desc.png" width="600" align=center/>


<h4 id="五、全局符号与本地符号"><a href="#五、全局符号与本地符号" class="headerlink" title="五、全局符号与本地符号"></a>五、全局符号与本地符号</h4><p>概念理解：</p>
<ul>
<li>全局符号：整个工程可见的符号；比如定义一个全局变量，所有文件都能访问到；</li>
<li>本地符号：只有当前文件可访问的符号，比如在当前文件中定义一个<code>static</code>修饰的变量；</li>
</ul>
<p>查看符号的命令：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>syms .o文件或<span class="type">Mach</span><span class="operator">-</span><span class="type">O文件</span></span><br></pre></td></tr></table></figure>

<h5 id="1-验证全局符号与本地符号"><a href="#1-验证全局符号与本地符号" class="headerlink" title="1. 验证全局符号与本地符号"></a>1. 验证全局符号与本地符号</h5><p>创建一个<code>main.m</code>文件，写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int global_init_value <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> int static_init_value <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%d&quot;</span>, static_init_value);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用命令生成可执行文件，并查看符号，效果如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_global_local.png" width="600" align=center/></p>
<p>第二列符号标签的含义：</p>
<ul>
<li><code>l</code>代表本地符号；</li>
<li><code>g</code>代表全局符号；</li>
</ul>
<p>第三列符号标签的含义，按照功能区分：</p>
<ul>
<li><code>f</code>：<code>File</code>，文件；</li>
<li><code>F</code>：<code>Function</code>，方法；</li>
<li><code>O</code>：	<code>Data</code>，数据；</li>
<li><code>d</code>：	<code>Debug</code>，调试符号（链接过程中，可通过<code>OTHER_LDFLAGS = -Xlinker -S</code>参数隐藏)；</li>
<li><code>ABS</code>：	<code>Absolute</code>；</li>
<li><code>COM</code>：	<code>Common</code>；</li>
<li><code>UND</code>：	未定义；</li>
</ul>
<h5 id="2-隐藏全局符号"><a href="#2-隐藏全局符号" class="headerlink" title="2. 隐藏全局符号"></a>2. 隐藏全局符号</h5><p>除了使用<code>static</code>修饰外，还有一种隐藏全局符号的方法，那就是使用<code>__attribute__</code>编译属性；</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">__attribute__((visibility(<span class="string">&quot;default&quot;</span>)))  <span class="comment">//默认</span></span><br><span class="line">__attribute__((visibility(<span class="string">&quot;hideen&quot;</span>)))  <span class="comment">//隐藏</span></span><br></pre></td></tr></table></figure>
<p><code>visibility</code>：用于设置动态链接库中函数的可见性，将变量或函数设置为<code>hidden</code>，则该符号仅在本文件中可见，在其他库中则不可见；</p>
<p>测试使用<code>__attribute__</code>编译属性修改<code>global_init_value</code>变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">int global_init_value __attribute__((visibility(<span class="string">&quot;hidden&quot;</span>))) <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>重新使用命令生成<code>Mach-O可执行文件</code>，并查看符号，效果如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_global_hide.png" width="600" align=center/></p>
<h4 id="六、导入符号和导出符号"><a href="#六、导入符号和导出符号" class="headerlink" title="六、导入符号和导出符号"></a>六、导入符号和导出符号</h4><p>概念理解：</p>
<ol>
<li>当前文件中使用到的<code>外部变量</code>、<code>外部方法</code>等，都属于其所属文件的导出符号；</li>
<li>导出符号一定是全局符号 ，将一个符号声明为全局，也就会默认成为导出符号，可供外界使用；</li>
<li><code>OC</code>中所有的符号都默认是导出符号；</li>
</ol>
<p>以<code>NSLog</code>为例：</p>
<ul>
<li>对于<code>Foundation</code>库来说，<code>NSLog</code>是提供外部使用的导出符号;</li>
<li>对于当前程序来说，<code>NSLog</code>使用的是从<code>Foundation</code>库中导入的符号;</li>
</ul>
<p>查看导出符号的命令：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>exports<span class="operator">-</span>trie .o文件或<span class="type">Mach</span><span class="operator">-</span><span class="type">O文件</span></span><br></pre></td></tr></table></figure>

<h5 id="1-验证导出符号"><a href="#1-验证导出符号" class="headerlink" title="1.验证导出符号"></a>1.验证导出符号</h5><p>在工程中创建一个空类<code>TestObject</code>，并在<code>main.m</code>文件中写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int global_init_value <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> int static_init_value <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%d&quot;</span>, static_init_value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这里涉及多个文件，所以，测试时可以使用上节讲到<code>Mach-O</code>终端调试方法；</p>
<p>查看导出符号，结果如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_export.png" width="600" align=center/></p>
<p>查看符号，结果如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_export_check.png" width="600" align=center/><br>可以看出，导出符号正好与全局符号对应；</p>
<h5 id="2-设置符号不导出"><a href="#2-设置符号不导出" class="headerlink" title="2.设置符号不导出"></a>2.设置符号不导出</h5><p>全局符号不可剥离，但如果将其设置为不导出，符号就变成了本地符号类型了，不仅可以避免外界的错误使用，而且还可以脱符号处理，以减小<code>Mach-O</code>的体积；</p>
<p>为实现这一点，我们可以在自定义动态库时，在配置文件中增加链接器参数，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例：OTHER_LDFLAGS =$(inherited) -Xlinker -unexported_symbol -Xlinker +符号名</span></span><br><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span>$(inherited) <span class="operator">-</span><span class="type">Xlinker</span> <span class="operator">-</span>unexported_symbol <span class="operator">-</span><span class="type">Xlinker</span> _OBJC_METACLASS_<span class="variable">$_TestObject</span></span><br><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span>$(inherited) <span class="operator">-</span><span class="type">Xlinker</span> <span class="operator">-</span>unexported_symbol <span class="operator">-</span><span class="type">Xlinker</span> _OBJC_CLASS_<span class="variable">$_TestObject</span></span><br></pre></td></tr></table></figure>
<p>再次查看导出符号，已经没有了<code>OC</code>类的导出符号，控制台显示结果如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_export_hide.png" width="600" align=center/></p>
<p>需要注意：由于<code>OC</code>是运行时语言，所以，不能直接使用<code>visibility(&quot;hidden&quot;)</code>；</p>
<h5 id="3-查看Mach-O中使用的库以及符号信息，并生成文件"><a href="#3-查看Mach-O中使用的库以及符号信息，并生成文件" class="headerlink" title="3.查看Mach-O中使用的库以及符号信息，并生成文件"></a>3.查看Mach-O中使用的库以及符号信息，并生成文件</h5><p>在配置文件中，增加如下设置：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span>$(inherited) <span class="operator">-</span><span class="type">Xlinker</span> <span class="operator">-</span><span class="type">S</span> <span class="operator">-</span><span class="type">Xlinker</span> <span class="operator">-</span>map <span class="operator">-</span><span class="type">Xlinker</span> $&#123;<span class="type">SRCROOT</span>&#125;<span class="operator">/</span><span class="type">MachOTest_Symbol</span>.text</span><br></pre></td></tr></table></figure>
<p>运行工程后将生成的文件，文件中包含以下信息：</p>
<ol>
<li>编译过程中生成的目标文件；</li>
<li>项目中使用的三方库；</li>
<li>项目中的<code>Sections</code>和<code>Symbols</code>等信息；</li>
</ol>
<h4 id="七、间接符号-Indirect-Symbol"><a href="#七、间接符号-Indirect-Symbol" class="headerlink" title="七、间接符号(Indirect Symbol)"></a>七、间接符号(Indirect Symbol)</h4><p>概念理解：</p>
<ol>
<li>间接符号就是使用的外部符号，例如：使用的系统库、外部动态库符号；</li>
<li>间接符号表中保存当前可执行文件使用的其他的动态库的符号；</li>
</ol>
<p>查看间接符号的命令：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">CMD</span> <span class="operator">=</span> objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">indirect</span><span class="operator">-</span>symbols .o文件或<span class="type">Mach</span><span class="operator">-</span><span class="type">O文件</span></span><br></pre></td></tr></table></figure>

<p>验证间接符号，在<code>main.m</code>文件中写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看间接符号，效果如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_indirect_symbol.png" width="600" align=center/><br>可以看到，<code>NSLog</code>就是间接符号，它属于<code>Foundation</code>动态库：</p>
<ul>
<li><code>adress</code>：表示间接符号链接地址；</li>
<li><code>name</code>：符号名；</li>
</ul>
<h4 id="八、弱符号-Weak-Symbol"><a href="#八、弱符号-Weak-Symbol" class="headerlink" title="八、弱符号(Weak Symbol)"></a>八、弱符号(Weak Symbol)</h4><p><code>Weak Reference Symbol</code>: 表示此未定义符号是弱引用；</p>
<ol>
<li>如果动态链接器找不到该符号的定义，则将其设置为<code>0</code>；</li>
<li>链接器会将此符号设置弱链接标志；</li>
</ol>
<p><code>Weak defintion Symbol</code>: 表示此符号为弱定义符号</p>
<ol>
<li>如果静态链接器或动态链接器为此符号找到另一个(非弱)定义，则弱定义将被忽略；</li>
<li>只能将合并部分中的符号标记为弱定义；</li>
</ol>
<h5 id="1-验证弱引用符号"><a href="#1-验证弱引用符号" class="headerlink" title="1.验证弱引用符号"></a>1.验证弱引用符号</h5><p>对于弱引用符号，更确切的理解是：如果未被定义(没有实现)，系统不会报错；</p>
<p>创建<code>WeakImportSymbol.h/m</code>文件，但只在其<code>.h</code>文件中定义一个没有实现体的弱引用方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">void weak_import_function(void) __attribute__((weak_import));</span><br></pre></td></tr></table></figure>

<p>然后，在<code>main.m</code>中增加如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &quot;WeakImportSymbol.h&quot;</span><br><span class="line">int main(int argc, char <span class="operator">*</span>argv[]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (weak_import_function) &#123;</span><br><span class="line">        weak_import_function();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时运行报错：<code>Undefined symbol: _weak_import_function</code>，因为链接时需要知道符号具体的地址在什么地方，否则就会提示错误；</p>
<p>解决方法：可以通过配置文件告诉编译器，这个符号是动态链接的，<code>dyld</code>运行时会自动查找；</p>
<p>于是，我们在配置文件中增加的配置如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// -U参数：告诉编译器该符号没有定义，需要动态查找</span></span><br><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span>$(inherited) <span class="operator">-</span><span class="type">Xlinker</span> <span class="operator">-</span><span class="type">U</span> <span class="operator">-</span><span class="type">Xlinker</span> _weak_import_function</span><br></pre></td></tr></table></figure>

<p><code>Weak Reference Symbol</code>的好处：</p>
<ol>
<li>可以判断其他的库是否有这个符号，如果有这个符号就可以调用，否则就不调用；</li>
<li>可以将整个动态库文件声明成一个弱引用，也意味着如果你这个库没有导入的话，也不会报动态库找不到的错误；</li>
</ol>
<h5 id="2-验证弱定义符号"><a href="#2-验证弱定义符号" class="headerlink" title="2.验证弱定义符号"></a>2.验证弱定义符号</h5><p>创建<code>WeakSymbol.h/m</code>文件，增加代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// WeakSymbol.h</span></span><br><span class="line">int global_int_value</span><br><span class="line">void weak_function(void);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// WeakSymbol.m</span></span><br><span class="line">void weak_function(void) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;weak_function&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在<code>main.m</code>中增加如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &quot;WeakSymbol.h&quot;</span><br><span class="line"></span><br><span class="line">int global_int_value;</span><br><span class="line"></span><br><span class="line">void weak_function(void) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;weak_function_main&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span>argv[]) &#123;</span><br><span class="line">    weak_function();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时运行报错：<code>2 duplicate symbols for architecture x86_64</code>；</p>
<p>解决方法：将任意一个文件中的全局变量声明为<code>弱定义符号</code>，这样在链接的过程<br> 中，找到符号的另一个(非弱)定义，则弱定义将被忽略，从而避免符号重定义；</p>
<p>于是，我们修改<code>WeakSymbol.h</code>中的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">int global_int_value __attribute__((<span class="keyword">weak</span>));</span><br><span class="line">void weak_function(void)  __attribute__((<span class="keyword">weak</span>));</span><br></pre></td></tr></table></figure>
<p>运行工程后，成功打印结果：<code>weak_function_main</code>；</p>
<h5 id="3-弱定义的本地符号"><a href="#3-弱定义的本地符号" class="headerlink" title="3.弱定义的本地符号"></a>3.弱定义的本地符号</h5><p>将弱定义的符号声明成一个隐藏符号，它就会变成了一个弱定义的本地符号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">void weak_hidden_function(void) __attribute__((<span class="keyword">weak</span>, visibility(<span class="string">&quot;hidden&quot;</span>)));</span><br></pre></td></tr></table></figure>


<h4 id="九、未初始化的全局符号-Common-Symbol"><a href="#九、未初始化的全局符号-Common-Symbol" class="headerlink" title="九、未初始化的全局符号(Common Symbol)"></a>九、未初始化的全局符号(Common Symbol)</h4><p>概念理解：在定义时未初始化的全局符号；</p>
<p>符号作用：</p>
<ol>
<li>在编译和链接的过程中，如果找到定义的符号，会自动将未定义符号删掉；</li>
<li>在链接过程中，链接器默认会把未定义符号变成强制定义的符号；</li>
</ol>
<p>链接器设置：</p>
<ul>
<li><code>-d</code>：强制定义<code>Common Symbol</code>；</li>
<li><code>-commons</code>：指定对待<code>Common Symbol</code>如何响应；</li>
</ul>
<h5 id="1-查看Common-Symbol"><a href="#1-查看Common-Symbol" class="headerlink" title="1.查看Common Symbol"></a>1.查看Common Symbol</h5><p>在<code>main.m</code>文件，写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">int global_uninit_value;</span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span>argv[]) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看符号表，控制台显示如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_common_symbol.png" width="600" align=center/></p>
<h5 id="2-验证Common-Symbol的作用"><a href="#2-验证Common-Symbol的作用" class="headerlink" title="2.验证Common Symbol的作用"></a>2.验证Common Symbol的作用</h5><p>在<code>main.m</code>文件，写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">int global_init_value <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">int global_init_value;</span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="operator">*</span>argv[]) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看符号表，控制台显示如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/symbol_common_symbol_check.png" width="600" align=center/></p>
<h4 id="十、重新导出符号"><a href="#十、重新导出符号" class="headerlink" title="十、重新导出符号"></a>十、重新导出符号</h4><p>概念理解：</p>
<ol>
<li>重新导出符号就是通过对间接符号起别名的方式，将其变成导出符号；</li>
<li>重新导出之后的符号会放在本文件的导出符号表中，此时外界究竟可以查看使用这个符号了；</li>
<li>重新导出符号可以让一个<code>符号</code>可见，也可以让一个<code>动态库</code>可见；</li>
</ol>
<p>举例：当程序链接<code>动态库A</code>，而<code>动态库A</code>又链接<code>动态库B</code>时，<code>动态库B</code>对于程序来说是不可见的，此时就可以使用重新导出符号的方式，使<code>动态库B</code>对程序可见；</p>
<h5 id="2-验证重新导出NSLog"><a href="#2-验证重新导出NSLog" class="headerlink" title="2.验证重新导出NSLog"></a>2.验证重新导出NSLog</h5><p>其实，<code>Foundation</code>已经对<code>NSLog</code>做了重新导出，否则外界是无法使用的；</p>
<p>查看当前符号表，可以看到，<code>NSLog</code>对于当前工程来说还是一个未定义符号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000000000</span>         <span class="operator">*</span><span class="type">UND</span><span class="operator">*</span> _NSLog</span><br></pre></td></tr></table></figure>
<p>现在，我们尝试自己重新导出<code>NSLog</code>符号，可以在配置文件中修改链接器中的参数<code>-alias(起别名)</code>，具体的配置如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span> $(inherited) <span class="operator">-</span><span class="type">Xlinker</span> <span class="operator">-</span>alias <span class="operator">-</span><span class="type">Xlinker</span> _NSLog <span class="operator">-</span><span class="type">Xlinker</span> <span class="type">ZS_NSLog</span></span><br></pre></td></tr></table></figure>
<p>再次查看符号表，此时将看到<code>ZS_NSLog</code>成为导出符号，而且被标记为<code>re-export</code>；</p>
<h4 id="十一、Swift符号"><a href="#十一、Swift符号" class="headerlink" title="十一、Swift符号"></a>十一、Swift符号</h4><p>创建一个<code>SwiftSymbol.swift</code>文件，在其中增加代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PrivateObject</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">testMethod</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublicObject</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">testMethod</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看当前符号表，控制台的效果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">0000000100003bb0 l     <span class="type">F</span> __TEXT,__text <span class="keyword">_</span><span class="variable">$s9MachOTest13PrivateObject33_C45E5A1705242B42AFDE1C0627FBB932LLC10testMethodyyF</span></span><br><span class="line"></span><br><span class="line"><span class="operator">....</span></span><br><span class="line">0000000100003c80 g     <span class="type">F</span> __TEXT,__text <span class="keyword">_</span><span class="variable">$s9MachOTest12PublicObjectC10testMethodyyF</span></span><br></pre></td></tr></table></figure>
<p>结果分析：</p>
<ol>
<li><code>Swift</code>文件产生的符号要比<code>OC</code>文件多出很多；</li>
<li>作为访问控制修饰符的<code>public</code>、<code>private</code>，分别对应着去全局符号(<code>g</code>)、本地符号(<code>l</code>)两种类型；</li>
</ol>
<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ol>
<li><a href="https://sourceforge.net/projects/machoview/">MachView软件下载地址</a></li>
<li><a href="https://github.com/DreamcoffeeZS/TestProjects/tree/main/01.MachO%E4%B8%8E%E7%AC%A6%E5%8F%B7">文中相关Demo下载地址</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS高级</category>
      </categories>
      <tags>
        <tag>Mach-O</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS高级-MachO简单分析</title>
    <url>/2021/11/04/iOS%E9%AB%98%E7%BA%A7-MachO%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><strong>主要内容：</strong></p>
<ol>
<li><code>Mach-O</code>的读写特性</li>
<li>查看命令文档</li>
<li>查看<code>Mach-O</code><span id="more"></span></li>
<li>查看<code>Symbol</code></li>
<li>配置<code>Mach-O</code>终端调试工具</li>
</ol>
<h4 id="一、Mach-O的读写特性"><a href="#一、Mach-O的读写特性" class="headerlink" title="一、Mach-O的读写特性"></a>一、Mach-O的读写特性</h4><p><code>Mach-O</code>文件其实等价于： <code>文件配置 + 二进制代码</code>；</p>
<p><code>Mach-O</code>文件是可读可写的，分析<code>Mach-O</code>文件的结构，可以解释程序运行中的许多问题；</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9d64afd74384beaa9e32663f3857dfc~tplv-k3u1fbpfcp-watermark.image" alt="MachO-简化结构.png"></p>
<h5 id="1-Mach-O可读"><a href="#1-Mach-O可读" class="headerlink" title="1. Mach-O可读"></a>1. Mach-O可读</h5><ol>
<li><code>Header</code>：提供读取所需的身份信息，包括<code>CPU类型</code>、<code>文件类型</code>等；</li>
<li><code>Load Commands</code>：提供读取所需的文件的信息，以<code>Load Command _TEXT</code>为例，其中记录有<ol>
<li><code>_TEXT</code>代码段的起始位置；</li>
<li><code>_TEXT</code>代码段的大小；</li>
</ol>
</li>
<li><code>__TEXT</code>,<code>__DATA</code>,<code>符号表</code>等，这些都是代码编译后的文件、数据存放的位置；</li>
</ol>
<h5 id="2-Mach-O可写"><a href="#2-Mach-O可写" class="headerlink" title="2.Mach-O可写"></a>2.Mach-O可写</h5><ol>
<li><code>Mach-O</code>能被执行是因为有签名，当我们修改了<code>Mach-O</code>文件，需要重新签名才能被苹果系统所接受；</li>
<li>破解软件都需要重新签名，正是这种原因；</li>
</ol>
<h4 id="二、查看命令文档"><a href="#二、查看命令文档" class="headerlink" title="二、查看命令文档"></a>二、查看命令文档</h4><p>有时候，需要在终端查询一些命令的具体用法，有两种方式(以查询<code>nm</code>命令为例)：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">man nm      <span class="comment">//推荐使用</span></span><br><span class="line">nm <span class="operator">--</span>help   </span><br></pre></td></tr></table></figure>

<p>当终端里显示<code>nm</code>的使用文档后，还可快速定位查询，以查询<code>&quot;-a&quot;</code>参数为例：</p>
<ul>
<li><code>/-a</code>：快速匹配文档中<code>-a</code>的位置；</li>
<li><code>n</code>：向下定位<code>-a</code>位置；</li>
<li><code>N</code>：向上定位<code>-a</code>位置；</li>
<li><code>q</code>：退出文档查看；</li>
</ul>
<h4 id="三、查看Mach-O"><a href="#三、查看Mach-O" class="headerlink" title="三、查看Mach-O"></a>三、查看Mach-O</h4><h5 id="1-常用的查看命令"><a href="#1-常用的查看命令" class="headerlink" title="1.常用的查看命令"></a>1.常用的查看命令</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看Header（$&#123;MACH_PATH&#125;表示Mach-O文件位置）</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">private</span><span class="operator">-</span>header $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看Header 和 Load commands</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">private</span><span class="operator">-</span>headers $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看__TEXT</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">-</span>d $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看符号表</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>syms $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看导出符号</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span>exports<span class="operator">-</span>trie $&#123;<span class="type">MACH_PATH</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看间接符号表</span></span><br><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">indirect</span><span class="operator">-</span>symbols $&#123;<span class="type">MACH_PATH</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-测试查看命令"><a href="#2-测试查看命令" class="headerlink" title="2.测试查看命令"></a>2.测试查看命令</h5><p>为了避免过多文件的干扰，创建测试工程时，选择选择<code>MacOS</code> -&gt;<code>Command Line Tool</code>；</p>
<p>进入工程后，在<code>main.m</code>文件中写入代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int global_init_value <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> int static_init_value <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%d&quot;</span>, static_init_value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Xcode</code>运行成功后，<code>Products</code>下的黑色文件即<code>Mach-O可执行文件</code>，如下图：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71a980af83aa4486889b61d4afbec224~tplv-k3u1fbpfcp-watermark.image" alt="MachO-可执行文件位置.png"></p>
<p>切换到可执行文件的目录下，使用<code>objdump</code>命令，查看<code>Header</code>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">private</span><span class="operator">-</span>header <span class="type">MachOTest</span></span><br></pre></td></tr></table></figure>

<p>终端的打印结果如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a50badce80f40c4b20043043fef1a14~tplv-k3u1fbpfcp-watermark.image" alt="objdump-查看Header.png"></p>
<p>使用<code>objdump</code>命令，查看<code>Header</code>以及<code>Load commands</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">objdump <span class="operator">--</span>macho <span class="operator">--</span><span class="keyword">private</span><span class="operator">-</span>headers <span class="type">MachOTest</span></span><br></pre></td></tr></table></figure>

<p>终端的打印结果如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/166474471e0a4d969591eb433827d636~tplv-k3u1fbpfcp-watermark.image" alt="objdump-查看Header&amp;Commands.png"></p>
<p>如上，我们在<code>Mach-O</code>文件的<code>Load Commands</code>中，可以找到<code>程序入口函数</code>以及<code>依赖系统动态库</code>的相关信息；</p>
<h4 id="四、查看Symbol"><a href="#四、查看Symbol" class="headerlink" title="四、查看Symbol"></a>四、查看Symbol</h4><p>查看符号，除了可以使用<code>objdump</code>命令以外，还可以使用<code>nm</code>命令；</p>
<h5 id="1-nm命令简介"><a href="#1-nm命令简介" class="headerlink" title="1.nm命令简介"></a>1.nm命令简介</h5><ol>
<li><code>nm</code>是<code>name</code>的缩写，它显示指定文件中的符号信息，文件可以是对象文件、可执行文件或对象文件库；</li>
<li>如果文件中没有包含符号信息，<code>nm</code>报告该情况，但不把他解释为出错；</li>
<li><code>nm</code>缺省情况下报告十进制符号表示法下的数字值；</li>
</ol>
<p>可以在终端使用<code>man nm</code>命令查看其具体用法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">%</span> man nm</span><br><span class="line">nm <span class="operator">-</span> display name list (symbol table)</span><br></pre></td></tr></table></figure>

<p>即，<code>nm</code>是一个可以查看展示符号表信息的命令。</p>
<h5 id="2-常用命令参数"><a href="#2-常用命令参数" class="headerlink" title="2.常用命令参数"></a>2.常用命令参数</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span>a <span class="comment">//显示符号表所有内容</span></span><br><span class="line"><span class="operator">-</span>p <span class="comment">//不排序，显示符号本来的顺序</span></span><br><span class="line"><span class="operator">-</span>g <span class="comment">//显示全局符号</span></span><br><span class="line"><span class="operator">-</span>r <span class="comment">//逆转排序</span></span><br><span class="line"><span class="operator">-</span>u <span class="comment">//显示未定义符号</span></span><br><span class="line"><span class="operator">-</span>m <span class="comment">//显示N_SECT类型的符号(Mach-O符号)显示</span></span><br></pre></td></tr></table></figure>

<h5 id="3-使用举例"><a href="#3-使用举例" class="headerlink" title="3.使用举例"></a>3.使用举例</h5><p>使用<code>nm</code>命令，查看<code>MachO</code>可执行文件中的符号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">nm <span class="operator">-</span>pa $&#123;<span class="type">MACH_PATH</span>&#125;</span><br></pre></td></tr></table></figure>

<p>终端的打印结果如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ba8fff296804a5180a7ec427f862bf0~tplv-k3u1fbpfcp-watermark.image" alt="nm-查看符号.png"></p>
<p>其中，第二列符号标签的含义如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0df1fe934d0943beb02b34a2da3a2df5~tplv-k3u1fbpfcp-watermark.image" alt="nm-符号类型.png"></p>
<p>注：标记<code>①</code>的<code>Type</code>，⼩写代表本地符号(<code>local symbol</code>);</p>
<h4 id="五、配置Mach-O终端测试工具"><a href="#五、配置Mach-O终端测试工具" class="headerlink" title="五、配置Mach-O终端测试工具"></a>五、配置Mach-O终端测试工具</h4><p>如上的调试过程十分繁琐，每次都需要等到程序运行完成，然后再切换到终端测试命令。为了更方便分析<code>Mach-O</code>，这里可以对工程进一步配置，使其运行时可直接将结果打印在终端里，具体的步骤如下：</p>
<h5 id="1-测试将Xcode打印重定向到终端"><a href="#1-测试将Xcode打印重定向到终端" class="headerlink" title="1.测试将Xcode打印重定向到终端"></a>1.测试将Xcode打印重定向到终端</h5><p>1.新建一个终端，使用<code>tty</code>命令获取其标识位置：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a6712973a5b484ea17dd1a96e79a31e~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-获取终端位置.png"></p>
<p>2.在<code>Xcode</code>中依次打开: <code>Build Phases</code> -&gt;<code>Run Script</code>，输入脚本命令使其能够在运行时打印：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f992f9d1db0c4b808ed2493246f1372d~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-配置RunScript.png"></p>
<p>3.运行工程，可以看到终端的打印如下</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72c865804e78457b9a27a54a2e36b31b~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-测试RunScript.png"></p>
<h5 id="2-测试Xcode脚本命令执行项目中的代码"><a href="#2-测试Xcode脚本命令执行项目中的代码" class="headerlink" title="2.测试Xcode脚本命令执行项目中的代码"></a>2.测试Xcode脚本命令执行项目中的代码</h5><p>虽然成功打印信息到终端，但是<code>&quot;Hello world&quot;</code>这段信息却是固定的，为了动态获取执行参数，我们可以自定义配置文件，并在其中定义如下的参数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DEBUG_URL</span> <span class="operator">=</span> www.debug.com</span><br></pre></td></tr></table></figure>

<p>然后，修改<code>Run Script</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;Hello World&quot;</span> <span class="operator">&gt;</span> <span class="regexp">/dev/</span>ttys000</span><br><span class="line">echo $&#123;<span class="type">DEBUG_URL</span>&#125; <span class="operator">&gt;</span> <span class="regexp">/dev/</span>ttys000</span><br></pre></td></tr></table></figure>

<p>终端打印结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Hello</span> <span class="type">World</span></span><br><span class="line">www.debug.com</span><br></pre></td></tr></table></figure>

<p>这里就说明，<code>Xcode</code>脚本执行与配置文件是在同一个环境下，我们可以做到将配置文件中的各种参数传递给脚本中使用。</p>
<h5 id="3-实现通过脚本命令打印符号信息"><a href="#3-实现通过脚本命令打印符号信息" class="headerlink" title="3. 实现通过脚本命令打印符号信息"></a>3. 实现通过脚本命令打印符号信息</h5><p>在具备以上条件后，可以实现通过脚本命令打印符号信息到终端，具体的做法如下：</p>
<p>将执行命令的操作定义在一个脚本文件中，并起名<code>xcode_run_cmd.sh</code>，其中的关键代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">RunCMDToTTY</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="operator">!</span> <span class="operator">-</span>e <span class="string">&quot;$TTY&quot;</span> ]]; then</span><br><span class="line">        <span class="type">EchoError</span> <span class="string">&quot;=======================&quot;</span></span><br><span class="line">        <span class="type">EchoError</span> <span class="string">&quot;ERROR: Not Config tty to output.&quot;</span></span><br><span class="line">        exit <span class="operator">-</span><span class="number">1</span></span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$CMD&quot;</span> ]]; then</span><br><span class="line">        <span class="type">RunCommand</span> <span class="string">&quot;$CMD&quot;</span> $&#123;<span class="type">CMD_FLAG</span>&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="type">EchoError</span> <span class="string">&quot;========================&quot;</span></span><br><span class="line">        <span class="type">EchoError</span> <span class="string">&quot;ERROR:Failed to run CMD. THE CMD must not null&quot;</span></span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">EchoError</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$TTY&quot;</span> ]]; then</span><br><span class="line">        echo <span class="string">&quot;$@&quot;</span> <span class="number">1</span><span class="operator">&gt;&amp;</span><span class="number">2</span><span class="operator">&gt;</span><span class="variable">$TTY</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        echo <span class="string">&quot;$@&quot;</span> <span class="number">1</span><span class="operator">&gt;&amp;</span><span class="number">2</span></span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">RunCommand</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$VERBOSE_SCRIPT_LOGGING&quot;</span> ]]; then</span><br><span class="line">      <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$TTY&quot;</span> ]]; then</span><br><span class="line">          echo <span class="string">&quot;♦ $@&quot;</span> <span class="number">1</span><span class="operator">&gt;</span><span class="variable">$TTY</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          echo <span class="string">&quot;♦ $*&quot;</span></span><br><span class="line">      fi</span><br><span class="line">      echo <span class="string">&quot;-----------------------------------------&quot;</span> <span class="number">1</span><span class="operator">&gt;</span><span class="variable">$TTY</span></span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="operator">-</span>n <span class="string">&quot;$TTY&quot;</span> ]]; then</span><br><span class="line">      echo `$@ <span class="operator">&amp;&gt;</span><span class="variable">$TTY</span>`</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="string">&quot;$@&quot;</span></span><br><span class="line">  fi</span><br><span class="line">  <span class="keyword">return</span> $<span class="operator">?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">RunCMDToTTY</span></span><br></pre></td></tr></table></figure>

<p>然后，在配置文件里增加三个参数：<code>CMD</code>，<code>CMD_FLAG</code>，<code>TTY</code>，即需要在.<code>xcconfig</code>中进行定义:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Config-TestProject.debug.xcconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DEBUG_URL = www.debug.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MACHO_PATH：Mach-O文件路径，即可执行文件路径，这里用到了环境变量来表示具体路径</span></span><br><span class="line"><span class="comment">// TTY = 终端位置标识</span></span><br><span class="line"><span class="comment">// CMD：运行命令</span></span><br><span class="line"><span class="comment">// CMD_FLAG = 命令参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">MACHO_PATH</span> <span class="operator">=</span> $&#123;<span class="type">BUILD_DIR</span>&#125;<span class="regexp">/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)/</span>$&#123;<span class="type">PRODUCT_NAME</span>&#125;.app<span class="operator">/</span>$&#123;<span class="type">PRODUCT_NAME</span>&#125;</span><br><span class="line"><span class="type">TTY</span> <span class="operator">=</span> <span class="regexp">/dev/</span>ttys000</span><br><span class="line"><span class="type">CMD</span> <span class="operator">=</span> nm</span><br><span class="line"><span class="type">CMD_FLAG</span> <span class="operator">=</span> <span class="operator">-</span>pa $&#123;<span class="type">MACHO_PATH</span>&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后的工程如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea2322ca186a45308e88b39fe840514e~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-配置文件.png"></p>
<p>最后，我们需要更改<code>Run Script</code>指令，使其执行脚本文件：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c1a81edf316474bbcc0b5107869a7bd~tplv-k3u1fbpfcp-watermark.image" alt="TTYDemo-配置脚本Script.png"></p>
<p>此时，再次运行项目，就可以直接在控制台看到使用<code>nm</code>命令分析得到的<code>Mach-O</code>信息了，而且我们可以更换<code>CMD</code>，<code>CMD_FLAG</code>参数，用以调试更多的其他命令。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a href="https://github.com/DreamcoffeeZS/TestProjects.git">文中演示使用的Demo仓库</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS高级</category>
      </categories>
      <tags>
        <tag>Mach-O</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS高级-Xcode多环境配置</title>
    <url>/2021/11/01/iOS%E9%AB%98%E7%BA%A7-Xcode%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>主要内容：</strong></p>
<ol>
<li>区分<code>Project</code>、<code>Target</code>、<code>Scheme</code></li>
<li>多<code>Target</code> 配置</li>
<li><code>Scheme</code>配置<span id="more"></span></li>
<li><code>xcconfig</code>文件配置</li>
</ol>
<h4 id="一、区分Project、Target、Scheme"><a href="#一、区分Project、Target、Scheme" class="headerlink" title="一、区分Project、Target、Scheme"></a>一、区分Project、Target、Scheme</h4><ul>
<li><code>Project</code>：是一个项目的整体，相当于一个仓库，包括了所有的代码和资源文件；</li>
<li><code>Target</code>：相当于一个具体的产品，包含了对于代码，资源文件的具体使用规则和配置；</li>
<li><code>Scheme</code>: 对指定<code>Target</code>的环境进行配置；</li>
</ul>
<p>总结：一个<code>Project</code>可以包含多个<code>Target</code>，也就是说通过不同<code>Target</code>我们可以生成不同的<code>APP</code>；</p>
<p>多环境配置的三种方法：</p>
<ol>
<li>多<code>target</code>配置;</li>
<li><code>Scheme</code>配置;</li>
<li><code>xcconfig</code>文件配置;</li>
</ol>
<h4 id="二、多Target-配置"><a href="#二、多Target-配置" class="headerlink" title="二、多Target 配置"></a>二、多Target 配置</h4><h5 id="1-总结特点"><a href="#1-总结特点" class="headerlink" title="1.总结特点"></a>1.总结特点</h5><ul>
<li>优点：方便管理代码，资源文件，比如在<code>Compile Sources</code>、<code>Copy Bundle Resources</code>里根据需要增加或者删除需要编译的代码和资源；</li>
<li>缺点：配置繁琐，涉及多个<code>info.plist</code>文件、宏定义等，大量的修改人容易错乱；</li>
</ul>
<h5 id="2-基本步骤"><a href="#2-基本步骤" class="headerlink" title="2.基本步骤"></a>2.基本步骤</h5><p>1.创建新<code>target</code></p>
<p>选中已有<code>target</code>，右键选择<code>Duplicate</code>，会拷贝创建出与原<code>Target</code>相同配置的新<code>Target</code>；</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c065c372995d416693dc6ccef0508622~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-Duplicate.png"></p>
<p>2.修改新<code>target</code>的配置</p>
<p>由于拷贝得到的<code>target</code>仍使用旧的配置，为了使用新<code>target</code>，所以我们还需要一些额外设置：</p>
<ol>
<li><p>修改新<code>Target</code>名字；</p>
</li>
<li><p>修改新<code>info.plist</code>名字；</p>
</li>
<li><p>修改<code>Build Settings</code> -&gt; <code>Packaging</code> -&gt; <code>info.plist File</code> 与 <code>Product Bundle identifier</code>；</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/928bf7525e524884a4ede350865c0536~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-修改名字.png"></p>
</li>
</ol>
<p>3.修改<code>Scheme</code>名字</p>
<p>进入<code>Scheme Manager</code>，修改<code>Scheme</code>的名字，这里并非必须，修改是为了更加方便识别;</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89f60813eda548c6932e74d1b22a6083~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-Scheme.png"></p>
<p>4.为了区别不同的<code>Target</code>，增加预定义宏</p>
<p>配置<code>OC</code>工程：<code>Build Settings</code> -&gt; <code>Preprocessor Macros</code></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21ec401d7c3a4fd7a806e38d861bf8da~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-OC添加宏.png"></p>
<p>配置<code>Swift</code>工程：<code>Build Settings</code> -&gt; <code>Other Swift Flags</code></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fde31bff98e443fa485c6b368ff4842~tplv-k3u1fbpfcp-watermark.image" alt="Target配置-Swift添加宏.png"></p>
<p>理解<code>-D</code>用法：</p>
<ol>
<li><code>swiftc</code>编译器中，需要添加一个<code>-D</code>的<code>option</code>，代表将条件编译标志标记为<code>true</code>；</li>
<li>至于<code>-D</code>的说明，也可以使用控制台命令查看：<code>swiftc --help grep &#39;-D&#39;</code></li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span><span class="type">D</span> <span class="operator">&lt;</span>value<span class="operator">&gt;</span>  <span class="type">Marks</span> a conditional compilation flag <span class="keyword">as</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>5.测试<code>target</code>多环境</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">#if</span> <span class="type">DEV</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Project DEV&quot;</span>)</span><br><span class="line"><span class="keyword">#else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Project Normal&quot;</span>)</span><br><span class="line"><span class="keyword">#endif</span></span><br></pre></td></tr></table></figure>

<h4 id="三、Scheme配置"><a href="#三、Scheme配置" class="headerlink" title="三、Scheme配置"></a>三、Scheme配置</h4><p>配置<code>Scheme</code>实现多环境，其实是通过设置多种<code>configurations</code>的方式，具体步骤如下:</p>
<h5 id="1-增加新configration"><a href="#1-增加新configration" class="headerlink" title="1.增加新configration"></a>1.增加新configration</h5><p>进入<code>Project</code> -&gt; <code>Info</code> -&gt; <code>Configurations</code>，在这里可以看到已经存在的<code>Debug</code>、<code>Release</code>等配置。点击<code>“+”</code>，可以在这里增加新的<code>configuration</code>(以<code>Dev</code>为例);</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aa48beefddf4ad9bd70c985a600f608~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-增加configration.png"></p>
<h5 id="2-切换多环境"><a href="#2-切换多环境" class="headerlink" title="2.切换多环境"></a>2.切换多环境</h5><p>增加<code>configuration</code>后，在<code>Edit Scheme</code>时，也会多出一种<code>configration</code>。我们在<code>run</code>的时候，就可以手动切换<code>configration</code>使用不同的环境；</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ef3d7a5ee5c48cf95c878f3b53e8451~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-切换configration.png"></p>
<h5 id="3-多Scheme"><a href="#3-多Scheme" class="headerlink" title="3.多Scheme"></a>3.多Scheme</h5><p>每次手动切换<code>configration</code>较为繁琐，我们还可以使用不同的<code>Scheme</code>直接对应不同的配置；</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8579731f6eeb4f979f042ec456bec16f~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-New-Scheme.png"></p>
<h5 id="4-测试Scheme多环境"><a href="#4-测试Scheme多环境" class="headerlink" title="4.测试Scheme多环境"></a>4.测试Scheme多环境</h5><p>1.<code>Build Setting</code> -&gt; <code>User-Defined</code>里自定义<code>Host_URL</code>，再对不同的<code>configration</code>配置不同的值；</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdffb0e428024bf793cdc242ff491d41~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-User-HOST_URL.png"></p>
<p>2.将<code>Host_URL</code>以变量的方式配置<code>到info.plist</code>文件中；</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81de9bcb9a1241d9b280a363d5683c2e~tplv-k3u1fbpfcp-watermark.image" alt="Scheme配置-Info-HOST_URL.png"></p>
<p>3.读取<code>info.plist</code>，手动切换<code>configration</code>或者使用不同的<code>Scheme</code>运行，将得到不同的信息；</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> path <span class="operator">=</span> <span class="type">Bundle</span>.main.path(forResource: <span class="string">&quot;Info&quot;</span>, ofType: <span class="string">&quot;plist&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span>&#125;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> infoDic <span class="operator">=</span> <span class="type">NSDictionary</span>(contentsOfFile: path) <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> host_url <span class="operator">=</span> infoDic[<span class="string">&quot;HOST_URL&quot;</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;HOST_URL:<span class="subst">\(host_url)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、xcconfig配置文件"><a href="#四、xcconfig配置文件" class="headerlink" title="四、xcconfig配置文件"></a>四、xcconfig配置文件</h4><p><code>xcconfig</code>配置文件：</p>
<ol>
<li><code>.xcconfig</code>配置文件，可以帮助我们以文件的形式配置<code>build settings</code>里的内容；</li>
<li><code>.xcconfig</code>的文件的内容，是以<code>key-value</code>形式构成的；</li>
<li>增加<code>.xcconfig</code>文件后，依然可以继续在<code>build settings</code>里增加配置项目，并不会覆盖；</li>
</ol>
<h5 id="1-查看配置文件"><a href="#1-查看配置文件" class="headerlink" title="1.查看配置文件"></a>1.查看配置文件</h5><p>其实，若使用<code>Cocoapods</code>管理第三方库，就已经自动生成了<code>Debug</code>和<code>Release</code>配置文件。</p>
<p>查看配置：<code>Xcode</code> -&gt; <code>PROJECT</code> -&gt; <code>info</code> -&gt; <code>Configurations</code></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e6c883e12ae461788fa93e177c45c19~tplv-k3u1fbpfcp-watermark.image" alt="xxconfig-pods配置.png"></p>
<h5 id="2-自定义配置文件"><a href="#2-自定义配置文件" class="headerlink" title="2.自定义配置文件"></a>2.自定义配置文件</h5><ol>
<li><code>Commd +N</code> -&gt; 搜索<code>Configuration Setting File</code>，保存名称以”<code>目录名-App名.环境</code>“为格式， 如”<code>Config-TestProject.debug</code>“；</li>
<li>在<code>.xcconfig</code>文件里写入配置，而这里用到的<code>key</code>其实都是<code>build settings</code>配置选项的缩写，具体可查看网站<a href="https://xcodebuildsettings.com/">Xcode Build Settings</a>；</li>
</ol>
<p>举例：在配置文件中写入以下配置：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SLASH</span> <span class="operator">=</span> <span class="operator">/</span></span><br><span class="line"><span class="type">HOST_URL</span> <span class="operator">=</span> http:$&#123;<span class="type">SLASH</span>&#125;<span class="operator">/</span><span class="number">1234</span></span><br><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span>  <span class="operator">-</span>framework <span class="string">&quot;AFNetworking&quot;</span></span><br><span class="line"><span class="type">HEADER_SEARCH_PATHS</span> <span class="operator">=</span> <span class="regexp">/abcd/</span>efg</span><br></pre></td></tr></table></figure>

<p>此时执行编译后，在<code>build settings</code>里搜索查看<code>Other Linker Flags</code>、<code>Header Search Paths</code>，这些配置都已经被成功修改；</p>
<h5 id="3-特殊符号问题"><a href="#3-特殊符号问题" class="headerlink" title="3.特殊符号问题"></a>3.特殊符号问题</h5><p>在写入配置信息时，其中<code>url</code>的<code>//</code>会被认为是注释。此时，我们可以先定义一个变量<code>SLASH = /</code>， 如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SLASH</span> <span class="operator">=</span> <span class="operator">/</span></span><br><span class="line"><span class="type">HOST_URL</span> <span class="operator">=</span> http:$&#123;<span class="type">SLASH</span>&#125;<span class="operator">/</span><span class="number">5678</span></span><br></pre></td></tr></table></figure>

<h5 id="4-增加约束条件"><a href="#4-增加约束条件" class="headerlink" title="4.增加约束条件"></a>4.增加约束条件</h5><p>某些情况下，我们需要为配置增加约束条件，如只在<code>Debug</code>环境下、<code>SDK</code>是模拟器，且架构是<code>x86_64</code>的情况下才会<code>link</code>这个<code>frameworkName</code>，则需要如下配置：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">OTHER_LDFLAGS</span>[config<span class="operator">=</span><span class="type">Debug</span>][sdk<span class="operator">=</span>iphonesimulator<span class="operator">*</span>][arch<span class="operator">=</span>x86_64] <span class="operator">=</span> <span class="operator">-</span>framework <span class="string">&quot;frameworkName&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="5-xcconfig文件冲突问题"><a href="#5-xcconfig文件冲突问题" class="headerlink" title="5.xcconfig文件冲突问题"></a>5.xcconfig文件冲突问题</h5><p>我们习惯于使用<code>cocoapods</code>管理第三方，由其生成的配置文件和我们自定义的配置文件就会冲突，因为一个环境只能配置一个<code>.xcconfig</code>文件：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1717a5a897ba4feeb8c4da0550330622~tplv-k3u1fbpfcp-watermark.image" alt="xxconfig-pods冲突.png"></p>
<p>而且，此时更新<code>Pods</code>也会警告：已经存在其他的配置文件，<code>Pods</code>设置的.<code>xcconfig</code>文件不会生效；</p>
<p>解决方案：在自定义配置文件中使用关键<code>include</code>命令，引入<code>pods</code>的配置文件，使其生效：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意：这里需要根据debug、release等不同的环境，分别设置</span></span><br><span class="line">#include <span class="string">&quot;Pods/Target Support Files/Pods-TestProject/Pods-TestProject.debug.xcconfig&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="6-xcconfig关键字冲突问题"><a href="#6-xcconfig关键字冲突问题" class="headerlink" title="6.xcconfig关键字冲突问题"></a>6.xcconfig关键字冲突问题</h5><p>将<code>Pods</code>生成的<code>.xcconfig</code>文件通过<code>include</code>导入自定义的配置文件中后，如果两者都对同一个<code>key</code>进行过配置，就会导致前者无效的问题。</p>
<p>比如，两者都对相同的<code>Other Link Flags</code>进行配置，查看<code>Build Setting</code>后，会发现<code>Pods</code>生成的<code>.xcconfig</code>没有生效；</p>
<p>解决方案：使用<code>inherited</code>进行继承，在自定义配置文件中配置如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">OTHER_LDFLAGS</span> <span class="operator">=</span> $(inherited) <span class="operator">-</span>framework <span class="string">&quot;AFNetworking&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="7-测试-xcconfig多环境"><a href="#7-测试-xcconfig多环境" class="headerlink" title="7.测试.xcconfig多环境"></a>7.测试.xcconfig多环境</h5><ol>
<li>在不同的<code>.xcconfig</code>定义不同的<code>HOST_URL</code>，并以类似上文的步骤在<code>info.plist</code>中增加配置；</li>
<li>切换到不同的<code>configration</code>下运行项目，将会得到不同的<code>HOST_URL</code>；</li>
</ol>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a href="https://github.com/DreamcoffeeZS/TestProjects/tree/main/01.MachO%E4%B8%8E%E7%AC%A6%E5%8F%B7">本文测试Demo地址</a></li>
<li><a href="https://www.jianshu.com/p/3508e9fff7cc">iOS多Target开发相似App</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS高级</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS高级-编译原理</title>
    <url>/2021/11/02/iOS%E9%AB%98%E7%BA%A7-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><strong>主要内容:</strong></p>
<ol>
<li>理解<code>C</code>、<code>C++</code>以及<code>OC</code>的关系</li>
<li>编译型语言与解释型语言</li>
<li>编译器<code>LLVM</code>与<code>CLang</code><span id="more"></span></li>
<li>理解<code>iOS</code>编译流程</li>
<li>预处理</li>
<li>编译</li>
<li>汇编</li>
<li>链接</li>
</ol>
<h4 id="一、理解C、C-以及OC的关系"><a href="#一、理解C、C-以及OC的关系" class="headerlink" title="一、理解C、C++以及OC的关系"></a>一、理解C、C++以及OC的关系</h4><h5 id="1-C语言"><a href="#1-C语言" class="headerlink" title="1.C语言"></a>1.C语言</h5><ol>
<li><code>C</code>语言是一门面向过程的计算机编程语言，既可用于系统软件开发，也适用于应用软件开发；</li>
<li><code>C</code>语言编译器普遍存在于各种不同的操作系统中，例如<code>Microsoft Windows</code>,<code>Mac OS X</code>, <code>Linux</code>, <code>Unix</code>等；</li>
<li><code>C</code>语言的设计影响了众多后来的编程语言，例如<code>C++</code>、<code>Objective-C</code>、<code>Java</code>、<code>C#</code>等；</li>
</ol>
<h5 id="2-C-语言"><a href="#2-C-语言" class="headerlink" title="2.C++语言"></a>2.C++语言</h5><ol>
<li>兼容了<code>C</code>语言面向过程特点，但又进行了扩充和完善；</li>
<li>作为一种面向对象的语言，具有封装、多继承、多态等特性；</li>
</ol>
<h5 id="3-Objective-C语言"><a href="#3-Objective-C语言" class="headerlink" title="3.Objective-C语言"></a>3.Objective-C语言</h5><ol>
<li>扩展了<code>C</code>语言的能力，使其具备面向对象设计的能力，相当于<code>C</code>的超集；</li>
<li><code>OC</code>代码中也可以有<code>C</code>和<code>C++</code>语句，它可以调用<code>C</code>函数，也可以通过<code>C++</code>对象访问方法；</li>
</ol>
<h5 id="4-OC与C-的比较"><a href="#4-OC与C-的比较" class="headerlink" title="4.OC与C++的比较"></a>4.OC与C++的比较</h5><ol>
<li><code>OC</code>与<code>C++</code>都是从<code>C</code>语言演变而来面向对象设计语言，也都兼容标准的<code>C</code>语言；但它们属于不同的面向对象学派；</li>
<li>两者最大的不同在于：<code>OC</code>提供了运行时的动态绑定机制，而<code>C++</code>是编译时静态绑定，并通过嵌入类和虚函数来模拟实现；</li>
<li><code>OC</code>在编译阶段降低了编译要求提高了灵活性，而<code>C++</code>则是提高了编译要求，在编译过程中就发现更多的潜在错误，在运行前改正，降低了灵活性；</li>
</ol>
<p>以下面的代码为例，在编译期间，<code>C++</code>认为是错误的，而<code>OC</code>则认为没有问题：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSString</span> <span class="operator">*</span>test <span class="operator">=</span>(id) [[<span class="type">NSArray</span> alloc] <span class="keyword">init</span>];</span><br></pre></td></tr></table></figure>

<p><code>OC</code>与<code>C++</code>在使用细节上的不同如下：</p>
<ol>
<li>定型：<code>OC</code>是动态定型，可以允许根据字符串名字来访问方法和类，还可以动态链接和添加类；</li>
<li>继承：<code>OC</code>不支持多继承，<code>C++</code>支持多继承；</li>
<li>函数调用：<code>OC</code>通过消息传递实现函数调用，而<code>C++</code>直接进行函数调用；</li>
<li>接口：<code>OC</code>采用<code>Protocol</code>形式来定义接口，而<code>C++</code>采用虚函数形式来定义接口；</li>
<li>重载：<code>OC</code>不允许同一个类中两个方法有相同的名字(即使只是参数类型不同)，但<code>C++</code>可以；</li>
</ol>
<h4 id="二、编译型语言与解释型语言"><a href="#二、编译型语言与解释型语言" class="headerlink" title="二、编译型语言与解释型语言"></a>二、编译型语言与解释型语言</h4><p><code>Objective-C</code>属于编译型语言，这是为了保证<code>iPhone</code>的执行效率；</p>
<h5 id="1-编译型语言"><a href="#1-编译型语言" class="headerlink" title="1.编译型语言"></a>1.编译型语言</h5><ol>
<li>程序运行前，必须先通过<code>编译器</code>生成<code>机器码</code>，机器码直接通过<code>CPU</code>执行，运行时不需要重新翻译；</li>
<li>程序执行效率高，但依赖编译器，调试周期长、跨平台性差些；</li>
<li>代表语言：<code>C</code>、<code>C++</code>、<code>OC</code>等；</li>
</ol>
<h5 id="2-解释型语言"><a href="#2-解释型语言" class="headerlink" title="2.解释型语言"></a>2.解释型语言</h5><ol>
<li>程序运行前，不需要进行编译，而是以文本方式存储程序代码，运行时需要解释器解释后再运行；</li>
<li>程序执行效率低下，但是程序具有动态性，运行后也可以随时增加和更新代码来改变程序逻辑；</li>
<li>代表语言：<code>Javascript</code>、<code>Python</code>等；</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/651ade0e8b42478994d08c42356d218f~tplv-k3u1fbpfcp-watermark.image" alt="编译原理-语言的分类.jpg"></p>
<h4 id="三、编译器LLVM与CLang"><a href="#三、编译器LLVM与CLang" class="headerlink" title="三、编译器LLVM与CLang"></a>三、编译器LLVM与CLang</h4><h5 id="1-编译器"><a href="#1-编译器" class="headerlink" title="1.编译器"></a>1.编译器</h5><p>概念：把一种编程语言(<code>原始语言</code>)转换为另一种编程语言(目标语言)的程序;</p>
<p>大多数编译器都分<code>前端</code>和<code>后端</code>两部分：</p>
<ul>
<li>前端：负责<code>词法分析</code>、<code>语法分析</code>、<code>生成中间代码</code>；</li>
<li>后端：以<code>中间代码</code>作为输入，进行与架构无关的代码优化，接着针对不同架构生成不同的机器码；</li>
</ul>
<p>补充：</p>
<ol>
<li>前后端以<code>中间代码</code>作为媒介，使得前后端可以独立的变化，互不影响；</li>
<li>这样的好处在于：新增一门语言只需要修改前端，而新增一种<code>CPU</code>架构只需要修改后端即可；</li>
</ol>
<h5 id="2-LLVM与Clang"><a href="#2-LLVM与Clang" class="headerlink" title="2.LLVM与Clang"></a>2.LLVM与Clang</h5><p><code>LLVM</code>是苹果当前使用的编译器：</p>
<ol>
<li><code>LLVM</code>是一套编译器基础设施项目，为自由软件，以<code>C++</code>写成，包含一系列模块化的编译器组件和工具链，用来开发编译器<code>前端</code>和<code>后端</code>；</li>
<li>基于 <code>LLVM</code> 衍生出了一些强大的子项目，比如：<code>Clang</code> 和 <code>LLDB</code>。</li>
</ol>
<p><code>CLang</code>基于<code>LLVM</code>，是一个高度模块化开发的轻量级编译器；</p>
<ol>
<li><code>CLang</code>主要来自苹果电脑的支持，同时支持<code>C</code>、<code>Objective-C</code>以及<code>C++</code>；</li>
<li><code>CLang</code>用于替代<code>Xcode5</code>版本前使用的<code>GCC</code>，编译速度提高了<code>3</code>倍：</li>
</ol>
<h5 id="3-理解iOS中的编译器"><a href="#3-理解iOS中的编译器" class="headerlink" title="3.理解iOS中的编译器"></a>3.理解iOS中的编译器</h5><ol>
<li>在<code>iOS</code>开发中，通常<code>LLVM</code>被认为是编译器的后端，而<code>Clang</code>是作为编译器的前端；</li>
<li>二者以 <code>IR</code>（中间代码）作为媒介，这样前后端分离，使得前后端可以独立的变化，互不影响；</li>
<li><code>C</code> 语言家族的前端是 <code>clang</code>，<code>swift</code> 的前端是 <code>swiftc</code>，但二者的后端都是 <code>LLVM</code>；</li>
</ol>
<h4 id="四、理解iOS编译流程"><a href="#四、理解iOS编译流程" class="headerlink" title="四、理解iOS编译流程"></a>四、理解iOS编译流程</h4><h5 id="1-编译流程图"><a href="#1-编译流程图" class="headerlink" title="1.编译流程图"></a>1.编译流程图</h5><p><a href="http://llvm.org/docs/">LLVM的编译过程</a>相当复杂，<code>iOS</code>代码运行需要经过：<code>预处理</code>、<code>编译</code>、<code>汇编</code>、<code>链接</code>四个关键阶段，具体的流程如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b0e10d16e16408d86cf70758c4b8e03~tplv-k3u1fbpfcp-watermark.image" alt="编译原理-编译流程.png"></p>
<h5 id="2-准备测试文件"><a href="#2-准备测试文件" class="headerlink" title="2.准备测试文件"></a>2.准备测试文件</h5><p>以<code>OC</code>语言为例，详细分析代码的编译流程，准备一个<code>main.m</code>文件的内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">/// 增加注释：宏定义Name</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Name <span class="string">&quot;梧雨北辰&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;Hello, %s&quot;</span>, Name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="五、预处理-Prepressing"><a href="#五、预处理-Prepressing" class="headerlink" title="五、预处理(Prepressing)"></a>五、预处理(Prepressing)</h4><h5 id="1-主要功能"><a href="#1-主要功能" class="headerlink" title="1.主要功能"></a>1.主要功能</h5><ol>
<li>替换宏：替换代码中各种宏定义，如定义的常量、函数等；</li>
<li>导入头文件：将<code>#include</code>包含的文件插入到该指令位置等；</li>
<li>清理注释：删除所有注释：<code>//</code> 、<code>/*</code> <code>*/</code>等；</li>
<li>条件编译：处理<code>#if</code>、<code>#ifdef</code>，<code>#endif</code>等类似的条件编译；</li>
<li>添加行号和文件名标识：以便于编译时编译器能够显示警告和错误的所在行号；</li>
</ol>
<h5 id="2-查看预处理结果"><a href="#2-查看预处理结果" class="headerlink" title="2.查看预处理结果"></a>2.查看预处理结果</h5><p>使用<code>xcrun</code>命令，在终端执行预处理操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span><span class="type">E</span> main.m</span><br></pre></td></tr></table></figure>

<p>终端显示效果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;main.m&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/Applications/Xcode13.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h&quot;</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"># <span class="number">193</span> <span class="string">&quot;/Applications/Xcode13.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h&quot;</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;main.m&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line"> <span class="type">NSLog</span>(@<span class="string">&quot;Hello, %s&quot;</span>, <span class="string">&quot;梧雨北辰&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<ol>
<li>预处理后的文件中，注释已经被清理，宏定义也已经被替换；</li>
<li>预处理后的文件有很多行，因为该过程中导入了头文件(<code>Foundation.h</code>)，而且这个过程是递归的；</li>
</ol>
<h4 id="六、编译-Compilation"><a href="#六、编译-Compilation" class="headerlink" title="六、编译(Compilation)"></a>六、编译(Compilation)</h4><h5 id="1-词法分析-Lexical-Analysis"><a href="#1-词法分析-Lexical-Analysis" class="headerlink" title="1. 词法分析(Lexical Analysis)"></a>1. 词法分析(Lexical Analysis)</h5><p>主要功能：通过扫描器，分割识别源代码符号(如大小括号、<code>=</code>、字符串)；</p>
<p>使用<code>xcrun</code>命令，在终端执行词法分析操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span>fmodules <span class="operator">-</span>fsyntax<span class="operator">-</span>only <span class="operator">-</span><span class="type">Xclang</span> <span class="operator">-</span>dump<span class="operator">-</span>tokens main.m</span><br></pre></td></tr></table></figure>

<p>终端显示效果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">annot_module_include &#x27;#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"><span class="operator">/</span>&#x27;     <span class="type">Loc</span><span class="operator">=&lt;</span>main.m:<span class="number">1</span>:<span class="number">1</span><span class="operator">&gt;</span></span><br><span class="line">int &#x27;int&#x27;  [<span class="type">StartOfLine</span>]  <span class="type">Loc</span><span class="operator">=&lt;</span>main.m:<span class="number">4</span>:<span class="number">1</span><span class="operator">&gt;</span></span><br><span class="line">identifier &#x27;main&#x27;  [<span class="type">LeadingSpace</span>]</span><br><span class="line"></span><br><span class="line"><span class="operator">......</span></span><br><span class="line"></span><br><span class="line">r_brace &#x27;&#125;&#x27;    [<span class="type">StartOfLine</span>]  <span class="type">Loc</span><span class="operator">=&lt;</span>main.m:<span class="number">7</span>:<span class="number">1</span><span class="operator">&gt;</span></span><br><span class="line">eof &#x27;&#x27;        <span class="type">Loc</span><span class="operator">=&lt;</span>main.m:<span class="number">10</span>:<span class="number">1</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<ol>
<li>每个被分割的源代码符号都被记录了位置，方便后续定位错误；</li>
<li>比如<code>Loc=&lt;main.m:4:1&gt;</code> 就表示：<code>&#39;int&#39;</code>这个符号是从源文件<code>main.m</code>的第<code>4</code>行的第<code>1</code>个字符开始的；</li>
</ol>
<h5 id="2-语法分析-Semantic-Analysis"><a href="#2-语法分析-Semantic-Analysis" class="headerlink" title="2.语法分析(Semantic Analysis)"></a>2.语法分析(Semantic Analysis)</h5><p>主要功能：对源代码符号进行分析，验证语法是否正确，最后生成<code>AST</code>语法树；</p>
<p>使用<code>xcrun</code>命令，查看语法分析结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span>fsyntax<span class="operator">-</span>only <span class="operator">-</span><span class="type">Xclang</span> <span class="operator">-</span>ast<span class="operator">-</span>dump main.c  <span class="keyword">open</span> <span class="operator">-</span>f</span><br></pre></td></tr></table></figure>

<p><code>AST</code>语法树：</p>
<ol>
<li>是抽象语法树，结构上比代码更精简，遍历速度更快；</li>
<li>能够更快的进行静态检查，同时生成<code>IR</code>(中间代码)；</li>
</ol>
<h5 id="3-静态分析-Static-Analysis"><a href="#3-静态分析-Static-Analysis" class="headerlink" title="3.静态分析(Static Analysis)"></a>3.静态分析(Static Analysis)</h5><p>主要功能：对<code>AST</code>树进行遍历分析，包括<code>类型检查</code>、<code>方法实现检查</code>，会及时提示错误；</p>
<h5 id="4-生成中间代码-Code-Generation"><a href="#4-生成中间代码-Code-Generation" class="headerlink" title="4.生成中间代码(Code Generation)"></a>4.生成中间代码(Code Generation)</h5><p>主要功能：<code>CodeGen</code>负责将<code>AST</code>语法树自顶向下遍历，逐步翻译成<code>IR</code>中间代码；</p>
<p><code>IR</code>中间代码：</p>
<ol>
<li>这是一种更接近于机器码的语言，使得编译器被分为前端和后端，不同的平台可以利用各自的编译器将中间代码，转化为适合不同平台的机器码；</li>
<li>对于<code>iOS</code>系统来说，<code>IR</code>中间代码生成的就是<code>Mach-O</code>可执行文件;</li>
<li><code>IR</code>是前端的输出，后端的输入；</li>
</ol>
<h4 id="七、汇编-Assembly"><a href="#七、汇编-Assembly" class="headerlink" title="七、汇编(Assembly)"></a>七、汇编(Assembly)</h4><p>输出<code>中间代码</code>标志着前端工作的完成，接下来将进入后端的处理流程。</p>
<h5 id="1-LLVM优化中间代码"><a href="#1-LLVM优化中间代码" class="headerlink" title="1.LLVM优化中间代码"></a>1.LLVM优化中间代码</h5><p>中间代码<code>IR</code>进入后端，<code>LLVM</code>会对其进行优化：</p>
<ol>
<li><code>Optimization Level</code></li>
<li><code>bitcode</code></li>
</ol>
<h5 id="2-生成汇编代码"><a href="#2-生成汇编代码" class="headerlink" title="2.生成汇编代码"></a>2.生成汇编代码</h5><p><code>LLVM</code>对<code>IR</code>进行优化后，会针对不同架构生成不同汇编代码；</p>
<p>汇编阶段的目的：</p>
<ol>
<li>将代码汇编化，并将符号进行归类；</li>
<li>将外部导入符号，放到重定位符号表；</li>
<li>最后生成一个或多个<code>.o</code>目标文件；</li>
</ol>
<p>使用<code>xcrun</code>命令，生成汇编文件：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span><span class="type">S</span> main.m <span class="operator">-</span>o main.s</span><br></pre></td></tr></table></figure>

<p>打开<code>.s</code>文件，摘取内容如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    .section    __TEXT,__text,regular,pure_instructions</span><br><span class="line">    .build_version macos, <span class="number">11</span>, <span class="number">0</span> sdk_version <span class="number">11</span>, <span class="number">3</span></span><br><span class="line">    .globl  _main                           ## <span class="operator">--</span> <span class="type">Begin</span> function main</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    callq   _NSLog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure>

<p>可以看到，汇编文件中的<code>NSLog</code>操作已经被转化为汇编命令形式的调用，即<code>callq _NSLog</code>；</p>
<h5 id="3-生成目标文件"><a href="#3-生成目标文件" class="headerlink" title="3.生成目标文件"></a>3.生成目标文件</h5><p>该阶段是<code>汇编器</code>将<code>汇编代码</code>转换为<code>机器代码</code>，并输出<code>目标文件</code>，即<code>.o</code>文件；</p>
<p>使用<code>xcrun</code>命令，生成目标文件:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">xcrun clang <span class="operator">-</span>fmodules <span class="operator">-</span>c main.m <span class="operator">-</span>o main.o</span><br></pre></td></tr></table></figure>

<p>使用<code>file</code>命令，查看目标文件类型:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">%</span> file main.o</span><br><span class="line">main.o: <span class="type">Mach</span><span class="operator">-</span><span class="type">O</span> <span class="number">64</span><span class="operator">-</span>bit object x86_64</span><br></pre></td></tr></table></figure>

<p>可以看到，汇编器生成<code>Mach-O</code>格式的文件，而且是<code>object</code>类型，即目标文件类型：</p>
<ol>
<li><code>Mach-O</code>文件是用于<code>iOS</code>和<code>OS</code>平台上的文件类型；</li>
<li><code>Mach-O</code>作为<code>a.out</code>格式的替代，提供了更强的扩展性，也提升了符号表中信息的访问速度；</li>
</ol>
<p>使用<code>xcrun</code>命令，查看下<code>main.o</code>中的符号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">xcrun nm <span class="operator">-</span>nm main.o</span><br></pre></td></tr></table></figure>

<p>终端显示效果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">                 (undefined) external _NSLog</span><br><span class="line">                 (undefined) external ___CFConstantStringClassReference</span><br><span class="line"><span class="number">0000000000000000</span> (__TEXT,__text) external _main</span><br></pre></td></tr></table></figure>

<p>可以看到，此时我们使用的<code>NSLog</code>函数，对应着<code>_NSLog</code>符号：</p>
<ol>
<li><code>undefined</code>：表示在当前文件暂时找不到符号<code>_NSLog</code>；</li>
<li><code>external</code>：表示这个符号是外部可以访问的，对应表示文件私有的符号是<code>non-external</code>；</li>
</ol>
<h4 id="八、链接-Linking"><a href="#八、链接-Linking" class="headerlink" title="八、链接(Linking)"></a>八、链接(Linking)</h4><p>主要功能：符号解析、重定位、合并目标文件，最终生成可执行文件；</p>
<h5 id="1-使用xcrun命令执行链接，得到可执行文件"><a href="#1-使用xcrun命令执行链接，得到可执行文件" class="headerlink" title="1.使用xcrun命令执行链接，得到可执行文件"></a>1.使用xcrun命令执行链接，得到可执行文件</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">xcrun clang main.o <span class="operator">-</span>o main</span><br></pre></td></tr></table></figure>

<h5 id="2-使用file命令，查看文件类型"><a href="#2-使用file命令，查看文件类型" class="headerlink" title="2.使用file命令，查看文件类型"></a>2.使用file命令，查看文件类型</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">%</span> file main</span><br><span class="line">main: <span class="type">Mach</span><span class="operator">-</span><span class="type">O</span> <span class="number">64</span><span class="operator">-</span>bit executable x86_64</span><br><span class="line"><span class="operator">%</span> <span class="operator">./</span>main</span><br><span class="line"><span class="number">2021</span><span class="operator">-</span><span class="number">10</span><span class="operator">-</span><span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">41.846</span> main[<span class="number">5663</span>:<span class="number">660299</span>] <span class="type">Hello</span>, 梧雨北辰</span><br></pre></td></tr></table></figure>

<p>结果分析：虽然还是<code>Mach-O</code>格式，但此时已经是<code>executable</code>类型了，即可执行文件。而且运行该文件后也打印出了预期的结果；</p>
<h5 id="3-再次使用xcrun命令，查看可执行文件的符号表"><a href="#3-再次使用xcrun命令，查看可执行文件的符号表" class="headerlink" title="3.再次使用xcrun命令，查看可执行文件的符号表"></a>3.再次使用xcrun命令，查看可执行文件的符号表</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">%</span> xcrun nm <span class="operator">-</span>nm main</span><br><span class="line">                 (undefined) external _NSLog (from <span class="type">Foundation</span>)</span><br><span class="line">                 (undefined) external ___CFConstantStringClassReference (from <span class="type">CoreFoundation</span>)</span><br><span class="line">                 (undefined) external dyld_stub_binder (from libSystem)</span><br><span class="line"><span class="number">0000000100000000</span> (__TEXT,__text) [referenced dynamically] external __mh_execute_header</span><br><span class="line">0000000100003f40 (__TEXT,__text) external _main</span><br><span class="line"><span class="number">0000000100008008</span> (__DATA,__data) non<span class="operator">-</span>external __dyld_private</span><br></pre></td></tr></table></figure>

<p>结果分析：<code>_NSLog</code>符号依然是<code>undefined</code>，不过此时多了一些信息，即<code>from Foundation</code>，表示这个符号来自于<code>Foundation</code>，会在运行时动态绑定；</p>
<h5 id="4-链接阶段的主要任务"><a href="#4-链接阶段的主要任务" class="headerlink" title="4.链接阶段的主要任务"></a>4.链接阶段的主要任务</h5><p>1.符号解析</p>
<p>将每个符号引用和对应的符号定义关联起来；</p>
<ul>
<li>链接器链接多文件时会创建符号表，用于记录所有已经定义和未定义的符号；<ol>
<li>出现相同符号，会报错：<code>&quot;ld:dumplicate symbols&quot;</code>；</li>
<li>在其他目标文件里没有找到到符号，会报错：<code>&quot;Undefined symbols&quot;</code>；</li>
</ol>
</li>
<li>另外，链接器在整理函数的符号调用关系时，可以帮助我们理清那些函数没有被调用，并自动去除掉；</li>
</ul>
<p>2.重定位</p>
<p>将变量名、函数名这些符号定义与一个内存位置关联起来；</p>
<ul>
<li>因为只有通过了绑定，机器才知道需要操作什么内存地址；</li>
<li>否则，我们就需要在写代码时给每个指令设置好内存地址，不仅操作繁琐，而且容易引起出错；</li>
</ul>
<p>3.合并目标文件</p>
<p>将多个<code>.m文件</code>编译产生的<code>.o</code>目标文件与其他<code>Mach-O</code>文件(如<code>dylib</code>、<code>a</code>、<code>tbd</code>），合成一个<code>Mach-O</code>格式的可执行文件；</p>
<ul>
<li>通常项目都会包含多个文件，不同文件之间的<code>变量</code>和<code>接口函数</code>就会产生相互依赖关系；</li>
<li>程序运行前，需要使用链接器将多个文件里的符号和地址绑定起来，才能保证整个程序里的变量、接口的正常调用；</li>
</ul>
<h5 id="5-理解静态链接与动态链接"><a href="#5-理解静态链接与动态链接" class="headerlink" title="5.理解静态链接与动态链接"></a>5.理解静态链接与动态链接</h5><p>静态链接：作用于编译期，链接后的文件依然可能会存在一些<code>&quot;undefined&quot;</code>的符号。但是这些符号都会被记录下来，在运行时再通过<code>dlopen</code>和<code>dlsym</code>动态链接绑定；</p>
<p>动态链接：作用于运行时，这样的优势在于：诸多类似<code>UIKit</code>这样的共享库将不必包含在每一个<code>App</code>包里。比如：我们使用到的<code>UIKit</code>系统库，等到点击<code>App</code>真正开始运行之前，才会去链接依赖的<code>UIKit</code>，链接完成再运行<code>App</code>；</p>
]]></content>
      <categories>
        <category>iOS高级</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客网站Github、Hexo与Next</title>
    <url>/2018/02/13/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99Github%E3%80%81Hexo%E4%B8%8ENext/</url>
    <content><![CDATA[<p>温馨提示：由于本篇是后期整理的文章，一些在实际操作中遇到的错误可能会遗漏，但都是可以百度到的，当然，我也欢迎大家留言问题，以供完善记录。</p>
<p>效果展示：<a href="https://wuyubeichen.github.io/">梧雨北辰的博客</a></p>
<p>主要内容：</p>
<ol>
<li>准备工作</li>
<li>搭建博客(远程与本地)</li>
<li>发布博客<span id="more"></span></li>
<li>更换主题</li>
<li>博客网站美化</li>
<li>在不同电脑管理hexo博客</li>
<li>遇到问题</li>
<li>其他方案</li>
</ol>
<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1-了解Hexo"><a href="#1-了解Hexo" class="headerlink" title="1.了解Hexo"></a>1.了解Hexo</h2><p><a href="https://github.com/hexojs/hexo">Hexo</a>是高效的静态站点生成框架，她基于Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的标签插件来快速的插入特定形式的内容，而且相对于其他框架，Hexo在速度上也有很大优势。</p>
<h2 id="2-搭建Node-js环境"><a href="#2-搭建Node-js环境" class="headerlink" title="2. 搭建Node.js环境"></a>2. 搭建Node.js环境</h2><p>我们了解到Hexo基于Node.js的，那么我们搭建博客网站首先需要安装Node.js环境。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。<br>下载地址：<a href="http://nodejs.cn/download">http://nodejs.cn/download</a><br>测试安装：命令行使用node -v 、mpm -v，查看显示版本号即成功。</p>
<h2 id="3-安装Hexo博客框架工具"><a href="#3-安装Hexo博客框架工具" class="headerlink" title="3.安装Hexo博客框架工具"></a>3.安装Hexo博客框架工具</h2><p>Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在控制台下使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>若报错，请尝试在命令前加上sudo</p>
<h2 id="4-安装Git版本工具"><a href="#4-安装Git版本工具" class="headerlink" title="4.安装Git版本工具"></a>4.安装Git版本工具</h2><p>Git是目前世界上最流行的分布式版本控制系统，是的，没有之一。使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步。<br>下载地址：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>Windows系统需下载，Mac系统因为自带Git无需操作。<br>测试安装：git  - -version，查看显示版本号即成功。</p>
<h2 id="5-注册Github账号"><a href="#5-注册Github账号" class="headerlink" title="5.注册Github账号"></a>5.注册Github账号</h2><p>gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件。<br>注册地址：<a href="https://github.com/">https://github.com</a><br>注册流程：<a href="https://www.baidu.com/">https://www.baidu.com</a>，百度一下，你就知道啦。</p>
<p>注意：注册Github的时候一定要选择一个合适的名字，因为后来博客网站的域名也会用到这个名字。虽然Github用户名支持后期修改，但是还是会带来很多不必要的麻烦。github的使用在网上有很多教程，这里也就不再累述了。</p>
<h1 id="二、开始搭建博客"><a href="#二、开始搭建博客" class="headerlink" title="二、开始搭建博客"></a>二、开始搭建博客</h1><h2 id="1-开启GitHub-Pages服务"><a href="#1-开启GitHub-Pages服务" class="headerlink" title="1.开启GitHub Pages服务"></a>1.开启GitHub Pages服务</h2><p>搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-7ab2930306e23157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="Create a new repository"></p>
<p>这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：<a href="http://dreamcoffeezs.github.io/">https://UserName.github.io</a>的形式。<br>注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很冗长。</p>
<p>点击Create Repository之后，随后选择Setting进入设置，找到Github Pages如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-5e0f79282ae8140c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="Github Pages"></p>
<p>这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-75e5fceb23b7b85a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="屏幕快照 2018-02-07 下午2.45.24.png"></p>
<p>此时若再查看setting，我们会看到开启GitHub Pages之后得到的域名如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-685aeb93cbe41235.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p>
<p>现在，我们就可以使用<a href="https://dreamcoffeezs.github.io/">https://UserName.github.io</a>，访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然有点点丑，是吧)：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-e1b205aeaf1442b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p>
<h2 id="2-创建本地博客站点"><a href="#2-创建本地博客站点" class="headerlink" title="2.创建本地博客站点"></a>2.创建本地博客站点</h2><p>上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init  myHexoBlog       //myHexoBlog是项目名</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/1244124-8f17110330f1d146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>下面来测试本地博客站点，在本地博客根目录下使用控制台命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g  //g是generetor的缩写，生成博客</span><br><span class="line"></span><br><span class="line">hexo s  //s是server的缩写，启动服务</span><br></pre></td></tr></table></figure>
<p>此时打开浏览器，输入 <a href="http://localhost:4000/">http://localhost:4000/</a>，我们将会看到Hexo自带默认主题显示的博客样式如下(呃，是好看了那么一点点)：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-3e96fc83cdb07011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"></p>
<h2 id="3-同步Github-允许公共访问"><a href="#3-同步Github-允许公共访问" class="headerlink" title="3.同步Github,允许公共访问"></a>3.同步Github,允许公共访问</h2><p>在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。<br>首先找到我们的博客仓库，并拷贝仓库地址：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-467d7e51b973d1c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"></p>
<p>然后修改本地博客目录的配置：<br>修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-32a2a2a1b31ffc24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"><br>最后执行控制台命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git —save //安装部署插件</span><br><span class="line"></span><br><span class="line">hexo d //部署到github</span><br></pre></td></tr></table></figure>
<p>现在，我们再次访问链接：<a href="https://dreamcoffeezs.github.io/">https://userName.github.io</a>，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。</p>
<h1 id="三、发布博客"><a href="#三、发布博客" class="headerlink" title="三、发布博客"></a>三、发布博客</h1><p>激动人心的时候到了，终于可以发布自己的第一篇博客了。来尝试一下以下的步骤：<br>在本地博客文件夹根目录输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;我个人博客的第一篇博客，哈哈哈...&quot;</span><br><span class="line"></span><br><span class="line">hexo g   //生成网页</span><br><span class="line"></span><br><span class="line">hexo d  //部署到远端(github)</span><br></pre></td></tr></table></figure>
<p>查看我们本地的博客文件夹，将会看到我们创建一个条新的博客文章：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-214d608a5c3be183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p>
<p>现在打开我们的博客网站：<a href="http://username.github.io/">http://UserName.github.io</a>,会看到网页如下(显示可能会延时，不如先喝杯茶放松下吧)：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-cbdb263feca887f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"></p>
<p>这就是我们发布博客的方法啦，当然这里是为了演示，真正做的时候我们要找到_posts里的博客原文，先编辑内容，然后再部署到github上。</p>
<h1 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h1><p>现在我们已经看见个人博客的雏形了，但是现在的博客网页一点也不高大上。为了让它看起来更美观一些，我们可以为其更换主题（当然也可以自己在默认主题下自己编写美化博客界面，可是我还不太会前端，以后再突破吧）。这里以使用github上的next主题为例：</p>
<h2 id="1-创建next文件夹"><a href="#1-创建next文件夹" class="headerlink" title="1.创建next文件夹"></a>1.创建next文件夹</h2><p>切换到本地博客根目录下，在主题文件thems下创建一个新文件夹next存放即将下载的next主题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir themes/next</span><br></pre></td></tr></table></figure>
<h2 id="2-下载主题Next"><a href="#2-下载主题Next" class="headerlink" title="2.下载主题Next"></a>2.下载主题Next</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -s [https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest](https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest) | grep tarball_url | cut -d &#x27;&quot;&#x27; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure>
<p>此步骤可参考：<a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></p>
<p>下载成之后我们会看到next的主题已经存在thems里了如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-c1330c2ff817ab5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"></p>
<h2 id="3-修改博客配置文件，更换主题配置"><a href="#3-修改博客配置文件，更换主题配置" class="headerlink" title="3.修改博客配置文件，更换主题配置"></a>3.修改博客配置文件，更换主题配置</h2><p>修改博客根目录(不是next主题)下的_config.yml文件，搜索theme字段，并将其值修改为next。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-7f63babdcf1a854a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>然后在控制台下输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean  //清理缓存</span><br><span class="line"></span><br><span class="line">hexo g    //重新生成博客代码</span><br><span class="line"></span><br><span class="line">hexo d   //部署到本地</span><br></pre></td></tr></table></figure>
<p>再次打开我们的博客网站：<a href="https://dreamcoffeezs.github.io/">https://UserName.github.io</a>，将会看到更换主题后的博客网页如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-892e7a2bcd8b1f39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="屏幕快照 2018-02-07 下午3.50.50.png"></p>
<h1 id="五、博客网站美化"><a href="#五、博客网站美化" class="headerlink" title="五、博客网站美化"></a>五、博客网站美化</h1><p>终于我们的博客也算像点样子了，如果你和我一样是个完美主义者，那我们来继续美化它吧。这需要我们对博客中的各种配置进行修改。</p>
<p>首先说明一下：<strong>在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</strong></p>
<h2 id="1-站点配置："><a href="#1-站点配置：" class="headerlink" title="1.站点配置："></a>1.站点配置：</h2><p>在本地的博客根目录下找到_config.yml，用编辑器打开，如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1244124-e66dd07f4d17947a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"></p>
<p>这里可以修改博客网站的标题、描述，语言等属性，上面更换主题也是在这个文件中修改的。大家可以在这里稍作设置。</p>
<h2 id="2-主题设置"><a href="#2-主题设置" class="headerlink" title="2.主题设置"></a>2.主题设置</h2><p>关于博客主题的配置这块本来想着自己写下呢，却发现官方文档更加详尽。大家可以参考Next文档来学习。<br>文档地址：<a href="http://theme-next.iissnan.com/getting-started.html">http://theme-next.iissnan.com/getting-started.html</a><br>其他参考：<br><a href="https://www.jianshu.com/p/f054333ac9e6">hexo的next主题个性化教程</a><br><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#">打造个性超赞博客Hexo+Next+githubPages的超深度优化</a></p>
<h2 id="3-更多主题选择"><a href="#3-更多主题选择" class="headerlink" title="3.更多主题选择"></a>3.更多主题选择</h2><p>next只是众多Hexo主题的一种，还有很多优秀的主题可供我们选择，参考以上的更换及配置方法我们就可以进一步美化我们的个人博客网站了。<br>更多主题选择：<a href="https://github.com/hexojs/hexo/wiki/Themes">https://github.com/hexojs/hexo/wiki/Themes</a></p>
<h1 id="六、在不同电脑管理hexo博客"><a href="#六、在不同电脑管理hexo博客" class="headerlink" title="六、在不同电脑管理hexo博客"></a>六、在不同电脑管理hexo博客</h1><p>其实，这也是我在使用Hexo搭建博客遇到的一个问题，如果我们检查自己博客在Github上的文件就会发现，github仓库里的文件和我们本地博客站点的文件夹是不同的，确切来说是少了很多内容。如果我们想在不同的电脑上管理自己的博客，就必须有源文件存在远端供我们随时下载、然后修改后重新部署到远端。</p>
<p>我们要理解这样一个过程：hexo -d是把本地博客源文件生成的静态网页文件同步到github上，实现部署。但是博客网站的源文件仍需要我们自己保存。这里主要有两种思路可以选择：</p>
<p>1.在github存放我们博客静态网页文件的仓库里另建分支brach，单独用于存放源文件。<br>2.将本地博客文件存放在<a href="https://gitee.com/">码云</a>上。</p>
<p>这些都是关于git的操作，所以这里不用细说了。单对于这两种方法来说，我更倾向于第二种。因为毕竟这些都是我们搭建个人博客的源文件，将来还要在网站上发表文章，很多数据都在这里。使用码云我们可以创建私有仓库，将这些源文件私有存放更好一些，而且源文件和静态博客网页文件分开存放也避免使用分支频繁切换。</p>
<h1 id="七、遇到问题"><a href="#七、遇到问题" class="headerlink" title="七、遇到问题"></a>七、遇到问题</h1><p> ####1.修改了配置，网站没有变化<br> 这种情况，大多因为修改后配置后我们直接部署，没有执行hexo clean。<br> ####2.代码无法高亮显示<br> 在Hexo的next主题下，我们使用markDown编辑文章，如果代码无法高亮，这有可能是我们没有在标记语言后添加语言类型，我需要在添加代码片段的时候使用如下的样式：<br> <br> <img src="http://upload-images.jianshu.io/upload_images/1244124-77df0d562485c6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"><br> <br> 类似其他语言用：java、python…
 </p>
<h1 id="八、其他方案"><a href="#八、其他方案" class="headerlink" title="八、其他方案"></a>八、其他方案</h1><p> 还有一种搭建博客网站的方案是<a href="https://www.jekyll.com.cn/">Jekyll</a>，还没有细致研究呢，先记在这里为以后扩展思路。<br> <br> 终于写完了，祝新的一年越来越好，加油！- 2018-02-13</p>
]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS高级-静态库与动态库</title>
    <url>/2021/11/08/iOS%E9%AB%98%E7%BA%A7-%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<h4 id="一、库的概念总结"><a href="#一、库的概念总结" class="headerlink" title="一、库的概念总结"></a>一、库的概念总结</h4><p>所谓库(<code>Libary</code>)，其实就是代码共享的一种方式，将具备一定功能的模块代码整理起来，方便多次使用；</p>
<span id="more"></span>

<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/libray_classification.png" width="600" align=center/>


<h5 id="1-开源库："><a href="#1-开源库：" class="headerlink" title="1.开源库："></a>1.开源库：</h5><p>库中代码公开，可以方便使用者学习和根据自己的需求随意修改源代码；</p>
<h5 id="2-闭源库："><a href="#2-闭源库：" class="headerlink" title="2.闭源库："></a>2.闭源库：</h5><ol>
<li>闭源库中代码不公开，只能通过其公开的一些头文件来调用；</li>
<li>闭源库中代码库是已经编译好的二进制文件，程序的运行只需要在编译的时候链接(<code>Link</code>)一下就好了，不会浪费编译时间;</li>
<li>闭源库由于链接的方式不同，就分为了<code>静态库(静态链接)</code>和<code>动态库(动态链接)</code>；</li>
</ol>
<h5 id="3-封装库的作用"><a href="#3-封装库的作用" class="headerlink" title="3.封装库的作用"></a>3.封装库的作用</h5><ol>
<li><code>方便复用</code>：将不经常改动的功能但经常使用的代码封装成库；</li>
<li><code>编译效率</code>：动态库与静态库都是二进制文件，程序运行时只要链接这些文件即可，节约时间；</li>
<li><code>代码安全</code>：重要的代码不想公开，但又需要提供功能给别人使用，可以封装为闭源库；</li>
</ol>
<h5 id="4-Cocoapods里的动、静态库"><a href="#4-Cocoapods里的动、静态库" class="headerlink" title="4.Cocoapods里的动、静态库"></a>4.Cocoapods里的动、静态库</h5><p><code>静态库</code>与<code>动态库</code>都是闭源库(都是二进制的)，是看不到源码的, 只能看到头文件，但是<code>Cocoapods</code>集成后却是可以看见的，这是因为：</p>
<ol>
<li><code>Cocoapods</code>是集成了源码放到了新建的<code>Pods</code>工程里；</li>
<li><code>Pods</code>工程的<code>target</code>依赖了我们所有导入的第三方库, 然后主<code>App</code>对<code>Pods</code>工程中的这个<code>target</code> 的生成的<code>product</code>进行依赖, 形成了我们好像直接可以使用第三方库源码的错觉；</li>
<li>其实<code>App</code>最终链接的还是静态库或者动态库。</li>
</ol>
<p>可以在<code>Xcode</code>中查看到效果如下：<br><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/libray_app_cocoapods.png" width="800" align=center/></p>
<h4 id="二、库的格式类型"><a href="#二、库的格式类型" class="headerlink" title="二、库的格式类型"></a>二、库的格式类型</h4><p><code>iOS</code>中动态库与静态库的后缀类型有以下几种：</p>
<h5 id="1-后缀类型-a"><a href="#1-后缀类型-a" class="headerlink" title="1.后缀类型.a"></a>1.后缀类型<code>.a</code></h5><ol>
<li><code>.a</code>是是典型的静态库，是纯二进制文件，不能直接使用, 至少还要有<code>.h</code>文件配合；</li>
<li>创建<code>.a</code>静态库：<code>Xode -&gt; File -&gt; New -&gt; Project</code>中的<code>Static Library</code>即可新建；</li>
</ol>
<h5 id="2-后缀类型-framework"><a href="#2-后缀类型-framework" class="headerlink" title="2.后缀类型.framework"></a>2.后缀类型<code>.framework</code></h5><ol>
<li><code>Framework</code>只是一种打包方式，不代表库的<code>链接</code>特性，所以不能以此区分<code>静态库</code>和<code>动态库</code>；</li>
<li><code>Framework</code>经过打包，可以将代码文件、头文件、资源文件、说明文档等集中在一起，方便开发者使用；</li>
<li><code>Framework</code>既可以做成静态库, 也可以做成动态库，只需在创建的<code>Framework</code>工程中修改某个 <code>target</code> 的 <code>Build Setting</code>，切换<code>Mach-O Type</code>即可；</li>
</ol>
<h5 id="3-后缀类型tbd-之前叫-dylib"><a href="#3-后缀类型tbd-之前叫-dylib" class="headerlink" title="3. 后缀类型tbd(之前叫.dylib)"></a>3. 后缀类型<code>tbd(之前叫.dylib)</code></h5><p><code>tbd</code>全称是<code>text-based stub libraries</code>，本质上就是一个<code>YAML</code>描述的文本文件；</p>
<ol>
<li>用于记录动态库的一些信息，包括导出的符号、动态库的架构信息、动态库的依赖信息；</li>
<li>用于避免在真机开发过程中直接使用传统的<code>dylib</code>；</li>
<li>对于真机来说，由于动态库都是在设备上，在<code>Xcode</code>上使用基于<code>tbd</code>格式的伪<code>framework</code>可以大大减少<code>Xcode</code>的大小；</li>
</ol>
<h5 id="4-后缀类型XCFramework"><a href="#4-后缀类型XCFramework" class="headerlink" title="4.后缀类型XCFramework"></a>4.后缀类型<code>XCFramework</code></h5><p><code>XCFramework</code>是苹果官方在<code>2019</code>年推出的新的库类型，支持包含多平台架构。<code>XCFramework</code>需要<code>Xcode11</code>以上支持；</p>
<p><code>XCFramework</code>的优势：</p>
<ol>
<li><code>Framework</code>只能包含多个架构(如<code>x86_64</code>、<code>arm64e</code>等)，而<code>XCFramework</code>可以按照平台划分，包含相同架构的不同平台文件(如将<code>iOS</code>，<code>macOS</code>，<code>watchOS</code>等多平台的<code>arm64</code>架构合并在一起)；</li>
<li><code>XCFramework</code>可以包含其他第三方的库；</li>
<li><code>XCFramework</code>可以更好的支持<code>Mac Catalyst</code>和<code>ARM</code>芯片的<code>MacOS</code>；</li>
<li><code>XCFramework</code>可以不用设置复杂的头文件路径；</li>
<li><code>XCFramework</code>可以在库里面设置权限；</li>
<li><code>XCFramework</code>使用时，不需要再通过脚本去剥离不需要的架构体系。</li>
</ol>
<p>举例：<code>libpo</code>命令不支持将相同架构合并在一起，比如<code>iOS</code>的<code>arm64</code>的与<code>macOS</code>的<code>arm64</code>不能合并；</p>
<h4 id="二、区分静态库与动态库"><a href="#二、区分静态库与动态库" class="headerlink" title="二、区分静态库与动态库"></a>二、区分静态库与动态库</h4><p>静态库与动态库，都是以二进制形式提供代码复用的代码库；</p>
<h5 id="1-静态库"><a href="#1-静态库" class="headerlink" title="1.静态库"></a>1.静态库</h5><p>静态库是在<code>编译期</code>链接的库，需要链接到<code>Mach-O</code>文件里；</p>
<p>优点：</p>
<ol>
<li>静态库在链接时, 会被完整的复制到可执行文件中; </li>
<li>使用静态库时，目标程序没有外部依赖，直接就可以运行，效率较高；</li>
</ol>
<p>缺点：</p>
<ol>
<li>多次使用, 就会有多次的拷贝(<code>import</code>)，会使用目标程序的体积增大；</li>
<li>无法动态加载和更新，每次更新都需要重新编译一次；</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/libray_static_use_in_system.png" width="300" hegiht="300" align=center/>


<h5 id="2-动态库"><a href="#2-动态库" class="headerlink" title="2.动态库"></a>2.动态库</h5><p>动态库是在运行时才链接的库，链接时不会拷贝，系统只加载一次动态库；</p>
<p>优点：</p>
<ol>
<li>代码共享：同一份库可以被多个程序使用，节省内存易于维护；</li>
<li>减少可执行文件的体积：动态库不需要拷贝到目标程序中，不会影响目标程序的体积；</li>
<li>动态更新：动态库不绑定到可执行程序上，所以升级替换动态库很容易，不需要重新编译代码；类似<code>windows</code>和<code>linux</code>上面一般插件和模块机制都是这样实现的；</li>
</ol>
<p>缺点：</p>
<ol>
<li>动态载入会带来一部分性能损失(可以忽略不计）</li>
<li>动态库也会使得程序依赖于外部环境，如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行(<code>Linux lib not found</code>错误)；</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/libray_dynamic_use_in_system.png" width="300" hegiht="300" align=center/>


<p>**补充：**常见动态库有<code>Windows</code>下的<code>.dll</code>，<code>Linux</code>下的<code>.so</code>，<code>Mac</code>下的<code>.dylib/.tbd</code></p>
<h4 id="三、使用静态库与动态库"><a href="#三、使用静态库与动态库" class="headerlink" title="三、使用静态库与动态库"></a>三、使用静态库与动态库</h4><img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/libray_framework_use_in_ios.png" width="400" align=center/>

<h5 id="1-iOS8之前：iOS平台不允许使用动态库"><a href="#1-iOS8之前：iOS平台不允许使用动态库" class="headerlink" title="1. iOS8之前：iOS平台不允许使用动态库"></a>1. iOS8之前：iOS平台不允许使用动态库</h5><ol>
<li>所有的<code>ipa</code>都需要经过<code>App</code>的秘钥加密后才能使用，所以即使使用动态库也会因为签名不对无法加载(除非越狱和非<code>AppStoree</code>)；</li>
<li><code>iOS8</code>之前的所有应用都运行在沙盒中，不同程序间不可共享代码，而且<code>iOS</code>是单进程，所以共享库没有存在必要；</li>
<li>苹果禁止动态下载你代码，无法发挥动态库的优势；</li>
</ol>
<h5 id="2-iOS8之后：允许使用Embedded-Framework"><a href="#2-iOS8之后：允许使用Embedded-Framework" class="headerlink" title="2. iOS8之后：允许使用Embedded Framework"></a>2. iOS8之后：允许使用Embedded Framework</h5><ol>
<li>由于<code>iOS</code>主<code>App</code>需要和<code>Extension</code>共享代码，<code>Swift</code>语言机制也需要动态库，于是苹果后来提出了<code>Embedded Framework</code>；</li>
<li>这种动态库允许<code>APP</code>和<code>APP Extension</code>共享代码，但是这份动态库的生命被限定在一个<code>APP</code>进程内。简单点可以理解为被阉割的动态库；</li>
<li><code>iOS</code>中的<code>Embedded Framework</code>可以理解为独立的没有<code>main</code>函数的可执行文件。</li>
</ol>
<table>
<thead>
<tr>
<th>库</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Static Framework</code></td>
<td>用户可制作的静态库，相当于<code>头文件 + 资源文件 + 二进制代码</code>；</td>
</tr>
<tr>
<td><code>Dynamic Framework</code></td>
<td>1.具有所有动态库的特性，比如<code>UIKit.framework</code>，系统提供的<code>framework</code>都是动态库；<br>2.系统的<code>Framework</code>不需要拷贝到目标程序中;<br>3.系统的的动态库是给多个进程用的；</td>
</tr>
<tr>
<td><code>Embedded Framework</code></td>
<td>1.用户可以制作的<code>framework</code>动态库；<br>2.需要拷贝到<code>App</code>中，并在<code>Xcode</code>中进行动态库的配置：<code>TARGET</code> -&gt; <code>General</code> -&gt; <code>Frameworks,Libraries,and Enbedded Content </code>；<br>3.只具有部分动态特性，因为受到<code>iOS</code>平台限制(签名机制和沙盒机制限制)；<br>3.只是给单进程里多个可执行文件(<code>Extension</code>可执行文件和APP可执行文件)用；<br></td>
</tr>
</tbody></table>
<p>上面提到跟<code>Swift</code>也有原因，在<code>Swift</code>的项目使用外部代码，可选的方式只有两种：</p>
<ol>
<li>把代码拷贝到工程中；</li>
<li>使用动态库<code>Framework</code>；</li>
</ol>
<p><code>Swift</code>不支持使用静态库，这个问题的根本原因主要是：</p>
<ol>
<li><code>Swift runtime</code>没有被包含在<code>iOS</code>系统中，而是会打包进<code>App</code>中；</li>
<li>这也是造成<code>Swift App</code>体积大的原因，若使用静态库会导致最终的目标程序中包含重复的运行库；</li>
</ol>
<h5 id="3-“Do-Not-Embed”、“Embed-Sign”、“Embed-Without-Signing”-区别？"><a href="#3-“Do-Not-Embed”、“Embed-Sign”、“Embed-Without-Signing”-区别？" class="headerlink" title="3. “Do Not Embed”、“Embed &amp; Sign”、“Embed Without Signing” 区别？"></a>3. “Do Not Embed”、“Embed &amp; Sign”、“Embed Without Signing” 区别？</h5><ul>
<li><strong>Embed</strong>：嵌入，对于静态库选择<code>Do Not Embed</code>，动态链接选择<code>Embed</code>；</li>
<li><strong>Sign</strong>：签名，如果代码没有签名则选择<code>Embed &amp; Sign</code>，否则<code>Embed Without Signing</code>；</li>
</ul>
]]></content>
      <categories>
        <category>iOS高级</category>
      </categories>
      <tags>
        <tag>静态库</tag>
        <tag>动态库</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发-屏幕旋转适配</title>
    <url>/2019/02/24/iOS%E5%BC%80%E5%8F%91-%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%AC%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<p>前段时间抽空总结了一下<code>iOS</code>视频播放的基本用法，发现这其中还有一个我们无法绕过的问题，那就是播放界面的旋转与适配。的确，视频播放与游戏类型的<code>App</code>经常会遇到这个的问题。由于至今接手的项目中不常涉及这块知识疏于总结，在搜索了一些资料后也发现都很散乱，所以决定在这里重新整理一下。</p>
<span id="more"></span>

<p><strong>主要内容：</strong></p>
<ol>
<li>最让人纠结的三种枚举 </li>
<li>两种屏幕旋转的触发方式 </li>
<li>屏幕旋转控制的优先级 </li>
<li>开启屏幕旋转的全局权限 </li>
<li>开启屏幕旋转的局部权限(视图控制器) </li>
<li>实现需求：项目主要界面竖屏，部分界面横屏 </li>
<li>默认横屏无效的问题 </li>
<li>关于旋转后的适配问题 </li>
<li><code>APP</code>启动即全屏</li>
</ol>
<h4 id="一、最让人纠结的三种枚举"><a href="#一、最让人纠结的三种枚举" class="headerlink" title="一、最让人纠结的三种枚举"></a>一、最让人纠结的三种枚举</h4><p>刚开始接触屏幕旋转这块知识的时候，最让人抓狂的也许就是三种相关的枚举类型了，它们就是：</p>
<ol>
<li><code>UIDeviceOrientation</code></li>
<li><code>UIInterfaceOrientation</code></li>
<li><code>UIInterfaceOrientationMask</code></li>
</ol>
<h5 id="1-设备方向UIDeviceOrientation"><a href="#1-设备方向UIDeviceOrientation" class="headerlink" title="1.设备方向UIDeviceOrientation"></a>1.设备方向UIDeviceOrientation</h5><p><code>UIDeviceOrientation</code>：</p>
<ol>
<li>这是硬件设备(<code>iPhone</code>、<code>iPad</code>等)本身的当前旋转方向，共有<code>7</code>种(包括一种未知的情况)；</li>
<li>设备方向只能取值，不能设置；</li>
<li>判断设备的方向是以<code>Home</code>键的位置作为参照的；</li>
</ol>
<p><code>UIDeviceOrientation</code>在源码中的定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Portrait 表示纵向，Landscape 表示横向。</span></span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIDeviceOrientation</span>) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">UIDeviceOrientationUnknown</span>,</span><br><span class="line">     <span class="type">UIDeviceOrientationPortrait</span>,           <span class="comment">// Device oriented vertically, home button on the bottom</span></span><br><span class="line">     <span class="type">UIDeviceOrientationPortraitUpsideDown</span>, <span class="comment">// Device oriented vertically, home button on the top</span></span><br><span class="line">     <span class="type">UIDeviceOrientationLandscapeLeft</span>,      <span class="comment">// Device oriented horizontally, home button on the right</span></span><br><span class="line">     <span class="type">UIDeviceOrientationLandscapeRight</span>,     <span class="comment">// Device oriented horizontally, home button on the left</span></span><br><span class="line">     <span class="type">UIDeviceOrientationFaceUp</span>,             <span class="comment">// Device oriented flat, face up</span></span><br><span class="line">     <span class="type">UIDeviceOrientationFaceDown</span>            <span class="comment">// Device oriented flat, face down</span></span><br><span class="line">   &#125; __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>
<p>获取设备当前设备的旋转方向使用：<code>[UIDevice currentDevice].orientation</code>；</p>
<p>为了监测设备方向的变化，可以在<code>Appdelegate</code>文件中使用通知如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[[<span class="type">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="meta">@selector</span>(onDeviceOrientationDidChange)</span><br><span class="line">                     name:<span class="type">UIDeviceOrientationDidChangeNotification</span></span><br><span class="line">                                               object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[[<span class="type">UIDevice</span> currentDevice] beginGeneratingDeviceOrientationNotifications];</span><br><span class="line"></span><br><span class="line"> <span class="operator">-</span> (<span class="type">BOOL</span>)onDeviceOrientationDidChange&#123;</span><br><span class="line">    <span class="comment">//获取当前设备Device</span></span><br><span class="line">    <span class="type">UIDevice</span> <span class="operator">*</span>device <span class="operator">=</span> [<span class="type">UIDevice</span> currentDevice] ;</span><br><span class="line">    <span class="comment">//识别当前设备的旋转方向</span></span><br><span class="line">    <span class="keyword">switch</span> (device.orientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationFaceUp</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;屏幕幕朝上平躺&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationFaceDown</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;屏幕朝下平躺&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationUnknown</span>:</span><br><span class="line">            <span class="comment">//系统当前无法识别设备朝向，可能是倾斜</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;未知方向&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationLandscapeLeft</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;屏幕向左橫置&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationLandscapeRight</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;屏幕向右橫置&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationPortrait</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;屏幕直立&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">UIDeviceOrientationPortraitUpsideDown</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;屏幕直立，上下顛倒&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;無法识别&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-页面方向UIInterfaceOrientation"><a href="#2-页面方向UIInterfaceOrientation" class="headerlink" title="2.页面方向UIInterfaceOrientation"></a>2.页面方向UIInterfaceOrientation</h5><p><code>UIInterfaceOrientation</code>是开发的程序界面的当前旋转方向，它是可以设置的；</p>
<p><code>UIInterfaceOrientation</code>的源码定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// Note that UIInterfaceOrientationLandscapeLeft is equal to UIDeviceOrientationLandscapeRight (and vice versa).</span></span><br><span class="line">    <span class="comment">// This is because rotating the device to the left requires rotating the content to the right.</span></span><br><span class="line">    typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIInterfaceOrientation</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIInterfaceOrientationUnknown</span>               <span class="operator">=</span> <span class="type">UIDeviceOrientationUnknown</span>,</span><br><span class="line">        <span class="type">UIInterfaceOrientationPortrait</span>              <span class="operator">=</span> <span class="type">UIDeviceOrientationPortrait</span>,</span><br><span class="line">        <span class="type">UIInterfaceOrientationPortraitUpsideDown</span>    <span class="operator">=</span> <span class="type">UIDeviceOrientationPortraitUpsideDown</span>,</span><br><span class="line">        <span class="type">UIInterfaceOrientationLandscapeLeft</span>         <span class="operator">=</span> <span class="type">UIDeviceOrientationLandscapeRight</span>,</span><br><span class="line">        <span class="type">UIInterfaceOrientationLandscapeRight</span>        <span class="operator">=</span> <span class="type">UIDeviceOrientationLandscapeLeft</span></span><br><span class="line">    &#125; __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>
<p>值得注意的两个枚举：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIInterfaceOrientationLandscapeLeft</span> <span class="operator">=</span> <span class="type">UIDeviceOrientationLandscapeRight</span>, </span><br><span class="line"><span class="type">UIInterfaceOrientationLandscapeRight</span> <span class="operator">=</span> <span class="type">UIDeviceOrientationLandscapeLeft</span></span><br></pre></td></tr></table></figure>
<p>我们可以发现<code>设备方向</code>与<code>页面方向</code>的枚举值大多是可以对应上的。只有左右旋转的时候是<code>UIInterfaceOrientationLandscapeLeft</code> 与<code>UIDeviceOrientationLandscapeRight</code>相等，<strong>反之亦然，这是因为向左旋转设备需要旋转程序界面右边的内容。</strong></p>
<h5 id="3-页面方向UIInterfaceOrientationMask"><a href="#3-页面方向UIInterfaceOrientationMask" class="headerlink" title="3.页面方向UIInterfaceOrientationMask"></a>3.页面方向UIInterfaceOrientationMask</h5><p><code>UIInterfaceOrientationMask</code>是<code>iOS6</code>之后增加的一种枚举，其源码如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">typedef <span class="type">NS_OPTIONS</span>(<span class="type">NSUInteger</span>, <span class="type">UIInterfaceOrientationMask</span>) &#123;</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskPortrait</span> <span class="operator">=</span> (<span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="type">UIInterfaceOrientationPortrait</span>),</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskLandscapeLeft</span> <span class="operator">=</span> (<span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="type">UIInterfaceOrientationLandscapeLeft</span>),</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskLandscapeRight</span> <span class="operator">=</span> (<span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="type">UIInterfaceOrientationLandscapeRight</span>),</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskPortraitUpsideDown</span> <span class="operator">=</span> (<span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="type">UIInterfaceOrientationPortraitUpsideDown</span>),</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskLandscape</span> <span class="operator">=</span> (<span class="type">UIInterfaceOrientationMaskLandscapeLeft</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskAll</span> <span class="operator">=</span> (<span class="type">UIInterfaceOrientationMaskPortrait</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskLandscapeLeft</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskLandscapeRight</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskPortraitUpsideDown</span>),</span><br><span class="line">    <span class="type">UIInterfaceOrientationMaskAllButUpsideDown</span> <span class="operator">=</span> (<span class="type">UIInterfaceOrientationMaskPortrait</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskLandscapeLeft</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">&#125; __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>
<p>我们已经知道<code>UIDeviceOrientation</code>与<code>UIInterfaceOrientation</code>的区别在于：前者是真实的设备方向，后者是页面方向；</p>
<p>而<code>UIInterfaceOrientation</code>和<code>UIInterfaceOrientationMask</code>的区别是什么呢？其实观察源码，<strong>我们就会发现，这是一种为了支持多种UIInterfaceOrientation而定义的类型</strong>；</p>
<p>下面的示例将很好的说明这点：</p>
<p>在<code>iOS6</code>之后，控制单个界面的旋转我们通常是下面三个方法来控制：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">BOOL</span>)shouldAutorotate <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">6_0</span>) __TVOS_PROHIBITED;</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">6_0</span>) __TVOS_PROHIBITED;</span><br><span class="line"><span class="comment">// Returns interface orientation masks.</span></span><br><span class="line"><span class="comment">//方法3</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientation</span>)preferredInterfaceOrientationForPresentation <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">6_0</span>) __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>
<p>方法2：用于设置当前界面支持的所有方向，所以返回值是<code>UIInterfaceOrientationMask</code>，更加方便的表达支持多方向旋转的情况；</p>
<p>方法3：用于设置进入界面默认支持的方向，使用了返回值类型<code>UIInterfaceOrientation</code>，默认进入界面的方向是个确定的方向，所以使用<code>UIInterfaceOrientation</code>更适合；</p>
<h4 id="二、两种屏幕旋转的触发方式"><a href="#二、两种屏幕旋转的触发方式" class="headerlink" title="二、两种屏幕旋转的触发方式"></a>二、两种屏幕旋转的触发方式</h4><p>我们开发的<code>App</code>的，大多情况都是大多界面支持竖屏，几个特别的界面支持旋转横屏，两种界面相互切换，触发其旋转有两种情况：</p>
<h5 id="情况1：系统没有关闭自动旋转屏幕功能"><a href="#情况1：系统没有关闭自动旋转屏幕功能" class="headerlink" title="情况1：系统没有关闭自动旋转屏幕功能"></a>情况1：系统没有关闭自动旋转屏幕功能</h5><p>这种情况，支持旋转的界面跟随用户手持设备旋转方向自动旋转。我们需要在当前视图控制器中添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.决定当前界面是否开启自动转屏，如果返回NO，后面两个方法也不会被调用，只是会支持默认的方向</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">BOOL</span>)shouldAutorotate &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.返回支持的旋转方向</span></span><br><span class="line"><span class="comment">//iPad设备上，默认返回值UIInterfaceOrientationMaskAllButUpSideDwon</span></span><br><span class="line"><span class="comment">//iPad设备上，默认返回值是UIInterfaceOrientationMaskAll</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="type">UIInterfaceOrientationMaskAll</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.返回进入界面默认显示方向</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientation</span>)preferredInterfaceOrientationForPresentation &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="type">UIInterfaceOrientationPortrait</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="情况2：单个界面强制旋转"><a href="#情况2：单个界面强制旋转" class="headerlink" title="情况2：单个界面强制旋转"></a>情况2：单个界面强制旋转</h5><p>在程序界面，通过点击等方式切换到横屏(尤其是视频播放的情况)，有以下两种方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line"><span class="operator">-</span> (void)setInterfaceOrientation:(<span class="type">UIDeviceOrientation</span>)orientation &#123;</span><br><span class="line">      <span class="keyword">if</span> ([[<span class="type">UIDevice</span> currentDevice]   respondsToSelector:<span class="meta">@selector</span>(setOrientation:)]) &#123;</span><br><span class="line">          [[<span class="type">UIDevice</span> currentDevice] setValue:[<span class="type">NSNumber</span> numberWithInteger:orientation]     </span><br><span class="line">                                       forKey:@<span class="string">&quot;orientation&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="operator">-</span> (void)setInterfaceOrientation:(<span class="type">UIInterfaceOrientation</span>)orientation &#123;</span><br><span class="line">   <span class="keyword">if</span> ([[<span class="type">UIDevice</span> currentDevice] respondsToSelector:<span class="meta">@selector</span>(setOrientation:)]) &#123;</span><br><span class="line">            <span class="type">SEL</span> selector <span class="operator">=</span> <span class="type">NSSelectorFromString</span>(@<span class="string">&quot;setOrientation:&quot;</span>);</span><br><span class="line">            <span class="type">NSInvocation</span> <span class="operator">*</span>invocation <span class="operator">=</span> [<span class="type">NSInvocation</span> invocationWithMethodSignature:[<span class="type">UIDevice</span>     </span><br><span class="line">        instanceMethodSignatureForSelector:selector]];</span><br><span class="line">            [invocation setSelector:selector];</span><br><span class="line">            [invocation setTarget:[<span class="type">UIDevice</span> currentDevice]];</span><br><span class="line">            int val <span class="operator">=</span> orientation;</span><br><span class="line">            [invocation setArgument:<span class="operator">&amp;</span>val atIndex:<span class="number">2</span>];</span><br><span class="line">            [invocation invoke];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意：使用这两个方法的时候，也要确保<code>shouldAutorotate</code>方法返回<code>YES</code>，这样这两个方法才会生效。还要注意两者使用的参数类型不同；</p>
<h4 id="三、屏幕旋转控制的优先级"><a href="#三、屏幕旋转控制的优先级" class="headerlink" title="三、屏幕旋转控制的优先级"></a>三、屏幕旋转控制的优先级</h4><p>事实上，如果我们只用上面的方法来控制旋转的开启与关闭，并不能符合我们的需求，而且方法无效。这是因为我们忽略了旋转权限优先级的问题；</p>
<p>屏幕旋转的设置有<code>3</code>个地方：</p>
<ol>
<li><code>Xcode</code>的<code>General</code>设置；</li>
<li><code>info.plist</code>的设置；</li>
<li>通过代码设置；</li>
</ol>
<p>这么多的设置很是繁杂，但是这些其实都是在不同级别上实现旋转的设置，我们会遇到设置后无效的情况，这就很可能是被上一级别控制的原因；</p>
<p>这里先有个大致的了解，控制屏幕旋转优先级为：<strong>工程Target属性配置(全局权限) &#x3D; Appdelegate&amp;&amp;Window &gt; 根视图控制器&gt; 普通视图控制器。</strong></p>
<h4 id="四、开启屏幕旋转的全局权限"><a href="#四、开启屏幕旋转的全局权限" class="headerlink" title="四、开启屏幕旋转的全局权限"></a>四、开启屏幕旋转的全局权限</h4><p>这里我使用<code>全局权限</code>来描述这个问题可能不太准确，其实是设置我们的设备能够支持的方向有哪些，这也是实现旋转的前提；</p>
<p>开启屏幕旋转的全局权限有三种方法，包括通过<code>Xcode</code>直接配置的两种方法和代码控制的一种方法。</p>
<p>这三种方法作用相同，但是由于代码的控制在程序启动之后，所以也是最有效的。下面分别对三种方法的用法介绍：</p>
<h5 id="1-Device-Orientation属性配置"><a href="#1-Device-Orientation属性配置" class="headerlink" title="1.Device Orientation属性配置"></a>1.Device Orientation属性配置</h5><p>我们创建了新工程，<code>Xcode</code>就默认替我们选择了支持旋转的几个方向，这就是<code>Device Orientation</code>属性的默认配置。在<code>Xcode</code>中依次打开：<code>General</code>—&gt;<code>Deployment Info</code>—&gt;<code>Device Orientation</code>,我们可以看到默认支持的设备方向如下：</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/screen-rotation-device-orientation.png">

<p>可以发现，<code>UpsideDown</code>没有被默认支持，因为对于<code>iPhone</code>即使勾选也没有<code>UpSideDown</code>的旋转效果。我们可以在这里勾选或者取消以修改支持的旋转方向。如果是<code>iPad</code>设备勾选之后会同时支持四个方向；</p>
<p><strong>特殊情况：对于iPhone，如果四个属性我们都选或者都不选，效果和默认的情况一样。</strong></p>
<h5 id="2-Info-Plist设置"><a href="#2-Info-Plist设置" class="headerlink" title="2.Info.Plist设置"></a>2.Info.Plist设置</h5><p>其实我们设置了<code>Device Orientation</code>之后，再到<code>info.plist</code>中查看<code>Supported interface orientation</code>，我们会看到：</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/screen_rotation_info_plist.png">

<p>没错，此时<code>Supported interface orientation</code>里的设置和<code>UIDevice Orientation</code>的值一致的，并且我们在这里增加或者删除其中的值，<code>UIDevice Orientation</code>的值也会随之变化，两者属于同一种设置；</p>
<h5 id="3-Appdelegate-Window中设置"><a href="#3-Appdelegate-Window中设置" class="headerlink" title="3.Appdelegate&amp;&amp;Window中设置"></a>3.Appdelegate&amp;&amp;Window中设置</h5><p>正常情况下，我们的<code>App</code>从<code>Appdelegate</code>中启动，而<code>Appdelegate</code>所持有唯一的<code>Window</code>对象是全局的，所以在<code>Appdelegate</code>文件中设置屏幕旋转也是全局有效的。</p>
<p>下面的代码设置了只支持竖屏和右旋转：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientationMask</span>)application:(<span class="type">UIApplication</span> <span class="operator">*</span>)application supportedInterfaceOrientationsForWindow:(<span class="type">UIWindow</span> <span class="operator">*</span>)window &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  <span class="type">UIInterfaceOrientationMaskPortrait</span> <span class="operator">|</span> <span class="type">UIInterfaceOrientationMaskLandscapeLeft</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意：<strong>如果我们实现了Appdelegate的这一方法，那么我们的App的全局旋转设置将以这里的为准，即使前两种方法的设置与这里的不同。</strong></p>
<h4 id="五、开启屏幕旋转的局部权限-视图控制器"><a href="#五、开启屏幕旋转的局部权限-视图控制器" class="headerlink" title="五、开启屏幕旋转的局部权限(视图控制器)"></a>五、开启屏幕旋转的局部权限(视图控制器)</h4><p>在设置了全局所支持的旋转方向后，接着就开始设置具体的控制器界面了。我们在上面已经说明了关于旋转的优先级了。而这里主要涉及了三种视图控制器：</p>
<ol>
<li><code>UITabbarViewController</code></li>
<li><code>UINavigationBarController</code></li>
<li><code>UIViewController</code></li>
</ol>
<p>自全局权限开启之后，接下来具有最高权限的就是<code>Window</code>的根视图控制器<code>rootViewController</code>了。如果我们要具体控制单个界面<code>UIViewController</code>的旋转就必须先看一下根视图控制器的配置情况了；</p>
<p>当然，在一般情况下，我们的项目都是用<code>UITabbarViewController</code>作为<code>Window</code>的根视图控制器，然后管理着若干个导航控制器<code>UINavigationBarController</code>，再由导航栏控制器去管理普通的视图控制器<code>UIViewController</code>；</p>
<p><strong>若以此为例的话，关于旋转的优先级从高到低就是UITabbarViewController&gt;UINavigationBarController &gt;UIViewController了。如果具有高优先级的控制器关闭了旋转设置，那么低优先级的控制器是无法做到旋转的</strong>；</p>
<p>比如说我们设置要单个视图控制器可以自动旋转，这需要在视图控制器中增加<code>shouldAutorotate</code>方法返回<code>YES</code>或者<code>NO</code>来控制。但如果存在上层根视图控制器，而我们只在这个视图控制器中实现方法，会发现这个方法是不走的，因为这个方法被上层根视图控制器拦截了；</p>
<p>理解这个原理后，我们有两种方法实现自动可控的旋转设置：</p>
<h5 id="方法1：逐级设置各视图控制器，高优先级的视图控制器影响低优先级控制器"><a href="#方法1：逐级设置各视图控制器，高优先级的视图控制器影响低优先级控制器" class="headerlink" title="方法1：逐级设置各视图控制器，高优先级的视图控制器影响低优先级控制器"></a>方法1：逐级设置各视图控制器，高优先级的视图控制器影响低优先级控制器</h5><p>解决上述的问题我们需要设置<code>UITabbarViewController</code>如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否自动旋转</span></span><br><span class="line"><span class="operator">-</span>(<span class="type">BOOL</span>)shouldAutorotate&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.selectedViewController.shouldAutorotate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持哪些屏幕方向</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.selectedViewController supportedInterfaceOrientations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认方向</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientation</span>)preferredInterfaceOrientationForPresentation&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.selectedViewController preferredInterfaceOrientationForPresentation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置导航控制器<code>UINavigationController</code>如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否自动旋转</span></span><br><span class="line"><span class="comment">//返回导航控制器的顶层视图控制器的自动旋转属性，因为导航控制器是以栈的原因叠加VC的</span></span><br><span class="line"><span class="comment">//topViewController是其最顶层的视图控制器，</span></span><br><span class="line"><span class="operator">-</span>(<span class="type">BOOL</span>)shouldAutorotate&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.topViewController.shouldAutorotate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持哪些屏幕方向</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.topViewController supportedInterfaceOrientations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认方向</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIInterfaceOrientation</span>)preferredInterfaceOrientationForPresentation&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.topViewController preferredInterfaceOrientationForPresentation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们就应该明白了，其实就是高优先级的视图控制器要跟随低优先级控制器的旋转配置。这样就能够达到目的;</p>
<h5 id="方法2-另辟蹊径，使用模态视图"><a href="#方法2-另辟蹊径，使用模态视图" class="headerlink" title="方法2: 另辟蹊径，使用模态视图"></a>方法2: 另辟蹊径，使用模态视图</h5><p>使用模态视图可以不受这种根视图控制器优先级的限制。这个也很容易理解，模态弹出的视图控制器是隔离出来的，不受根视图控制的影响。具体的设置和普通视图器代码相同，这里就不累述了；</p>
<h4 id="六、实现需求：项目主要界面竖屏，部分界面横屏"><a href="#六、实现需求：项目主要界面竖屏，部分界面横屏" class="headerlink" title="六、实现需求：项目主要界面竖屏，部分界面横屏"></a>六、实现需求：项目主要界面竖屏，部分界面横屏</h4><p>这其实也是一个我们做屏幕旋转最常见的需求，在根据上面的讲述之后，我们实现这个需求会很容易，但是具体的实现却有着不同的思路，我在这里总结了两种方法：</p>
<h5 id="方法1：使用基类控制器逐级控制"><a href="#方法1：使用基类控制器逐级控制" class="headerlink" title="方法1：使用基类控制器逐级控制"></a>方法1：使用基类控制器逐级控制</h5><p>具体步骤：</p>
<ol>
<li>开启全局权限设置项目支持的旋转方向；</li>
<li>根据第五节中的方法1，自定义标签控制器和导航控制器来设置屏幕的自动旋转；</li>
<li>自定义基类控制器设置不支持自动转屏，并默认只支持竖屏；</li>
<li>对项目中需要转屏幕的控制器开启自动转屏、设置支持的旋转方向并设置默认方向；</li>
</ol>
<p><code>Demo1</code>链接: <a href="https://github.com/DreamcoffeeZS/Demo_TestRotatesOne.git">https://github.com/DreamcoffeeZS/Demo_TestRotatesOne.git</a></p>
<h5 id="方法2：Appdelegate增设旋转属性"><a href="#方法2：Appdelegate增设旋转属性" class="headerlink" title="方法2：Appdelegate增设旋转属性"></a>方法2：Appdelegate增设旋转属性</h5><p>具体步骤：</p>
<ol>
<li>在<code>Applegate</code>文件中增加一个用于记录当前屏幕是否横屏的属性；</li>
<li>需要横屏的界面，进入界面后强制横屏，离开界面时恢复竖屏；</li>
</ol>
<p><code>Demo2</code>链接: <a href="https://github.com/DreamcoffeeZS/Demo_TestRotatesTwo.git">https://github.com/DreamcoffeeZS/Demo_TestRotatesTwo.git</a></p>
<h4 id="七、默认横屏无效的问题"><a href="#七、默认横屏无效的问题" class="headerlink" title="七、默认横屏无效的问题"></a>七、默认横屏无效的问题</h4><p>在上面的项目中，我们可能会遇到一个关于默认横屏的问题，把它拿出来细说一下。</p>
<p>我们项目中有支持竖屏的<code>界面A</code>，也有支持横竖屏的<code>界面B</code>，而且<code>界面B</code>需要进入时就显示横屏。从<code>界面A</code>到<code>界面B</code>中，如果我们使用第五节中的方法1会遇到无法显示默认横屏的情况，因为没有旋转设备，<code>shouldAutorotate</code>就没被调用，也就没法显示我们需要的横屏。这里有两个解决方法：</p>
<h5 id="方法1：在自定义导航控制器中增加以下方法"><a href="#方法1：在自定义导航控制器中增加以下方法" class="headerlink" title="方法1：在自定义导航控制器中增加以下方法"></a>方法1：在自定义导航控制器中增加以下方法</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#pragma mark <span class="operator">-</span><span class="type">UINavigationControllerDelegate</span></span><br><span class="line"><span class="comment">//不要忘记设置delegate</span></span><br><span class="line"><span class="operator">-</span> (void)navigationController:(<span class="type">UINavigationController</span> <span class="operator">*</span>)navigationController didShowViewController:(<span class="type">UIViewController</span> <span class="operator">*</span>)viewController animated:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> presentViewController:[<span class="type">UIViewController</span> new] animated:<span class="type">NO</span> completion:<span class="operator">^</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="type">NO</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的缺点是，原理上利用弹出模态视图来调用转屏，造成切换界面的时候有闪烁效果，体验不佳。所以这里也只是提供一种思路，不推荐使用；</p>
<h5 id="方法2-在需要默认横屏的界面里设置，进入时强制横屏，离开时强制竖屏"><a href="#方法2-在需要默认横屏的界面里设置，进入时强制横屏，离开时强制竖屏" class="headerlink" title="方法2:在需要默认横屏的界面里设置，进入时强制横屏，离开时强制竖屏"></a>方法2:在需要默认横屏的界面里设置，进入时强制横屏，离开时强制竖屏</h5><p>关于这种使用，这个具体可以参考第五节中的<code>demo2</code></p>
<p><strong>注意：两种方法不可同时使用</strong></p>
<h4 id="八、关于旋转后的适配问题"><a href="#八、关于旋转后的适配问题" class="headerlink" title="八、关于旋转后的适配问题"></a>八、关于旋转后的适配问题</h4><p>屏幕旋转的实现会带来相应的<code>UI</code>适配问题，我们需要针对不同方向下的界面重新调整视图布局。首先我们要能够监测到屏幕旋转事件，这里分为两种情况：</p>
<h4 id="1-视图控制器UIViewController里的监测"><a href="#1-视图控制器UIViewController里的监测" class="headerlink" title="1.视图控制器UIViewController里的监测"></a>1.视图控制器UIViewController里的监测</h4><p>当发生转屏事件的时候，下面的<code>UIViewControoller</code>方法会监测到视图<code>View</code>的大小变化，从而帮助我们适配</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This method is called when the view controller&#x27;s view&#x27;s size is</span></span><br><span class="line"><span class="comment">changed by its parent (i.e. for the root view controller when its window rotates or is resized).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">If you override this method, you should either call super to</span></span><br><span class="line"><span class="comment">propagate the change to children or manually forward the </span></span><br><span class="line"><span class="comment">change to children.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="operator">-</span> (void)viewWillTransitionToSize:(<span class="type">CGSize</span>)size </span><br><span class="line">withTransitionCoordinator:(id <span class="operator">&lt;</span><span class="type">UIViewControllerTransitionCoordinator</span><span class="operator">&gt;</span>)coordinator <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">8_0</span>);</span><br></pre></td></tr></table></figure>

<p>从注释里可以看出此方法在屏幕旋转的时候被调用，我们使用时候也应该首先调用<code>super</code>方法，具体代码使用示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//屏幕旋转之后，屏幕的宽高互换，我们借此判断重新布局</span></span><br><span class="line"><span class="comment">//横屏：size.width &gt; size.height</span></span><br><span class="line"><span class="comment">//竖屏: size.width &lt; size.height</span></span><br><span class="line"><span class="operator">-</span> (void)viewWillTransitionToSize:(<span class="type">CGSize</span>)size withTransitionCoordinator:(id<span class="operator">&lt;</span><span class="type">UIViewControllerTransitionCoordinator</span><span class="operator">&gt;</span>)coordinator&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</span><br><span class="line">    <span class="keyword">if</span> (size.width <span class="operator">&gt;</span> size.height) &#123;</span><br><span class="line">        <span class="comment">//横屏设置，为防止遮挡键盘,调整输入视图的高度</span></span><br><span class="line">        <span class="keyword">self</span>.textView_height.constant <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//竖屏设置</span></span><br><span class="line">        <span class="keyword">self</span>.textView_height.constant <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-子视图横竖屏监测"><a href="#2-子视图横竖屏监测" class="headerlink" title="2.子视图横竖屏监测"></a>2.子视图横竖屏监测</h5><p>如果是类似于表视图的单元格，要监测到屏幕变化实现适配，我们需要用到<code>layoutSubviews</code>方法，因为屏幕切换横竖屏时会触发此方法，然后我们根据状态栏的位置就可以判断横竖屏了，代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)layoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">     <span class="comment">//通过状态栏电池图标判断横竖屏</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="type">UIApplication</span> sharedApplication].statusBarOrientation <span class="operator">==</span> <span class="type">UIInterfaceOrientationMaskPortrait</span>) &#123;</span><br><span class="line">        <span class="comment">//竖屏布局</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//横屏布局</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="九、APP启动即全屏"><a href="#九、APP启动即全屏" class="headerlink" title="九、APP启动即全屏"></a>九、APP启动即全屏</h4><p>有时项目需要从<code>App</code>启动就默认是横屏，这里有个很方便的方法，就是我们在<code>Device Orientation</code>属性配置里设置如下：</p>
<img src="https://cdn.jsdelivr.net/gh/wuyubeichen/cdn-resources/blog/screen_rotation_all_screen.png">

<p>但是只这样处理的话，会让项目只支持横屏，所以我们可以在<code>Appdelegate</code>里再次调整我们所支持的方向，方法已经说过，这里就不累述了;</p>
<h4 id="最后总结："><a href="#最后总结：" class="headerlink" title="最后总结："></a>最后总结：</h4><p>关于屏幕旋转的使用大致总结到这里了，如果存在疏漏与错误欢迎路过的朋友指正！谢谢~</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>UI问题</tag>
      </tags>
  </entry>
</search>
