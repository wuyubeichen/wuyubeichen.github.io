{"meta":{"title":"梧雨北辰的博客","subtitle":"天行健，君子以自强不息！","description":"iOS Developer, Beijing China","author":"Zhou Shuai","url":"https://wuyubeichen.github.io","root":"/"},"pages":[{"title":"About","date":"2025-04-05T09:43:37.376Z","updated":"2025-04-05T09:43:37.376Z","comments":true,"path":"about/index.html","permalink":"https://wuyubeichen.github.io/about/index.html","excerpt":"","text":"个人介绍现工作于北京，来自河南，毕业于河南财经政法大学 作为一名平凡的iOS开发者，正在自己喜欢的行业上继续努力，也希望会遇到更多志同道合的朋友。 给我留言欢迎大家给我留言，一起学习交流！"},{"title":"书单","date":"2025-04-05T09:43:37.376Z","updated":"2025-04-05T09:43:37.376Z","comments":false,"path":"books/index.html","permalink":"https://wuyubeichen.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2025-04-05T09:43:37.377Z","updated":"2025-04-05T09:43:37.377Z","comments":true,"path":"links/index.html","permalink":"https://wuyubeichen.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2025-04-05T09:43:37.377Z","updated":"2025-04-05T09:43:37.377Z","comments":false,"path":"repository/index.html","permalink":"https://wuyubeichen.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2025-05-04T18:28:50.731Z","updated":"2025-05-04T18:28:50.731Z","comments":false,"path":"categories/index.html","permalink":"https://wuyubeichen.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2025-05-04T18:28:22.973Z","updated":"2025-05-04T18:28:22.973Z","comments":false,"path":"tags/index.html","permalink":"https://wuyubeichen.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS高级-静态库与动态库","slug":"iOS高级-静态库与动态库","date":"2021-11-08T14:23:12.000Z","updated":"2025-05-03T16:22:24.790Z","comments":true,"path":"2021/11/08/iOS高级-静态库与动态库/","permalink":"https://wuyubeichen.github.io/2021/11/08/iOS%E9%AB%98%E7%BA%A7-%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/","excerpt":"一、库的概念总结所谓库(Libary)，其实就是代码共享的一种方式，将具备一定功能的模块代码整理起来，方便多次使用；","text":"一、库的概念总结所谓库(Libary)，其实就是代码共享的一种方式，将具备一定功能的模块代码整理起来，方便多次使用； 1.开源库：库中代码公开，可以方便使用者学习和根据自己的需求随意修改源代码； 2.闭源库： 闭源库中代码不公开，只能通过其公开的一些头文件来调用； 闭源库中代码库是已经编译好的二进制文件，程序的运行只需要在编译的时候链接(Link)一下就好了，不会浪费编译时间; 闭源库由于链接的方式不同，就分为了静态库(静态链接)和动态库(动态链接)； 3.封装库的作用 方便复用：将不经常改动的功能但经常使用的代码封装成库； 编译效率：动态库与静态库都是二进制文件，程序运行时只要链接这些文件即可，节约时间； 代码安全：重要的代码不想公开，但又需要提供功能给别人使用，可以封装为闭源库； 4.Cocoapods里的动、静态库静态库与动态库都是闭源库(都是二进制的)，是看不到源码的, 只能看到头文件，但是Cocoapods集成后却是可以看见的，这是因为： Cocoapods是集成了源码放到了新建的Pods工程里； Pods工程的target依赖了我们所有导入的第三方库, 然后主App对Pods工程中的这个target 的生成的product进行依赖, 形成了我们好像直接可以使用第三方库源码的错觉； 其实App最终链接的还是静态库或者动态库。 可以在Xcode中查看到效果如下： 二、库的格式类型iOS中动态库与静态库的后缀类型有以下几种： 1.后缀类型.a .a是是典型的静态库，是纯二进制文件，不能直接使用, 至少还要有.h文件配合； 创建.a静态库：Xode -&gt; File -&gt; New -&gt; Project中的Static Library即可新建； 2.后缀类型.framework Framework只是一种打包方式，不代表库的链接特性，所以不能以此区分静态库和动态库； Framework经过打包，可以将代码文件、头文件、资源文件、说明文档等集中在一起，方便开发者使用； Framework既可以做成静态库, 也可以做成动态库，只需在创建的Framework工程中修改某个 target 的 Build Setting，切换Mach-O Type即可； 3. 后缀类型tbd(之前叫.dylib)tbd全称是text-based stub libraries，本质上就是一个YAML描述的文本文件； 用于记录动态库的一些信息，包括导出的符号、动态库的架构信息、动态库的依赖信息； 用于避免在真机开发过程中直接使用传统的dylib； 对于真机来说，由于动态库都是在设备上，在Xcode上使用基于tbd格式的伪framework可以大大减少Xcode的大小； 4.后缀类型XCFrameworkXCFramework是苹果官方在2019年推出的新的库类型，支持包含多平台架构。XCFramework需要Xcode11以上支持； XCFramework的优势： Framework只能包含多个架构(如x86_64、arm64e等)，而XCFramework可以按照平台划分，包含相同架构的不同平台文件(如将iOS，macOS，watchOS等多平台的arm64架构合并在一起)； XCFramework可以包含其他第三方的库； XCFramework可以更好的支持Mac Catalyst和ARM芯片的MacOS； XCFramework可以不用设置复杂的头文件路径； XCFramework可以在库里面设置权限； XCFramework使用时，不需要再通过脚本去剥离不需要的架构体系。 举例：libpo命令不支持将相同架构合并在一起，比如iOS的arm64的与macOS的arm64不能合并； 二、区分静态库与动态库静态库与动态库，都是以二进制形式提供代码复用的代码库； 1.静态库静态库是在编译期链接的库，需要链接到Mach-O文件里； 优点： 静态库在链接时, 会被完整的复制到可执行文件中; 使用静态库时，目标程序没有外部依赖，直接就可以运行，效率较高； 缺点： 多次使用, 就会有多次的拷贝(import)，会使用目标程序的体积增大； 无法动态加载和更新，每次更新都需要重新编译一次； 2.动态库动态库是在运行时才链接的库，链接时不会拷贝，系统只加载一次动态库； 优点： 代码共享：同一份库可以被多个程序使用，节省内存易于维护； 减少可执行文件的体积：动态库不需要拷贝到目标程序中，不会影响目标程序的体积； 动态更新：动态库不绑定到可执行程序上，所以升级替换动态库很容易，不需要重新编译代码；类似windows和linux上面一般插件和模块机制都是这样实现的； 缺点： 动态载入会带来一部分性能损失(可以忽略不计） 动态库也会使得程序依赖于外部环境，如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行(Linux lib not found错误)； **补充：**常见动态库有Windows下的.dll，Linux下的.so，Mac下的.dylib/.tbd 三、使用静态库与动态库 1. iOS8之前：iOS平台不允许使用动态库 所有的ipa都需要经过App的秘钥加密后才能使用，所以即使使用动态库也会因为签名不对无法加载(除非越狱和非AppStoree)； iOS8之前的所有应用都运行在沙盒中，不同程序间不可共享代码，而且iOS是单进程，所以共享库没有存在必要； 苹果禁止动态下载你代码，无法发挥动态库的优势； 2. iOS8之后：允许使用Embedded Framework 由于iOS主App需要和Extension共享代码，Swift语言机制也需要动态库，于是苹果后来提出了Embedded Framework； 这种动态库允许APP和APP Extension共享代码，但是这份动态库的生命被限定在一个APP进程内。简单点可以理解为被阉割的动态库； iOS中的Embedded Framework可以理解为独立的没有main函数的可执行文件。 库 说明 Static Framework 用户可制作的静态库，相当于头文件 + 资源文件 + 二进制代码； Dynamic Framework 1.具有所有动态库的特性，比如UIKit.framework，系统提供的framework都是动态库；2.系统的Framework不需要拷贝到目标程序中;3.系统的的动态库是给多个进程用的； Embedded Framework 1.用户可以制作的framework动态库；2.需要拷贝到App中，并在Xcode中进行动态库的配置：TARGET -&gt; General -&gt; Frameworks,Libraries,and Enbedded Content ；3.只具有部分动态特性，因为受到iOS平台限制(签名机制和沙盒机制限制)；3.只是给单进程里多个可执行文件(Extension可执行文件和APP可执行文件)用； 上面提到跟Swift也有原因，在Swift的项目使用外部代码，可选的方式只有两种： 把代码拷贝到工程中； 使用动态库Framework； Swift不支持使用静态库，这个问题的根本原因主要是： Swift runtime没有被包含在iOS系统中，而是会打包进App中； 这也是造成Swift App体积大的原因，若使用静态库会导致最终的目标程序中包含重复的运行库； 3. “Do Not Embed”、“Embed &amp; Sign”、“Embed Without Signing” 区别？ Embed：嵌入，对于静态库选择Do Not Embed，动态链接选择Embed； Sign：签名，如果代码没有签名则选择Embed &amp; Sign，否则Embed Without Signing；","categories":[{"name":"iOS高级","slug":"iOS高级","permalink":"https://wuyubeichen.github.io/categories/iOS%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"静态库","slug":"静态库","permalink":"https://wuyubeichen.github.io/tags/%E9%9D%99%E6%80%81%E5%BA%93/"},{"name":"动态库","slug":"动态库","permalink":"https://wuyubeichen.github.io/tags/%E5%8A%A8%E6%80%81%E5%BA%93/"}]},{"title":"iOS高级-MachO符号分类","slug":"iOS高级-MachO符号分类","date":"2021-11-06T14:23:12.000Z","updated":"2025-05-03T16:23:07.125Z","comments":true,"path":"2021/11/06/iOS高级-MachO符号分类/","permalink":"https://wuyubeichen.github.io/2021/11/06/iOS%E9%AB%98%E7%BA%A7-MachO%E7%AC%A6%E5%8F%B7%E5%88%86%E7%B1%BB/","excerpt":"主要内容： 理解Symbol的概念 查看Symbol的方式 符号表Symbol Table","text":"主要内容： 理解Symbol的概念 查看Symbol的方式 符号表Symbol Table 重定位符号 全局符号与本地符号 导出符号 间接符号 弱符号 未初始化的全局符号 重新导出符号 Swift符号 一、理解Symbol的概念Mahc-O文件中的符号表Symbol Table，在Mach-O的整个链接和运行过程中起着重要作用； 1.符号的概念 Symbol：包含了名称(String)和类型等信息的数据结构，对应的是一个函数或者数据的地址； Symbol Table：保存符号信息的表； String Table：保存符号名称的表； Indirect Symbol Table：间接符号表，保存使用的外部符号，更准确一点就是使用的外部动态库的符号，它是Symbol Table的子集； 2.符号与链接链接的作用：链接器把多个.m文件编译产生的.o文件和(dylib、a、tbd）文件，合成一个Mach-O格式的可执行文件； 链接阶段的重要目的：符号解析和重定位 符号解析：将每个符号引用和对应的符号定义关联起来； 重定位：将每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用； 举例：二进制文件main中用到了二进制A中的函数a，则main就可以读取二进制A维护的符号表，进而在A找到函数a的实现； 3.符号与调试Xcode调试时，需要通过符号表将符号和源文件映射起来，而如果将调试符号裁剪掉(如图，将Deployment Postprocessing设置为YES)，就会使得断点失效。 注意：Release模式下是可以裁剪掉符号的，因为release模式下默认有dsym文件，调试器仍然可以从中获取到信息正常工作； 二、查看Symbol的方式1.使用MachOView查看使用MachOView查看Mach-O文件，效果如下： 2.使用objdump命令查看1234567891011// 查看重定位符号表objdump -—macho -—reloc .o文件// 查看符号表objdump --macho --syms .o文件或MachO文件// 查看导出符号objdump --macho --exports-trie .o文件或Mach-O文件// 查看间接符号表objdump --macho --indirect-symbols .o文件或Mach-O文件 三、符号表Symbol Table1.符号表在Mach-O中的位置下面的图，能够更加直观的展示符号表在Mach-O文件中的位置： 这里需要注意两个重要的Load Commands： LC_SYMTAB ：描述当前Mach-O中的符号表信息； LC_DYSYMTAB ：描述动态连接器使用其他符号表的信息； 其中LC_SYMTAB对应的数据结构symtab_command，其源码如下： 1234567891011121314 struct symtab_command &#123; // 共有属性。指明当前描述的加载命令，当前被设置为LC_SYMTAB uint32_t cmd ; // 共有属性。指明加载命令的大小，当前被设置为sizeof(symtab_command) uint32_t cmdsize; // 表示从文件开始到symbol table所在位置的偏移量。symbol table用[nlist]来表示 uint32_t symoff; // 符号表内符号的数量 uint32_t nsyms; // 表示从文件开始到string table所在位置的偏移量。 uint32_t stroff; // 表示string table大小(以byteカ单位) uint32_t strsize;&#125;;LC_SYMTAB的使用场景： 静态链接器、动态链接器链接文件时； 调试器寻找调试信息时； 2.符号表的源码分析Symbol Table中存储着符号，而Symbol则是一个数据结构，包含了名称(String)和类型等元数据，符号对应一个函数或者数据的地址，其在代码的定义如下： 123456789struct nlist_64 &#123; union &#123; uint32_t n_strx; /* index into the string table */ &#125; n_un; uint8_t n_type; /* type flag, see below */ uint8_t n_sect; /* section number or NO_SECT */ uint16_t n_desc; /* see &lt;mach-o/stab.h&gt; */ uint64_t n_value; /* value of this symbol (or stab offset) */&#125;; 代码中n_strx字段存储的就是符号在String Table的下标，符号表与符号的关系可用下图表示： 四、重定位符号概念理解： 在链接生成Mach-O可执行文件之前，编译生成.o目标文件会对符号进行归类，而其中使用到的外部符号会暂存到重定位符号表中； 等到真正链接生成Mach-O文件时，这些符号会统一存到Symbol Table中； 查看重定位符号的命令： 1objdump -—macho -—reloc .o目标文件 以下是验证过程： 1.准备测试文件创建一个main.m文件，写入代码如下： 123456#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; NSLog(@&quot;Hello world!&quot;); return 0;&#125; 使用命令分别生成.o目标文件与Mach-O可执行文件： 12xcrun clang -fmodules -c main.m -o main.o //得到目标文件xcrun clang main.o -o main //得到Mach-O可执行文件 2.对比__Text代码段使用objdump命令，分别查看目标文件与可执行文件中的__TEXT段，对比之下会发现：前者的符号调用callq _NSLog是没有地址的。 控制台中显示效果如下： 3.查看重定位符号表 4.重定位符号表中的字段说明 五、全局符号与本地符号概念理解： 全局符号：整个工程可见的符号；比如定义一个全局变量，所有文件都能访问到； 本地符号：只有当前文件可访问的符号，比如在当前文件中定义一个static修饰的变量； 查看符号的命令： 1objdump --macho --syms .o文件或Mach-O文件 1. 验证全局符号与本地符号创建一个main.m文件，写入代码如下： 123456789#import &lt;Foundation/Foundation.h&gt;int global_init_value = 10;static int static_init_value = 9;int main(int argc, const char * argv[]) &#123; NSLog(@&quot;%d&quot;, static_init_value); return 0;&#125; 使用命令生成可执行文件，并查看符号，效果如下： 第二列符号标签的含义： l代表本地符号； g代表全局符号； 第三列符号标签的含义，按照功能区分： f：File，文件； F：Function，方法； O： Data，数据； d： Debug，调试符号（链接过程中，可通过OTHER_LDFLAGS = -Xlinker -S参数隐藏)； ABS： Absolute； COM： Common； UND： 未定义； 2. 隐藏全局符号除了使用static修饰外，还有一种隐藏全局符号的方法，那就是使用__attribute__编译属性； 12__attribute__((visibility(&quot;default&quot;))) //默认__attribute__((visibility(&quot;hideen&quot;))) //隐藏 visibility：用于设置动态链接库中函数的可见性，将变量或函数设置为hidden，则该符号仅在本文件中可见，在其他库中则不可见； 测试使用__attribute__编译属性修改global_init_value变量： 1int global_init_value __attribute__((visibility(&quot;hidden&quot;))) = 10; 重新使用命令生成Mach-O可执行文件，并查看符号，效果如下： 六、导入符号和导出符号概念理解： 当前文件中使用到的外部变量、外部方法等，都属于其所属文件的导出符号； 导出符号一定是全局符号 ，将一个符号声明为全局，也就会默认成为导出符号，可供外界使用； OC中所有的符号都默认是导出符号； 以NSLog为例： 对于Foundation库来说，NSLog是提供外部使用的导出符号; 对于当前程序来说，NSLog使用的是从Foundation库中导入的符号; 查看导出符号的命令： 1objdump --macho --exports-trie .o文件或Mach-O文件 1.验证导出符号在工程中创建一个空类TestObject，并在main.m文件中写入代码如下： 123456789#import &lt;Foundation/Foundation.h&gt;int global_init_value = 10;static int static_init_value = 9;int main(int argc, const char * argv[]) &#123; NSLog(@&quot;%d&quot;, static_init_value); return 0;&#125; 因为这里涉及多个文件，所以，测试时可以使用上节讲到Mach-O终端调试方法； 查看导出符号，结果如下： 查看符号，结果如下：可以看出，导出符号正好与全局符号对应； 2.设置符号不导出全局符号不可剥离，但如果将其设置为不导出，符号就变成了本地符号类型了，不仅可以避免外界的错误使用，而且还可以脱符号处理，以减小Mach-O的体积； 为实现这一点，我们可以在自定义动态库时，在配置文件中增加链接器参数，具体如下： 123//示例：OTHER_LDFLAGS =$(inherited) -Xlinker -unexported_symbol -Xlinker +符号名OTHER_LDFLAGS =$(inherited) -Xlinker -unexported_symbol -Xlinker _OBJC_METACLASS_$_TestObjectOTHER_LDFLAGS =$(inherited) -Xlinker -unexported_symbol -Xlinker _OBJC_CLASS_$_TestObject 再次查看导出符号，已经没有了OC类的导出符号，控制台显示结果如下： 需要注意：由于OC是运行时语言，所以，不能直接使用visibility(&quot;hidden&quot;)； 3.查看Mach-O中使用的库以及符号信息，并生成文件在配置文件中，增加如下设置： 1OTHER_LDFLAGS =$(inherited) -Xlinker -S -Xlinker -map -Xlinker $&#123;SRCROOT&#125;/MachOTest_Symbol.text 运行工程后将生成的文件，文件中包含以下信息： 编译过程中生成的目标文件； 项目中使用的三方库； 项目中的Sections和Symbols等信息； 七、间接符号(Indirect Symbol)概念理解： 间接符号就是使用的外部符号，例如：使用的系统库、外部动态库符号； 间接符号表中保存当前可执行文件使用的其他的动态库的符号； 查看间接符号的命令： 1CMD = objdump --macho --indirect-symbols .o文件或Mach-O文件 验证间接符号，在main.m文件中写入代码如下： 12345#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; NSLog(@&quot;Hello World&quot;); return 0;&#125; 查看间接符号，效果如下：可以看到，NSLog就是间接符号，它属于Foundation动态库： adress：表示间接符号链接地址； name：符号名； 八、弱符号(Weak Symbol)Weak Reference Symbol: 表示此未定义符号是弱引用； 如果动态链接器找不到该符号的定义，则将其设置为0； 链接器会将此符号设置弱链接标志； Weak defintion Symbol: 表示此符号为弱定义符号 如果静态链接器或动态链接器为此符号找到另一个(非弱)定义，则弱定义将被忽略； 只能将合并部分中的符号标记为弱定义； 1.验证弱引用符号对于弱引用符号，更确切的理解是：如果未被定义(没有实现)，系统不会报错； 创建WeakImportSymbol.h/m文件，但只在其.h文件中定义一个没有实现体的弱引用方法： 1void weak_import_function(void) __attribute__((weak_import)); 然后，在main.m中增加如下的代码： 1234567#import &quot;WeakImportSymbol.h&quot;int main(int argc, char *argv[]) &#123; if (weak_import_function) &#123; weak_import_function(); &#125; return 0;&#125; 此时运行报错：Undefined symbol: _weak_import_function，因为链接时需要知道符号具体的地址在什么地方，否则就会提示错误； 解决方法：可以通过配置文件告诉编译器，这个符号是动态链接的，dyld运行时会自动查找； 于是，我们在配置文件中增加的配置如下： 12/// -U参数：告诉编译器该符号没有定义，需要动态查找OTHER_LDFLAGS =$(inherited) -Xlinker -U -Xlinker _weak_import_function Weak Reference Symbol的好处： 可以判断其他的库是否有这个符号，如果有这个符号就可以调用，否则就不调用； 可以将整个动态库文件声明成一个弱引用，也意味着如果你这个库没有导入的话，也不会报动态库找不到的错误； 2.验证弱定义符号创建WeakSymbol.h/m文件，增加代码如下： 12345678/// WeakSymbol.hint global_int_valuevoid weak_function(void);/// WeakSymbol.mvoid weak_function(void) &#123; NSLog(@&quot;weak_function&quot;);&#125; 然后，在main.m中增加如下的代码： 123456789101112#import &quot;WeakSymbol.h&quot;int global_int_value;void weak_function(void) &#123; NSLog(@&quot;weak_function_main&quot;);&#125;int main(int argc, char *argv[]) &#123; weak_function(); return 0;&#125; 此时运行报错：2 duplicate symbols for architecture x86_64； 解决方法：将任意一个文件中的全局变量声明为弱定义符号，这样在链接的过程 中，找到符号的另一个(非弱)定义，则弱定义将被忽略，从而避免符号重定义； 于是，我们修改WeakSymbol.h中的代码如下： 12int global_int_value __attribute__((weak));void weak_function(void) __attribute__((weak)); 运行工程后，成功打印结果：weak_function_main； 3.弱定义的本地符号将弱定义的符号声明成一个隐藏符号，它就会变成了一个弱定义的本地符号： 1void weak_hidden_function(void) __attribute__((weak, visibility(&quot;hidden&quot;))); 九、未初始化的全局符号(Common Symbol)概念理解：在定义时未初始化的全局符号； 符号作用： 在编译和链接的过程中，如果找到定义的符号，会自动将未定义符号删掉； 在链接过程中，链接器默认会把未定义符号变成强制定义的符号； 链接器设置： -d：强制定义Common Symbol； -commons：指定对待Common Symbol如何响应； 1.查看Common Symbol在main.m文件，写入代码如下： 12345int global_uninit_value;int main(int argc, char *argv[]) &#123; return 0;&#125; 查看符号表，控制台显示如下： 2.验证Common Symbol的作用在main.m文件，写入代码如下： 123456int global_init_value = 10;int global_init_value;int main(int argc, char *argv[]) &#123; return 0;&#125; 查看符号表，控制台显示如下： 十、重新导出符号概念理解： 重新导出符号就是通过对间接符号起别名的方式，将其变成导出符号； 重新导出之后的符号会放在本文件的导出符号表中，此时外界究竟可以查看使用这个符号了； 重新导出符号可以让一个符号可见，也可以让一个动态库可见； 举例：当程序链接动态库A，而动态库A又链接动态库B时，动态库B对于程序来说是不可见的，此时就可以使用重新导出符号的方式，使动态库B对程序可见； 2.验证重新导出NSLog其实，Foundation已经对NSLog做了重新导出，否则外界是无法使用的； 查看当前符号表，可以看到，NSLog对于当前工程来说还是一个未定义符号： 10000000000000000 *UND* _NSLog 现在，我们尝试自己重新导出NSLog符号，可以在配置文件中修改链接器中的参数-alias(起别名)，具体的配置如下： 1OTHER_LDFLAGS = $(inherited) -Xlinker -alias -Xlinker _NSLog -Xlinker ZS_NSLog 再次查看符号表，此时将看到ZS_NSLog成为导出符号，而且被标记为re-export； 十一、Swift符号创建一个SwiftSymbol.swift文件，在其中增加代码如下： 1234567private class PrivateObject &#123; func testMethod() &#123;&#125;&#125;public class PublicObject&#123; func testMethod() &#123;&#125;&#125; 查看当前符号表，控制台的效果如下： 12340000000100003bb0 l F __TEXT,__text _$s9MachOTest13PrivateObject33_C45E5A1705242B42AFDE1C0627FBB932LLC10testMethodyyF....0000000100003c80 g F __TEXT,__text _$s9MachOTest12PublicObjectC10testMethodyyF 结果分析： Swift文件产生的符号要比OC文件多出很多； 作为访问控制修饰符的public、private，分别对应着去全局符号(g)、本地符号(l)两种类型； 参考链接： MachView软件下载地址 文中相关Demo下载地址","categories":[{"name":"iOS高级","slug":"iOS高级","permalink":"https://wuyubeichen.github.io/categories/iOS%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"Mach-O","slug":"Mach-O","permalink":"https://wuyubeichen.github.io/tags/Mach-O/"}]},{"title":"iOS高级-MachO简单分析","slug":"iOS高级-MachO简单分析","date":"2021-11-04T14:23:12.000Z","updated":"2025-05-03T16:24:37.029Z","comments":true,"path":"2021/11/04/iOS高级-MachO简单分析/","permalink":"https://wuyubeichen.github.io/2021/11/04/iOS%E9%AB%98%E7%BA%A7-MachO%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/","excerpt":"主要内容： Mach-O的读写特性 查看命令文档 查看Mach-O","text":"主要内容： Mach-O的读写特性 查看命令文档 查看Mach-O 查看Symbol 配置Mach-O终端调试工具 一、Mach-O的读写特性Mach-O文件其实等价于： 文件配置 + 二进制代码； Mach-O文件是可读可写的，分析Mach-O文件的结构，可以解释程序运行中的许多问题； 1. Mach-O可读 Header：提供读取所需的身份信息，包括CPU类型、文件类型等； Load Commands：提供读取所需的文件的信息，以Load Command _TEXT为例，其中记录有 _TEXT代码段的起始位置； _TEXT代码段的大小； __TEXT,__DATA,符号表等，这些都是代码编译后的文件、数据存放的位置； 2.Mach-O可写 Mach-O能被执行是因为有签名，当我们修改了Mach-O文件，需要重新签名才能被苹果系统所接受； 破解软件都需要重新签名，正是这种原因； 二、查看命令文档有时候，需要在终端查询一些命令的具体用法，有两种方式(以查询nm命令为例)： 12man nm //推荐使用nm --help 当终端里显示nm的使用文档后，还可快速定位查询，以查询&quot;-a&quot;参数为例： /-a：快速匹配文档中-a的位置； n：向下定位-a位置； N：向上定位-a位置； q：退出文档查看； 三、查看Mach-O1.常用的查看命令1234567891011121314151617// 查看Header（$&#123;MACH_PATH&#125;表示Mach-O文件位置）objdump --macho --private-header $&#123;MACH_PATH&#125;// 查看Header 和 Load commandsobjdump --macho --private-headers $&#123;MACH_PATH&#125;// 查看__TEXTobjdump --macho -d $&#123;MACH_PATH&#125;// 查看符号表objdump --macho --syms $&#123;MACH_PATH&#125;// 查看导出符号objdump --macho --exports-trie $&#123;MACH_PATH&#125;// 查看间接符号表objdump --macho --indirect-symbols $&#123;MACH_PATH&#125; 2.测试查看命令为了避免过多文件的干扰，创建测试工程时，选择选择MacOS -&gt;Command Line Tool； 进入工程后，在main.m文件中写入代码如下： 123456789#import &lt;Foundation/Foundation.h&gt;int global_init_value = 10;static int static_init_value = 9;int main(int argc, const char * argv[]) &#123; NSLog(@&quot;%d&quot;, static_init_value); return 0;&#125; Xcode运行成功后，Products下的黑色文件即Mach-O可执行文件，如下图： 切换到可执行文件的目录下，使用objdump命令，查看Header: 1objdump --macho --private-header MachOTest 终端的打印结果如下： 使用objdump命令，查看Header以及Load commands： 1objdump --macho --private-headers MachOTest 终端的打印结果如下： 如上，我们在Mach-O文件的Load Commands中，可以找到程序入口函数以及依赖系统动态库的相关信息； 四、查看Symbol查看符号，除了可以使用objdump命令以外，还可以使用nm命令； 1.nm命令简介 nm是name的缩写，它显示指定文件中的符号信息，文件可以是对象文件、可执行文件或对象文件库； 如果文件中没有包含符号信息，nm报告该情况，但不把他解释为出错； nm缺省情况下报告十进制符号表示法下的数字值； 可以在终端使用man nm命令查看其具体用法： 12% man nmnm - display name list (symbol table) 即，nm是一个可以查看展示符号表信息的命令。 2.常用命令参数123456-a //显示符号表所有内容-p //不排序，显示符号本来的顺序-g //显示全局符号-r //逆转排序-u //显示未定义符号-m //显示N_SECT类型的符号(Mach-O符号)显示 3.使用举例使用nm命令，查看MachO可执行文件中的符号： 1nm -pa $&#123;MACH_PATH&#125; 终端的打印结果如下： 其中，第二列符号标签的含义如下： 注：标记①的Type，⼩写代表本地符号(local symbol); 五、配置Mach-O终端测试工具如上的调试过程十分繁琐，每次都需要等到程序运行完成，然后再切换到终端测试命令。为了更方便分析Mach-O，这里可以对工程进一步配置，使其运行时可直接将结果打印在终端里，具体的步骤如下： 1.测试将Xcode打印重定向到终端1.新建一个终端，使用tty命令获取其标识位置： 2.在Xcode中依次打开: Build Phases -&gt;Run Script，输入脚本命令使其能够在运行时打印： 3.运行工程，可以看到终端的打印如下 2.测试Xcode脚本命令执行项目中的代码虽然成功打印信息到终端，但是&quot;Hello world&quot;这段信息却是固定的，为了动态获取执行参数，我们可以自定义配置文件，并在其中定义如下的参数： 1DEBUG_URL = www.debug.com 然后，修改Run Script： 12echo &quot;Hello World&quot; &gt; /dev/ttys000echo $&#123;DEBUG_URL&#125; &gt; /dev/ttys000 终端打印结果： 12Hello Worldwww.debug.com 这里就说明，Xcode脚本执行与配置文件是在同一个环境下，我们可以做到将配置文件中的各种参数传递给脚本中使用。 3. 实现通过脚本命令打印符号信息在具备以上条件后，可以实现通过脚本命令打印符号信息到终端，具体的做法如下： 将执行命令的操作定义在一个脚本文件中，并起名xcode_run_cmd.sh，其中的关键代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142RunCMDToTTY() &#123; if [[ ! -e &quot;$TTY&quot; ]]; then EchoError &quot;=======================&quot; EchoError &quot;ERROR: Not Config tty to output.&quot; exit -1 fi if [[ -n &quot;$CMD&quot; ]]; then RunCommand &quot;$CMD&quot; $&#123;CMD_FLAG&#125; else EchoError &quot;========================&quot; EchoError &quot;ERROR:Failed to run CMD. THE CMD must not null&quot; fi&#125;EchoError() &#123; if [[ -n &quot;$TTY&quot; ]]; then echo &quot;$@&quot; 1&gt;&amp;2&gt;$TTY else echo &quot;$@&quot; 1&gt;&amp;2 fi&#125;RunCommand() &#123; if [[ -n &quot;$VERBOSE_SCRIPT_LOGGING&quot; ]]; then if [[ -n &quot;$TTY&quot; ]]; then echo &quot;♦ $@&quot; 1&gt;$TTY else echo &quot;♦ $*&quot; fi echo &quot;-----------------------------------------&quot; 1&gt;$TTY fi if [[ -n &quot;$TTY&quot; ]]; then echo `$@ &amp;&gt;$TTY` else &quot;$@&quot; fi return $?&#125;RunCMDToTTY 然后，在配置文件里增加三个参数：CMD，CMD_FLAG，TTY，即需要在.xcconfig中进行定义: 12345678910111213// Config-TestProject.debug.xcconfig// DEBUG_URL = www.debug.com// MACHO_PATH：Mach-O文件路径，即可执行文件路径，这里用到了环境变量来表示具体路径// TTY = 终端位置标识// CMD：运行命令// CMD_FLAG = 命令参数MACHO_PATH = $&#123;BUILD_DIR&#125;/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)/$&#123;PRODUCT_NAME&#125;.app/$&#123;PRODUCT_NAME&#125;TTY = /dev/ttys000CMD = nmCMD_FLAG = -pa $&#123;MACHO_PATH&#125; 配置完成后的工程如下： 最后，我们需要更改Run Script指令，使其执行脚本文件： 此时，再次运行项目，就可以直接在控制台看到使用nm命令分析得到的Mach-O信息了，而且我们可以更换CMD，CMD_FLAG参数，用以调试更多的其他命令。 参考链接 文中演示使用的Demo仓库","categories":[{"name":"iOS高级","slug":"iOS高级","permalink":"https://wuyubeichen.github.io/categories/iOS%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"Mach-O","slug":"Mach-O","permalink":"https://wuyubeichen.github.io/tags/Mach-O/"}]},{"title":"iOS高级-MachO文件结构","slug":"iOS高级-MachO文件结构","date":"2021-11-03T14:57:35.000Z","updated":"2025-05-03T16:24:41.541Z","comments":true,"path":"2021/11/03/iOS高级-MachO文件结构/","permalink":"https://wuyubeichen.github.io/2021/11/03/iOS%E9%AB%98%E7%BA%A7-MachO%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","excerpt":"主要内容： 理解可执行文件 理解Mach-O文件 Mach-O文件结构","text":"主要内容： 理解可执行文件 理解Mach-O文件 Mach-O文件结构 Mach Header Load Commands Data 理解大小端模式 理解通用二进制文件 一、理解可执行文件1.可执行文件 进程，其实就是可执行文件在内存中加载得到的结果； 可执行文件必须是操作系统可理解的格式，而且不同系统的可执行文件的格式也是不同的； 2.不同平台的可执行文件 Linux：ELF文件 Windows：PE32／PE32+文件 OS和iOS：Mach-O(Mach Object)文件 二、理解Mach-O文件作为iOS，iPadOS、macOS平台的可执行文件格式，Mach-O文件涉及App启动运行、bitcode分析、 crash符号化等诸多多个功能： 1. Mach-O文件 Mach-O文件是iOS，iPadOS、macOS平台的可执行文件格式。对应系统通过应用二进制接口(application binary interface，缩写为ABI)来运行该格式的文件； Mach-O格式用来替代BSD系统中的a.out格式，保存了在编译和链接过程中产生的机器代码和数据，从而为静态链接和动态链接的代码提供单一文件格式。 Mach-O提供了更强的扩展性，以及更快的符号表信息访问速度； 2.Mach-O格式的常见文件类型 Executable：可执行文件(.out .o)； Dylib：动态链接库； Bundle：不能被链接，只能在运行时使用dlopen()加载； Image：包含Executable、Dylib和Bundle； Framework：包含Dylib、资源文件和头文件的文件夹； 三、Mach-O文件结构1.查看Mach-O的两种方法 使用MachOView软件，可直接查看MachO文件的结构； 使用终端命令objdump； 2.查看Mach-O文件结构使用MachOView查看Mach-O，效果如下： Mach-O文件中包含三个主要的部分： Header：头部，描述CPU类型、文件类型、加载命令的条数大小等信息； Load Commands：加载命令，其条数和大小已经在header中被提供； Data：数据段； 其他的信息还有： Dynamic Loader Info：动态库加载信息 Function Starts：入口函数 Symbol Table：符号表 Dynamic Symbol Table： 动态库符号表 String Table：字符串表 四、Mach Header(可执行文件头)1.功能总结 Header是链接器加载时最先读取的内容，因为它决定了一些基础架构、系统类型等信息； Header包含整个Mach-O文件的关键信息，如CPU类型、文件类型、加载命令的条数大小等信息，使得系统能够迅速定位Mach-O文件的运行环境； Header针对32位和64位架构的CPU，分别对应mach_header和mach_header_64的结构体； 2.源码分析Header被定义在loader.h文件中，具体代码如下： 12345678910struct mach_header_64 &#123; uint32_t magic; // 32位或者64位，系统内核用来判断是否是mach-o格式 cpu_type_t cputype; // CPU架构类型，比如ARM cpu_subtype_t cpusubtype; // CPU的具体类型，例如arm64、armv7 uint32_t filetype; // mach-o文件类型, 可执行文件、目标文件或者静态库和动态库 uint32_t ncmds; // LoadCommands加载命令的条数（加载命令紧跟header之后） uint32_t sizeofcmds; // 全部LoadCommands加载命令的大小 uint32_t flags; // 标志位标识二进制文件支持的功能，主要是和系统加载、链接有关 uint32_t reserved; // 保留字段(相比于32位多出的字段) &#125;; 由于可执行文件、目标文件或者静态库和动态库等都是Mach-O格式，所以才需要filetype来说明。常用的文件类型有以下几种： 12345#define MH_OBJECT 0x1 /* 目标文件*/#define MH_EXECUTE 0x2 /* 可执行文件*/#define MH_DYLIB 0x6 /* 动态库*/#define MH_DYLINKER 0x7 /* 动态链接器*/#define MH_DSYM 0xa /* 存储二进制文件符号信息，用于debug分析*/ 3.MachOView演示 五、Load Commands1.功能总结 Load Commands是加载命令的列表，用于描述Data在二进制文件和虚拟内存中的布局信息； Load Commands记录了很多信息，例如动态链接器的位置、程序的入口、依赖库的信息、代码的位置、符号表的位置等； Load commands由内核定义，不同版本的command数量不同，其条数和大小记录在header中； Load commands的type是以LC_为前缀常量，譬如LC_SEGMENT、LC_SYMTAB等； 2..代码分析Load Command被定义在loader.h文件中，具体代码如下： 1234struct load_command &#123; uint32_t cmd; /* 加载命令的类型 */ uint32_t cmdsize; /* 加载命令的大小 */&#125;; 每个Load Command都有独立的结构，但是所有结构的前两个字段是固定的。比如LC_SEGMENT_64，这是一个读取segment、section有关命令，具体代码如下： 12345678910111213struct segment_command_64 &#123; /* for 64-bit architectures */ uint32_t cmd; // 表示加载命令类型 uint32_t cmdsize; // 表示加载命令大小（还包括了紧跟其后的nsects个section的大小） char segname[16]; // 16个字节的段名字 uint64_t vmaddr; // 段的虚拟内存起始地址 uint64_t vmsize; // 段的虚拟内存大小 uint64_t fileoff; // 段在文件中的偏移量 uint64_t filesize; // 段在文件中的大小 vm_prot_t maxprot; // 段页面所需要的最高内存保护（4 = r，2 = w，1 = x） vm_prot_t initprot; // 段页面初始的内存保护 uint32_t nsects; // 段中section数量 uint32_t flags; // 标志位&#125;; 六、Data1.功能总结 Data中存储了实际的数据与代码，主要包含方法、符号表、动态符号表、动态库加载信息(重定向、符号绑定等)等； Data中的排布完全按照Load Command中的描述； Data由Segment（段）和 Section （节）的方式来组成，通常，Data拥有多个segment，每个segment可以有零到多个section节； 不同的segment都有一段虚拟地址映射到进程的地址空间； 几乎所有的Mach-O文件都包含3个segment __TEXT：代码段，只读可执行，存储函数的二进制代码(__text)，常量字符串(__cstring)，OC的类/方法名等信息 __DATA：数据段， 可读可写，存储OC的字符串(__cfstring)，以及运行时的元数据：class/protocol/method，以及全局变量，静态变量等； __LINKEDIT：只读，存储启动App需要的信息，如 bind &amp; rebase 的地址、函数的名称和地址等信息​； 2.源码分析在Data区中，Section占了很大的比例，而且在Mach-O中集中体现在__TEXT和__DATA两段里。 Section被定义在loader.h文件中，具体代码如下： 1234567891011121314struct section_64 &#123; /* for 64-bit architectures */ char sectname[16]; // 当前section的名称 char segname[16]; // section所在的segment名称 uint64_t addr; // 内存中起始位置 uint64_t size; // section大小 uint32_t offset; // section的文件偏移 uint32_t align; // 字节大小对齐 uint32_t reloff; // 重定位入口的文件偏移 uint32_t nreloc; // 重定位入口数量 uint32_t flags; // 标志，section的类型和属性 uint32_t reserved1; // 保留（用于偏移量或索引） uint32_t reserved2; // 保留（用于count或sizeof） uint32_t reserved3; // 保留&#125;; 七、理解大小端模式分析Mach-O文件时，经常会看到内存地址相关的内容，这里就涉及到了大小端模式的概念； 小端模式：数据的低字节，保存在内存的低地址； 大端模式：数据的低字节，保存在内存的高地址； iOS设备的处理器是基于ARM架构的，默认是采用小端模式(低字节放低位）读取数据的，而网络和蓝牙传输数据通常是用的大端模式(低字节放高位)： 下面以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value 1234567Little-Endian: 低地址存放低位，如下：低地址 ------------------&gt; 高地址0x78 0x56 0x34 0x12Big-Endian: 低地址存放高位，如下：低地址 -----------------&gt; 高地址0x12 0x34 0x56 0x78 内存地址 小端模式存放内容 大端模式存放内容 0x4000 0x78 0x12 0x4001 0x56 0x34 0x4002 0x34 0x56 0x4003 0x12 0x78 八、理解通用二进制文件1.基本概念 通用二进制文件的存储结构，是将多种架构的Mach-O文件打包在一起，CPU在读取该二进制文件时可以自动检测并选用合适的架构； 通用二进制文件会同时存储多种架构，所以比单一架构的二进制文件大很多，会占用大量的磁盘空间。但由于系统运行时会自动选择最合适的，不相关的架构代码，不会占用内存空间，所以执行效率提高了； 通用二进制格式也被称为胖二进制格式； 2.通用二进制格式分析通用二进制格式的定义在&lt;mach-o/fat.h&gt;中: 下载xnu后，依次在 xnu -&gt; EXTERNAL_HEADERS -&gt;mach-o中找到该文件。 通用二进制文件有两个重要结构体：fat_header、fat_arch； 两个结构体的定义如下： 123456789101112131415161718192021/* - magic：可以让系统内核读取该文件时知道是通用二进制文件 - nfat_arch：表明下面有多个fat_arch结构体，即通用二进制文件包含多少个Mach-O */struct fat_header &#123; uint32_t magic; /* FAT_MAGIC */ uint32_t nfat_arch; /* number of structs that follow */&#125;;/* fat_arch是描述Mach-O - cputype 和 cpusubtype：说明Mach-O适用的平台 - offset（偏移）、size（大小）、align（页对齐）描述了Mach-O二进制位于通用二进制文件的位置 */struct fat_arch &#123; cpu_type_t cputype; /* cpu specifier (int) */ cpu_subtype_t cpusubtype; /* machine specifier (int) */ uint32_t offset; /* file offset to this object file */ uint32_t size; /* size of this object file */ uint32_t align; /* alignment as a power of 2 */&#125;; 参考链接 xnu Mach-O官方源码","categories":[{"name":"iOS高级","slug":"iOS高级","permalink":"https://wuyubeichen.github.io/categories/iOS%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"Mach-O","slug":"Mach-O","permalink":"https://wuyubeichen.github.io/tags/Mach-O/"}]},{"title":"iOS高级-编译原理","slug":"iOS高级-编译原理","date":"2021-11-02T14:54:10.000Z","updated":"2025-05-03T16:24:28.557Z","comments":true,"path":"2021/11/02/iOS高级-编译原理/","permalink":"https://wuyubeichen.github.io/2021/11/02/iOS%E9%AB%98%E7%BA%A7-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","excerpt":"主要内容: 理解C、C++以及OC的关系 编译型语言与解释型语言 编译器LLVM与CLang","text":"主要内容: 理解C、C++以及OC的关系 编译型语言与解释型语言 编译器LLVM与CLang 理解iOS编译流程 预处理 编译 汇编 链接 一、理解C、C++以及OC的关系1.C语言 C语言是一门面向过程的计算机编程语言，既可用于系统软件开发，也适用于应用软件开发； C语言编译器普遍存在于各种不同的操作系统中，例如Microsoft Windows,Mac OS X, Linux, Unix等； C语言的设计影响了众多后来的编程语言，例如C++、Objective-C、Java、C#等； 2.C++语言 兼容了C语言面向过程特点，但又进行了扩充和完善； 作为一种面向对象的语言，具有封装、多继承、多态等特性； 3.Objective-C语言 扩展了C语言的能力，使其具备面向对象设计的能力，相当于C的超集； OC代码中也可以有C和C++语句，它可以调用C函数，也可以通过C++对象访问方法； 4.OC与C++的比较 OC与C++都是从C语言演变而来面向对象设计语言，也都兼容标准的C语言；但它们属于不同的面向对象学派； 两者最大的不同在于：OC提供了运行时的动态绑定机制，而C++是编译时静态绑定，并通过嵌入类和虚函数来模拟实现； OC在编译阶段降低了编译要求提高了灵活性，而C++则是提高了编译要求，在编译过程中就发现更多的潜在错误，在运行前改正，降低了灵活性； 以下面的代码为例，在编译期间，C++认为是错误的，而OC则认为没有问题： 1NSString *test =(id) [[NSArray alloc] init]; OC与C++在使用细节上的不同如下： 定型：OC是动态定型，可以允许根据字符串名字来访问方法和类，还可以动态链接和添加类； 继承：OC不支持多继承，C++支持多继承； 函数调用：OC通过消息传递实现函数调用，而C++直接进行函数调用； 接口：OC采用Protocol形式来定义接口，而C++采用虚函数形式来定义接口； 重载：OC不允许同一个类中两个方法有相同的名字(即使只是参数类型不同)，但C++可以； 二、编译型语言与解释型语言Objective-C属于编译型语言，这是为了保证iPhone的执行效率； 1.编译型语言 程序运行前，必须先通过编译器生成机器码，机器码直接通过CPU执行，运行时不需要重新翻译； 程序执行效率高，但依赖编译器，调试周期长、跨平台性差些； 代表语言：C、C++、OC等； 2.解释型语言 程序运行前，不需要进行编译，而是以文本方式存储程序代码，运行时需要解释器解释后再运行； 程序执行效率低下，但是程序具有动态性，运行后也可以随时增加和更新代码来改变程序逻辑； 代表语言：Javascript、Python等； 三、编译器LLVM与CLang1.编译器概念：把一种编程语言(原始语言)转换为另一种编程语言(目标语言)的程序; 大多数编译器都分前端和后端两部分： 前端：负责词法分析、语法分析、生成中间代码； 后端：以中间代码作为输入，进行与架构无关的代码优化，接着针对不同架构生成不同的机器码； 补充： 前后端以中间代码作为媒介，使得前后端可以独立的变化，互不影响； 这样的好处在于：新增一门语言只需要修改前端，而新增一种CPU架构只需要修改后端即可； 2.LLVM与ClangLLVM是苹果当前使用的编译器： LLVM是一套编译器基础设施项目，为自由软件，以C++写成，包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端； 基于 LLVM 衍生出了一些强大的子项目，比如：Clang 和 LLDB。 CLang基于LLVM，是一个高度模块化开发的轻量级编译器； CLang主要来自苹果电脑的支持，同时支持C、Objective-C以及C++； CLang用于替代Xcode5版本前使用的GCC，编译速度提高了3倍： 3.理解iOS中的编译器 在iOS开发中，通常LLVM被认为是编译器的后端，而Clang是作为编译器的前端； 二者以 IR（中间代码）作为媒介，这样前后端分离，使得前后端可以独立的变化，互不影响； C 语言家族的前端是 clang，swift 的前端是 swiftc，但二者的后端都是 LLVM； 四、理解iOS编译流程1.编译流程图LLVM的编译过程相当复杂，iOS代码运行需要经过：预处理、编译、汇编、链接四个关键阶段，具体的流程如下图： 2.准备测试文件以OC语言为例，详细分析代码的编译流程，准备一个main.m文件的内容如下： 1234567#import &lt;Foundation/Foundation.h&gt;/// 增加注释：宏定义Name#define Name &quot;梧雨北辰&quot;int main(int argc, const char * argv[]) &#123; NSLog(@&quot;Hello, %s&quot;, Name); return 0;&#125; 五、预处理(Prepressing)1.主要功能 替换宏：替换代码中各种宏定义，如定义的常量、函数等； 导入头文件：将#include包含的文件插入到该指令位置等； 清理注释：删除所有注释：// 、/* */等； 条件编译：处理#if、#ifdef，#endif等类似的条件编译； 添加行号和文件名标识：以便于编译时编译器能够显示警告和错误的所在行号； 2.查看预处理结果使用xcrun命令，在终端执行预处理操作： 1xcrun clang -E main.m 终端显示效果如下： 12345678910111213# 1 &quot;main.m&quot;# 1 &quot;&lt;built-in&gt;&quot; 1...# 1 &quot;/Applications/Xcode13.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h&quot; 1 3# 193 &quot;/Applications/Xcode13.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h&quot; 2 3# 2 &quot;main.m&quot; 2int main(int argc, const char * argv[]) &#123; NSLog(@&quot;Hello, %s&quot;, &quot;梧雨北辰&quot;); return 0;&#125; 结果分析： 预处理后的文件中，注释已经被清理，宏定义也已经被替换； 预处理后的文件有很多行，因为该过程中导入了头文件(Foundation.h)，而且这个过程是递归的； 六、编译(Compilation)1. 词法分析(Lexical Analysis)主要功能：通过扫描器，分割识别源代码符号(如大小括号、=、字符串)； 使用xcrun命令，在终端执行词法分析操作： 1xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m 终端显示效果如下： 123456789annot_module_include &#x27;#import &lt;Foundation/Foundation.h&gt;/&#x27; Loc=&lt;main.m:1:1&gt;int &#x27;int&#x27; [StartOfLine] Loc=&lt;main.m:4:1&gt;identifier &#x27;main&#x27; [LeadingSpace]......r_brace &#x27;&#125;&#x27; [StartOfLine] Loc=&lt;main.m:7:1&gt;eof &#x27;&#x27; Loc=&lt;main.m:10:1&gt; 结果分析： 每个被分割的源代码符号都被记录了位置，方便后续定位错误； 比如Loc=&lt;main.m:4:1&gt; 就表示：&#39;int&#39;这个符号是从源文件main.m的第4行的第1个字符开始的； 2.语法分析(Semantic Analysis)主要功能：对源代码符号进行分析，验证语法是否正确，最后生成AST语法树； 使用xcrun命令，查看语法分析结果： 1xcrun clang -fsyntax-only -Xclang -ast-dump main.c open -f AST语法树： 是抽象语法树，结构上比代码更精简，遍历速度更快； 能够更快的进行静态检查，同时生成IR(中间代码)； 3.静态分析(Static Analysis)主要功能：对AST树进行遍历分析，包括类型检查、方法实现检查，会及时提示错误； 4.生成中间代码(Code Generation)主要功能：CodeGen负责将AST语法树自顶向下遍历，逐步翻译成IR中间代码； IR中间代码： 这是一种更接近于机器码的语言，使得编译器被分为前端和后端，不同的平台可以利用各自的编译器将中间代码，转化为适合不同平台的机器码； 对于iOS系统来说，IR中间代码生成的就是Mach-O可执行文件; IR是前端的输出，后端的输入； 七、汇编(Assembly)输出中间代码标志着前端工作的完成，接下来将进入后端的处理流程。 1.LLVM优化中间代码中间代码IR进入后端，LLVM会对其进行优化： Optimization Level bitcode 2.生成汇编代码LLVM对IR进行优化后，会针对不同架构生成不同汇编代码； 汇编阶段的目的： 将代码汇编化，并将符号进行归类； 将外部导入符号，放到重定位符号表； 最后生成一个或多个.o目标文件； 使用xcrun命令，生成汇编文件： 1xcrun clang -S main.m -o main.s 打开.s文件，摘取内容如下： 12345678910 .section __TEXT,__text,regular,pure_instructions .build_version macos, 11, 0 sdk_version 11, 3 .globl _main ## -- Begin function main // ...... callq _NSLog // .......subsections_via_symbols 可以看到，汇编文件中的NSLog操作已经被转化为汇编命令形式的调用，即callq _NSLog； 3.生成目标文件该阶段是汇编器将汇编代码转换为机器代码，并输出目标文件，即.o文件； 使用xcrun命令，生成目标文件: 1xcrun clang -fmodules -c main.m -o main.o 使用file命令，查看目标文件类型: 12% file main.omain.o: Mach-O 64-bit object x86_64 可以看到，汇编器生成Mach-O格式的文件，而且是object类型，即目标文件类型： Mach-O文件是用于iOS和OS平台上的文件类型； Mach-O作为a.out格式的替代，提供了更强的扩展性，也提升了符号表中信息的访问速度； 使用xcrun命令，查看下main.o中的符号： 1xcrun nm -nm main.o 终端显示效果如下： 123 (undefined) external _NSLog (undefined) external ___CFConstantStringClassReference0000000000000000 (__TEXT,__text) external _main 可以看到，此时我们使用的NSLog函数，对应着_NSLog符号： undefined：表示在当前文件暂时找不到符号_NSLog； external：表示这个符号是外部可以访问的，对应表示文件私有的符号是non-external； 八、链接(Linking)主要功能：符号解析、重定位、合并目标文件，最终生成可执行文件； 1.使用xcrun命令执行链接，得到可执行文件1xcrun clang main.o -o main 2.使用file命令，查看文件类型1234% file mainmain: Mach-O 64-bit executable x86_64% ./main2021-10-01 19:06:41.846 main[5663:660299] Hello, 梧雨北辰 结果分析：虽然还是Mach-O格式，但此时已经是executable类型了，即可执行文件。而且运行该文件后也打印出了预期的结果； 3.再次使用xcrun命令，查看可执行文件的符号表1234567% xcrun nm -nm main (undefined) external _NSLog (from Foundation) (undefined) external ___CFConstantStringClassReference (from CoreFoundation) (undefined) external dyld_stub_binder (from libSystem)0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header0000000100003f40 (__TEXT,__text) external _main0000000100008008 (__DATA,__data) non-external __dyld_private 结果分析：_NSLog符号依然是undefined，不过此时多了一些信息，即from Foundation，表示这个符号来自于Foundation，会在运行时动态绑定； 4.链接阶段的主要任务1.符号解析 将每个符号引用和对应的符号定义关联起来； 链接器链接多文件时会创建符号表，用于记录所有已经定义和未定义的符号； 出现相同符号，会报错：&quot;ld:dumplicate symbols&quot;； 在其他目标文件里没有找到到符号，会报错：&quot;Undefined symbols&quot;； 另外，链接器在整理函数的符号调用关系时，可以帮助我们理清那些函数没有被调用，并自动去除掉； 2.重定位 将变量名、函数名这些符号定义与一个内存位置关联起来； 因为只有通过了绑定，机器才知道需要操作什么内存地址； 否则，我们就需要在写代码时给每个指令设置好内存地址，不仅操作繁琐，而且容易引起出错； 3.合并目标文件 将多个.m文件编译产生的.o目标文件与其他Mach-O文件(如dylib、a、tbd），合成一个Mach-O格式的可执行文件； 通常项目都会包含多个文件，不同文件之间的变量和接口函数就会产生相互依赖关系； 程序运行前，需要使用链接器将多个文件里的符号和地址绑定起来，才能保证整个程序里的变量、接口的正常调用； 5.理解静态链接与动态链接静态链接：作用于编译期，链接后的文件依然可能会存在一些&quot;undefined&quot;的符号。但是这些符号都会被记录下来，在运行时再通过dlopen和dlsym动态链接绑定； 动态链接：作用于运行时，这样的优势在于：诸多类似UIKit这样的共享库将不必包含在每一个App包里。比如：我们使用到的UIKit系统库，等到点击App真正开始运行之前，才会去链接依赖的UIKit，链接完成再运行App；","categories":[{"name":"iOS高级","slug":"iOS高级","permalink":"https://wuyubeichen.github.io/categories/iOS%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://wuyubeichen.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"iOS高级-Xcode多环境配置","slug":"iOS高级-Xcode多环境配置","date":"2021-11-01T14:54:10.000Z","updated":"2025-05-03T16:24:45.795Z","comments":true,"path":"2021/11/01/iOS高级-Xcode多环境配置/","permalink":"https://wuyubeichen.github.io/2021/11/01/iOS%E9%AB%98%E7%BA%A7-Xcode%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"主要内容： 区分Project、Target、Scheme 多Target 配置 Scheme配置","text":"主要内容： 区分Project、Target、Scheme 多Target 配置 Scheme配置 xcconfig文件配置 一、区分Project、Target、Scheme Project：是一个项目的整体，相当于一个仓库，包括了所有的代码和资源文件； Target：相当于一个具体的产品，包含了对于代码，资源文件的具体使用规则和配置； Scheme: 对指定Target的环境进行配置； 总结：一个Project可以包含多个Target，也就是说通过不同Target我们可以生成不同的APP； 多环境配置的三种方法： 多target配置; Scheme配置; xcconfig文件配置; 二、多Target 配置1.总结特点 优点：方便管理代码，资源文件，比如在Compile Sources、Copy Bundle Resources里根据需要增加或者删除需要编译的代码和资源； 缺点：配置繁琐，涉及多个info.plist文件、宏定义等，大量的修改人容易错乱； 2.基本步骤1.创建新target 选中已有target，右键选择Duplicate，会拷贝创建出与原Target相同配置的新Target； 2.修改新target的配置 由于拷贝得到的target仍使用旧的配置，为了使用新target，所以我们还需要一些额外设置： 修改新Target名字； 修改新info.plist名字； 修改Build Settings -&gt; Packaging -&gt; info.plist File 与 Product Bundle identifier； 3.修改Scheme名字 进入Scheme Manager，修改Scheme的名字，这里并非必须，修改是为了更加方便识别; 4.为了区别不同的Target，增加预定义宏 配置OC工程：Build Settings -&gt; Preprocessor Macros 配置Swift工程：Build Settings -&gt; Other Swift Flags 理解-D用法： swiftc编译器中，需要添加一个-D的option，代表将条件编译标志标记为true； 至于-D的说明，也可以使用控制台命令查看：swiftc --help grep &#39;-D&#39; 1-D &lt;value&gt; Marks a conditional compilation flag as true 5.测试target多环境 12345#if DEV print(&quot;Project DEV&quot;)#else print(&quot;Project Normal&quot;)#endif 三、Scheme配置配置Scheme实现多环境，其实是通过设置多种configurations的方式，具体步骤如下: 1.增加新configration进入Project -&gt; Info -&gt; Configurations，在这里可以看到已经存在的Debug、Release等配置。点击“+”，可以在这里增加新的configuration(以Dev为例); 2.切换多环境增加configuration后，在Edit Scheme时，也会多出一种configration。我们在run的时候，就可以手动切换configration使用不同的环境； 3.多Scheme每次手动切换configration较为繁琐，我们还可以使用不同的Scheme直接对应不同的配置； 4.测试Scheme多环境1.Build Setting -&gt; User-Defined里自定义Host_URL，再对不同的configration配置不同的值； 2.将Host_URL以变量的方式配置到info.plist文件中； 3.读取info.plist，手动切换configration或者使用不同的Scheme运行，将得到不同的信息； 12345guard let path = Bundle.main.path(forResource: &quot;Info&quot;, ofType: &quot;plist&quot;) else &#123; return&#125;guard let infoDic = NSDictionary(contentsOfFile: path) else &#123;return&#125;if let host_url = infoDic[&quot;HOST_URL&quot;] &#123; print(&quot;HOST_URL:\\(host_url)&quot;)&#125; 四、xcconfig配置文件xcconfig配置文件： .xcconfig配置文件，可以帮助我们以文件的形式配置build settings里的内容； .xcconfig的文件的内容，是以key-value形式构成的； 增加.xcconfig文件后，依然可以继续在build settings里增加配置项目，并不会覆盖； 1.查看配置文件其实，若使用Cocoapods管理第三方库，就已经自动生成了Debug和Release配置文件。 查看配置：Xcode -&gt; PROJECT -&gt; info -&gt; Configurations 2.自定义配置文件 Commd +N -&gt; 搜索Configuration Setting File，保存名称以”目录名-App名.环境“为格式， 如”Config-TestProject.debug“； 在.xcconfig文件里写入配置，而这里用到的key其实都是build settings配置选项的缩写，具体可查看网站Xcode Build Settings； 举例：在配置文件中写入以下配置： 1234SLASH = /HOST_URL = http:$&#123;SLASH&#125;/1234OTHER_LDFLAGS = -framework &quot;AFNetworking&quot;HEADER_SEARCH_PATHS = /abcd/efg 此时执行编译后，在build settings里搜索查看Other Linker Flags、Header Search Paths，这些配置都已经被成功修改； 3.特殊符号问题在写入配置信息时，其中url的//会被认为是注释。此时，我们可以先定义一个变量SLASH = /， 如下代码： 12SLASH = /HOST_URL = http:$&#123;SLASH&#125;/5678 4.增加约束条件某些情况下，我们需要为配置增加约束条件，如只在Debug环境下、SDK是模拟器，且架构是x86_64的情况下才会link这个frameworkName，则需要如下配置： 1OTHER_LDFLAGS[config=Debug][sdk=iphonesimulator*][arch=x86_64] = -framework &quot;frameworkName&quot; 5.xcconfig文件冲突问题我们习惯于使用cocoapods管理第三方，由其生成的配置文件和我们自定义的配置文件就会冲突，因为一个环境只能配置一个.xcconfig文件： 而且，此时更新Pods也会警告：已经存在其他的配置文件，Pods设置的.xcconfig文件不会生效； 解决方案：在自定义配置文件中使用关键include命令，引入pods的配置文件，使其生效： 12//注意：这里需要根据debug、release等不同的环境，分别设置#include &quot;Pods/Target Support Files/Pods-TestProject/Pods-TestProject.debug.xcconfig&quot; 6.xcconfig关键字冲突问题将Pods生成的.xcconfig文件通过include导入自定义的配置文件中后，如果两者都对同一个key进行过配置，就会导致前者无效的问题。 比如，两者都对相同的Other Link Flags进行配置，查看Build Setting后，会发现Pods生成的.xcconfig没有生效； 解决方案：使用inherited进行继承，在自定义配置文件中配置如下： 1OTHER_LDFLAGS = $(inherited) -framework &quot;AFNetworking&quot; 7.测试.xcconfig多环境 在不同的.xcconfig定义不同的HOST_URL，并以类似上文的步骤在info.plist中增加配置； 切换到不同的configration下运行项目，将会得到不同的HOST_URL； 参考链接 本文测试Demo地址 iOS多Target开发相似App","categories":[{"name":"iOS高级","slug":"iOS高级","permalink":"https://wuyubeichen.github.io/categories/iOS%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://wuyubeichen.github.io/tags/Xcode/"},{"name":"环境配置","slug":"环境配置","permalink":"https://wuyubeichen.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"iOS底层-自动释放池原理","slug":"iOS底层-自动释放池原理","date":"2019-04-18T10:18:44.000Z","updated":"2025-05-03T16:23:45.570Z","comments":true,"path":"2019/04/18/iOS底层-自动释放池原理/","permalink":"https://wuyubeichen.github.io/2019/04/18/iOS%E5%BA%95%E5%B1%82-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E5%8E%9F%E7%90%86/","excerpt":"主要内容： AutoreleasePool简介 AutoreleasePool底层原理 Autorelease与NSThread、NSRunLoop的关系","text":"主要内容： AutoreleasePool简介 AutoreleasePool底层原理 Autorelease与NSThread、NSRunLoop的关系 AutoreleasePool在主线程上的释放时机 AutoreleasePool在子线程上的释放时机 AutoreleasePool需要手动添加的情况 一、Autorelease简介iOS开发中的Autorelease机制是为了延时释放对象。自动释放的概念看上去很像ARC，但实际上这更类似于C语言中自动变量的特性； 自动变量：在超出变量作用域后将被废弃； 自动释放池：在超出释放池生命周期后，向其管理的对象实例的发送release消息； 1.1 MRC下使用自动释放池在MRC环境中使用自动释放池需要用到NSAutoreleasePool对象，其生命周期就相当于C语言变量的作用域。对于所有调用过autorelease方法的对象，在废弃NSAutoreleasePool对象时，都将调用release实例方法。用源代码表示如下： 12345678910111213//MRC环境下的测试：//第一步：生成并持有释放池NSAutoreleasePool对象;NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];//第二步：调用对象的autorelease实例方法;id obj = [[NSObject alloc] init];[obj autorelease];//第三步：废弃NSAutoreleasePool对象;[pool drain]; //向pool管理的所有对象发送消息，相当于[obj release]//obi已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))NSLog(@&quot;打印obj：%@&quot;, obj); 理解NSAutoreleasePool对象的生命周期，如下图所示： MRC向一个对象发送一条autorelease消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池中每一个对象发送一条release消息，以此来释放对象向一个对象发送release消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为0时，系统才会调用dealloc方法释放该对象和对象本身所拥有的实例。 1.2 ARC下使用自动释放池ARC环境不能使用NSAutoreleasePool类也不能调用autorelease方法，代替它们实现对象自动释放的是@autoreleasepool块和__autoreleasing修饰符。比较两种环境下的代码差异如下图： 如图所示，@autoreleasepool块替换了NSAutoreleasePoool类对象的生成、持有及废弃这一过程。而附有__autoreleasing修饰符的变量替代了autorelease方法，将对象注册到了Autoreleasepool；由于ARC的优化，__autorelease是可以被省略的，所以简化后的ARC代码如下： 12345//ARC环境下的测试：@autoreleasepool &#123; id obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; 显式使用__autoreleasing修饰符的情况非常少见，这是因为ARC的很多情况下，即使是不显式的使用__autoreleasing，也能实现对象被注册到释放池中。主要包括以下几种情况： 编译器会进行优化，检查方法名是否以alloc/new/copy/mutableCopy开始，如果不是则自动将返回对象注册到Autoreleasepool; 访问附有__weak修饰符的变量时，实际上必定要访问注册到Autoreleasepool的对象，即会自动加入Autoreleasepool; id的指针或对象的指针(id*，NSError**)，在没有显式地指定修饰符时候，会被默认附加上__autoreleasing修饰符，加入Autoreleasepool **注意：**如果编译器版本为LLVM.3.0以上，即使ARC无效@autoreleasepool块也能够使用；如下源码所示： 12345//MRC环境下的测试：@autoreleasepool&#123; id obj = [[NSObject alloc] init]; [obj autorelease];&#125; 3.NSAutoreleasePool与@autoreleasepool的区别 MRC中使用NSAutoreleasePool，ARC中使用@autoreleasepool; NSAutoreleasePool对象作用于进行时，@autoreleasepool作用于编译阶段； 二、AutoRelease原理2.1 使用@autoreleasepool{}我们在main函数中写入自动释放池相关的测试代码如下： 123456int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 为了探究释放池的底层实现，我们在终端使用clang -rewrite-objc + 文件名命令将上述OC代码转化为C++源码： 123456789int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0); &#125;//大括号对应释放池的作用域 return 0;&#125; 在经过编译器clang命令转化后，我们看到的所谓的@autoreleasePool块，其实对应着__AtAutoreleasePool的结构体。 2.2 分析结构体__AtAutoreleasePool的具体实现在源码中找到__AtAutoreleasePool结构体的实现代码，具体如下： 12345678extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; __AtAutoreleasePool结构体包含了：构造函数、析构函数和一个边界对象； 构造函数内部调用：objc_autoreleasePoolPush()方法，返回边界对象atautoreleasepoolobj 析构函数内部调用：objc_autoreleasePoolPop()方法，传入边界对象atautoreleasepoolobj 分析main函数中__autoreleasepool结构体实例的生命周期是这样的： __autoreleasepool是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的， 而其析构函数则是在程序执行到离开这个对象的作用域时调用。 所以，我们可以将上面main函数的代码简化如下： 12345678int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; void *atautoreleasepoolobj = objc_autoreleasePoolPush(); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0); objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; 2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对AutoreleasePoolPage对应静态方法push和pop的封装 1234567void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 2.4 理解AutoreleasePoolPageAutoreleasePoolPage是一个C++中的类，打开Runtime的源码工程，在NSObject.mm文件中可以找到它的定义，摘取其中的关键代码如下： 12345678910111213141516171819202122//大致在641行代码开始class AutoreleasePoolPage &#123;# define EMPTY_POOL_PLACEHOLDER ((id*)1) //空池占位# define POOL_BOUNDARY nil //边界对象(即哨兵对象） static pthread_key_t const key = AUTORELEASE_POOL_KEY; static uint8_t const SCRIBBLE = 0xA3; // 0xA3A3A3A3 after releasing static size_t const SIZE = #if PROTECT_AUTORELEASEPOOL PAGE_MAX_SIZE; // must be multiple of vm page size#else PAGE_MAX_SIZE; // size and alignment, power of 2#endif static size_t const COUNT = SIZE / sizeof(id); magic_t const magic; //校验AutoreleasePagePoolPage结构是否完整 id *next; //指向新加入的autorelease对象的下一个位置，初始化时指向begin() pthread_t const thread; //当前所在线程，AutoreleasePool是和线程一一对应的 AutoreleasePoolPage * const parent; //指向父节点page，第一个结点的parent值为nil AutoreleasePoolPage *child; //指向子节点page，最后一个结点的child值为nil uint32_t const depth; //链表深度，节点个数 uint32_t hiwat; //数据容纳的一个上限 //......&#125;; 其实，每个自动释放池都是是由若干个AutoreleasePoolPage组成的双向链表结构，如下图所示: AutoreleasePoolPage中拥有parent和child指针，分别指向上一个和下一个page；当前一个page的空间被占满(每个AutorelePoolPage的大小为4096字节)时，就会新建一个AutorelePoolPage对象并连接到链表中，后来的 Autorelease对象也会添加到新的page中； 另外，当next== begin()时，表示AutoreleasePoolPage为空；当next == end()，表示AutoreleasePoolPage已满。 2.5 理解哨兵对象&#x2F;边界对象(POOL_BOUNDARY)的作用在AutoreleasePoolPage的源码中，我们很容易找到边界对象(哨兵对象)的定义： 1#define POOL_BOUNDARY nil 边界对象其实就是nil的别名，而它的作用事实上也就是为了起到一个标识的作用。 每当自动释放池初始化调用objc_autoreleasePoolPush方法时，总会通过AutoreleasePoolPage的push方法，将POOL_BOUNDARY放到当前page的栈顶，并且返回这个边界对象； 而在自动释放池释放调用objc_autoreleasePoolPop方法时，又会将边界对象以参数传入，这样自动释放池就会向释放池中对象发送release消息，直至找到第一个边界对象为止。 2.6 理解objc_autoreleasePoolPush方法经过前面的分析，objc_autoreleasePoolPush最终调用的是 AutoreleasePoolPage的push方法，该方法的具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static inline void *push() &#123; return autoreleaseFast(POOL_BOUNDARY);&#125;static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123;1. return autoreleaseNoPage(obj); &#125;&#125;//压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针id *add(id obj) &#123; id *ret = next; *next = obj; next++; return ret;&#125;//当前hotPage已满时调用static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123; do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page); &#125; while (page-&gt;full()); setHotPage(page); return page-&gt;add(obj);&#125;//当前hotpage不存在时调用static id *autoreleaseNoPage(id obj) &#123; AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); if (obj != POOL_SENTINEL) &#123; page-&gt;add(POOL_SENTINEL); &#125; return page-&gt;add(obj);&#125; 观察上述代码，每次调用push其实就是创建一个新的AutoreleasePool，在对应的AutoreleasePoolPage中插入一个POOL_BOUNDARY ，并且返回插入的POOL_BOUNDARY 的内存地址。push方法内部调用的是autoreleaseFast方法，并传入边界对象(POOL_BOUNDARY)； hotPage可以理解为当前正在使用的AutoreleasePoolPage； 自动释放池最终都会通过page-&gt;add(obj)方法将边界对象添加到释放池中，而这一过程在autoreleaseFast方法中被分为三种情况： 当前page存在且不满，调用page-&gt;add(obj)方法将对象添加至page的栈中，即next指向的位置 当前page存在但是已满，调用autoreleaseFullPage初始化一个新的page，调用page-&gt;add(obj)方法将对象添加至page的栈中 当前page不存在时，调用autoreleaseNoPage创建一个hotPage，再调用page-&gt;add(obj) 方法将对象添加至page的栈中 2.7 objc_autoreleasePoolPop方法AutoreleasePool的释放调用的是objc_autoreleasePoolPop方法，此时需要传入边界对象作为参数。这个边界对象正是每次执行objc_autoreleasePoolPush方法返回的对象atautoreleasepoolobj； 同理，我们找到objc_autoreleasePoolPop最终调用的方法，即AutoreleasePoolPage的pop方法，该方法的具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041static inline void pop(void *token) //POOL_BOUNDARY的地址&#123; AutoreleasePoolPage *page; id *stop; page = pageForPointer(token); //通过POOL_BOUNDARY找到对应的page stop = (id *)token; if (DebugPoolAllocation &amp;&amp; *stop != POOL_SENTINEL) &#123; // This check is not valid with DebugPoolAllocation off // after an autorelease with a pool page but no pool in place. _objc_fatal(&quot;invalid or prematurely-freed autorelease pool %p; &quot;, token); &#125; if (PrintPoolHiwat) printHiwat(); // 记录最高水位标记 page-&gt;releaseUntil(stop); //向栈中的对象发送release消息，直到遇到第一个哨兵对象 // memory: delete empty children // 删除空掉的节点 if (DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // special case: delete everything during page-per-pool debugging AutoreleasePoolPage *parent = page-&gt;parent; page-&gt;kill(); setHotPage(parent); &#125; else if (DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // special case: delete everything for pop(top) // when debugging missing autorelease pools page-&gt;kill(); setHotPage(nil); &#125; else if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half full if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 上述代码中，首先根据传入的边界对象地址找到边界对象所处的page；然后选择当前page中最新加入的对象一直向前清理，可以向前跨越若干个page，直到边界所在的位置；清理的方式是向这些对象发送一次release消息，使其引用计数减一； 另外，清空page对象还会遵循一些原则： 如果当前的page中存放的对象少于一半，则子page全部删除； 如果当前当前的page存放的多余一半（意味着马上将要满），则保留一个子page，节省创建新page的开销; 2.8 autorelease方法上述是对自动释放池整个生命周期的分析，现在我们来理解延时释放对象autorelease方法的实现，首先查看该方法的调用栈： 123456789101112- [NSObject autorelease]└── id objc_object::rootAutorelease() └── id objc_object::rootAutorelease2() └── static id AutoreleasePoolPage::autorelease(id obj) └── static id AutoreleasePoolPage::autoreleaseFast(id obj) ├── id *add(id obj) ├── static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) │ ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent) │ └── id *add(id obj) └── static id *autoreleaseNoPage(id obj) ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent) └── id *add(id obj) 如上所示，autorelease方法最终也会调用上面提到的 autoreleaseFast方法，将当前对象加到AutoreleasePoolPage中。关于autoreleaseFast的分析这里不再累述，我们主要来考虑一下两次调用的区别： autorelease函数和push函数一样，关键代码都是调用autoreleaseFast函数向自动释放池的链表栈中添加一个对象，不过push函数入栈的是一个边界对象，而autorelease函数入栈的是一个具体的Autorelease的对象。 三、AutoreleasePool与NSThread、NSRunLoop的关系由于AppKit和UIKit框架的优化，我们很少需要显式的创建一个自动释放池块。这其中就涉及到AutoreleasePool与NSThread、NSRunLoop的关系。 3.1 RunLoop和NSThread的关系RunLoop是用于控制线程生命周期并接收事件进行处理的机制，其实质是一个do-While循环。在苹果文档找到关于NSRunLoop的介绍如下： Your application neither creates or explicitly manages NSRunLoop objects. Each NSThread object—including the application’s main thread—has an NSRunLoop object automatically created for it as needed. If you need to access the current thread’s run loop, you do so with the class method currentRunLoop. 总结RunLoop与NSThread(线程)之间的关系如下： RunLoop与线程是一一对应关系，每个线程(包括主线程)都有一个对应的RunLoop对象；其对应关系保存在一个全局的Dictionary里； 主线程的RunLoop默认由系统自动创建并启动；而其他线程在创建时并没有RunLoop，若该线程一直不主动获取，就一直不会有RunLoop； 苹果不提供直接创建RunLoop的方法；所谓其他线程Runloop的创建其实是发生在第一次获取的时候，系统判断当前线程没有RunLoop就会自动创建； 当前线程结束时，其对应的Runloop也被销毁； 3.2 RunLoop和AutoreleasePool的关系在苹果文档中找到两者关系的介绍如下： The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event. 如上所述，主线程的NSRunLoop在监测到事件响应开启每一次event loop之前，会自动创建一个autorelease pool，并且会在event loop结束的时候执行drain操作，释放其中的对象。 3.3 Thread和AutoreleasePool的关系在苹果文档中找到两者关系的介绍如下： Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects (see Threads). As new pools are created, they get added to the top of the stack. When pools are deallocated, they are removed from the stack. Autoreleased objects are placed into the top autorelease pool for the current thread. When a thread terminates, it automatically drains all of the autorelease pools associated with itself. 如上所述， 包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。 四、AutoreleasePool在主线程上的释放时机4.1 理解主线程上的自动释放过程分析主线程RunLoop管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：po [NSRunLoop currentRunLoop]，具体效果如下： 我们看到主线程RunLoop中有两个与自动释放池相关的Observer，它们的 activities分别为0x1和0xa0这两个十六进制的数，转为二进制分别为1和10100000，对应CFRunLoopActivity的类型如下： 12345678910/* Run Loop Observer Activities */typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), //0x1，启动Runloop循环 kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //0xa0，即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), kCFRunLoopExit = (1UL &lt;&lt; 7), //0xa0，退出RunLoop循环 kCFRunLoopAllActivities = 0x0FFFFFFFU &#125;; 结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下： App启动后，苹果在主线程RunLoop里注册了两个Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler(); 第一个Observer监视的事件是Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush()创建自动释放池。order = -2147483647(即32位整数最小值)表示其优先级最高，可以保证创建释放池发生在其他所有回调之前; 第二个Observer监视了两个事件： BeforeWaiting(准备进入休眠)时，调用_objc_autoreleasePoolPop()和_objc_autoreleasePoolPush()释放旧的池并创建新池； Exit(即将退出Loop) 时，调用 _objc_autoreleasePoolPop()来释放自动释放池。order = 2147483647(即32位整数的最大值)表示其优先级最低，保证其释放池子发生在其他所有回调之后; 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建AutoreleasePool了; 最后，也可以结合图示理解主线程上自动释放对象的具体流程： 程序启动到加载完成后，主线程对应的RunLoop会停下来等待用户交互 用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。 RunLoop检测到事件后，就会创建自动释放池; 所有的延迟释放对象都会被添加到这个池子中; 在一次完整的运行循环结束之前，会向池中所有对象发送release消息，然后自动释放池被销毁; 4.2 测试主线程上的对象自动释放过程下面的代码创建了一个Autorelease对象string，并且通过weakString进行弱引用(不增加引用计数，所以不会影响对象的生命周期)，具体如下： 1234567891011121314151617181920212223242526@interface TestMemoryVC ()@property (nonatomic,weak)NSString *weakString;@end@implementation TestMemoryVC- (void)viewDidLoad &#123; [super viewDidLoad]; NSString *string = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;WUYUBEICHEN&quot;]; self.weakString = string;&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; NSLog(@&quot;viewWillAppear:%@&quot;, self.weakString);&#125;- (void)viewDidAppear:(BOOL)animated &#123; [super viewDidAppear:animated]; NSLog(@&quot;viewDidAppear:%@&quot;, self.weakString);&#125;@end//打印结果：//viewWillAppear:WUYUBEICHEN//viewDidAppear:(null) 代码分析： viewDidLoad和viewWillAppear是在同一个 runloop 调用的，因此在 viewWillAppear中，这个autorelease的变量依然有值； 自动变量string在离开viewDidLoad作用域后，会依靠当前主线程上的RunLoop迭代自动释放； 最终string对象在viewDidAppear方法执行前被释放(即RunLoop完成此次迭代)。 五、AutoreleasePool子线程上的释放时机子线程默认不开启RunLoo，那么其中的延时对象该如何释放呢？其实这依然要从Thread和AutoreleasePool的关系来考虑： Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects. 也就是说，每一个线程都会维护自己的 Autoreleasepool栈，所以子线程虽然默认没有开启RunLoop，但是依然存在AutoreleasePool，在子线程退出的时候会去释放autorelease对象。 前面讲到过，ARC会根据一些情况进行优化，添加__autoreleasing修饰符，其实这就相当于对需要延时释放的对象调用了autorelease方法。从源码分析的角度来看，如果子线程中没有创建AutoreleasePool ，而一旦产生了Autorelease对象，就会调用autoreleaseNoPage方法自动创建hotpage，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。 六、AutoreleasePool需要手动添加的情况尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建AutoreleasePool，而其中的延时对象将在当前释放池的作用域结束时释放。苹果文档中说明了三种情况，我们可能会需要手动添加自动释放池： 编写的不是基于UI框架的程序，例如命令行工具； 通过循环方式创建大量临时对象； 使用非Cocoa程序创建的子线程； 而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例： 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; for (int i = 0; i &lt; 1000000; i++) &#123; NSObject *obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; &#125; 代码分析： 上述代码中，obj因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的RunLoop管理的； 因为for循环在当前线程没有执行完毕，Runloop也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。 释放池中的对象将会在viewDidAppear方法执行前就被销毁。 在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下： 123456789- (void)viewDidLoad &#123; [super viewDidLoad]; for (int i = 0; i &lt; 1000000; i++) &#123; @autoreleasepool&#123; NSObject *obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; &#125; &#125; 参考链接 苹果文档NSAutoreleasePool 苹果文档NSRunLoop 苹果文档Using Autorelease Pool Blocks","categories":[{"name":"iOS底层","slug":"iOS底层","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BA%95%E5%B1%82/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"https://wuyubeichen.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"iOS底层-内存管理基本概念","slug":"iOS底层-内存管理基本概念","date":"2019-04-16T10:06:36.000Z","updated":"2025-05-03T16:23:31.291Z","comments":true,"path":"2019/04/16/iOS底层-内存管理基本概念/","permalink":"https://wuyubeichen.github.io/2019/04/16/iOS%E5%BA%95%E5%B1%82-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"主要内容： 内存区域划分 内存管理&#x2F;引用计数 MRC手动管理引用计数","text":"主要内容： 内存区域划分 内存管理&#x2F;引用计数 MRC手动管理引用计数 ARC自动引用计数 MRC与ARC的切换 内存泄漏问题 野指针问题 一、内存区域划分程序在分配内存的时，主要分为：栈区、堆区、静态区、常量区、代码区； 内存区域 具体说明 栈区 存放局部变量的值，系统自动分配和释放;特点：容量小，速度快，有序 堆区 存放通过malloc系列函数或new操作符分配的内存，如对象；一般由程序员分配和释放，如果不释放，则出现内存泄露;特点：容量大，速度慢，无序； 静态区 存放全局变量和静态变量(包括静态局部变量和静态全局变量)；当程序结束时，系统回收； 常量区 存放常量的内存区域；程序结束时，系统回收； 代码区 存放二进制代码的区域 从上述分类上看，我们在开发过程中主要涉及的是堆上内存的管理。通常，我们创建一个对象的代码如下： 1NSObject *obj = [[NSObject alloc] init]; 上述代码创建了一个NSObject类型的指针obj和一个NSObject类型的对象。obj指针存在栈上，而其指向的对象则是在堆上。这种对象也称之为堆对象。 二、内存管理&#x2F;引用计数1.OC使用引用计数机制管理内存 无论是MRC还是ARC环境，OC都采用引用计数来管理内存；每个对象都有一个引用计数器，任何时候指向对象的指针个数和对象的引用计数相等； 每次RunLoop完成一次迭代循环，都会检查对象的引用计数，如果引用计数为0，说明这个对象没有地方在使用，将会被释放； OC管理内存涉及到对象的&quot;生成&quot;、&quot;持有&quot;、&quot;释放&quot;，MRC需要调用对应的方法来管理引用计数，而ARC则是自动管理引用计数，无需再调用这些内存管理的方法。 虽然MRC和ARC两者管理内存的形式不同，但是它们都遵循相同的内存管理规律，内容如下： 自己生成的对象，自己所持有; 非自己生成的对象，自己也能持有; 不再需要自己持有对象时，释放； 非自己持有的对象，无法释放； 三、MRC手动管理引用计数 MRC，即手动管理引用计数。当我们通过alloc、retain等方法持有对象后，也必须有相应的release或者autorelease将其释放。 即：在MRC模式下必须遵守：谁创建谁释放，谁引用谁管理； 总结对象操作与Objective-C内存方法对应关系如下： 对象操作 OC方法 生成并持有对象 以alloc&#x2F;new&#x2F;copy&#x2F;mutableCopy等名称开头方法 持有对象 retain方法 释放对象 release方法 废弃对象 dealloc方法 1.自己生成的对象，自己所持有&#x2F;非自己生成对象，不持有12id obj = [[NSObject alloc] init]; //自己生成并持有对象id obj1 = [NSMutableArray array]; //取得非自己生成的对象，但不持有对象 OC中使用alloc、new、copy、mutableCopy这些名称开头的方法意味着自己生成对象并持有，否则就是非自己生成的对象不持有。如上源码，使用NSObject类的alloc类方法就能自己生成并持有对象，指向生成并持有对象的指针被赋值给了obj。 通过自定义方法来理解这两种创建对象方法的区别(系统方法也是类似的实现)，测试代码如下： 1234567891011//以alloc开头的方法- (id)allocObject &#123; id obj = [[NSObject alloc] init]; return obj;&#125;- (id)object &#123; id obj = [[NSObject alloc] init]; [obj autorelease]; //用该方法，可以使取得的对象存在，但是自己不持有对象 return obj;&#125; autorelease即自动释放，对象已经加入自动释放池，所以获取对象并不持有；涉及到的自动释放池的内容会在后续详细总结。 **注意：**生成并持有对象的的方法一定是驼峰拼写来命名的方法，如alloc、allocMyObject等方法；相反allocate、mutableCopyed就不属于这类方法； 2.非自己生成的对象，自己也能持有12id obj1 = [NSMutableArray array]; //取得非自己生成的对象，但不持有对象[obj retain]; //通过retain方法，持有了对象 源代码中，NSMutableArray类对象被赋值给变量obj，但是变量obj自己不持有该对象。使用retain方法后可以持有对象。 3.不再需要自己持有对象时释放自己持有的对象，一旦不需要，持有者有义务释放该对象，释放对象使用release方法。 123id obj = [[NSObject alloc] init]; //自己生成并持有对象[obj release]; //释放自己持有的对象NSLog(@&quot;%@&quot;,obj); //已经释放，再次使用会崩溃 虽然指向对象的指针依然保留在变量obj中，看似可以访问，但对象一经释放就绝不可再访问。 4.非自己持有的对象无法释放在应用程序中释放非自己持有的对象就会造成崩溃，使用代码演示如下： 12345678//情况1：释放完不再需要的对象后再次释放，访问了已经废弃的对象而崩溃！id obj = [[NSObject alloc] init];[obj release];[obj release];//情况2：取得自己并不持有的对象对其释放，释放了非自己持有的对象而崩溃！id obj = [[NSMutableArray array];[obj release]; 四、ARC自动引用计数 ARC(Automic Reference Counting)，即自动引用计数； 这是iOS5推出的新特性，iOS4.3也支持ARC，只是不能使用weak。 ARC不再需要使用类似retain、release的操作来持有或者释放对象，从而大大提高了开发效率； 1.ARC使用条件 Xcode4.2或以上版本 使用LLVM编辑器3.0或以上版本 Xcode编译器选项中设置ARC有效 2.ARC基本原理 ARC下的编译器会在代码编译阶段合适的位置，自动加入retain/release/autorelease的操作; ARC的规则：只要还有一个强引用指针指向对象，对象就会保存在内存中； ARC中使用strong和weak关键字来修饰对象；strong表示强引用，对应MRC下的retain；weak表示弱引用，对应原来的assign，不同的是当对象被释放的时候，对象weak指针自动赋值为nil，从而不会引发野指针错误； 3.ARC所有权修饰符ARC有效时，OC处理id类型和对象类型必须附加所有权修饰符。所有权修饰符一共有四种： __strong __weak __unsafe_unretained __autoreleasing __strong修饰符:__strong是id类型和对象类型默认的所有权修饰，表示对对象的”强引用”；当对象没有任何一个强引用指向它的时候，对象将被释放； __weak修饰符: __weak与__strong修饰符的作用相反，表示弱引用，不会增加引用计数； 当对象被释放后，所有指向它的弱引用都会被置为nil，这样避免了野指针问题。 __weak修饰符常用于解决循环引用问题； __weak只能用于iOS5以上版本，更早的版本只能使用__unsafe_unretained修饰符。 __unsafe_unretained修饰符 __unsafe_unretained提供弱引用，与__weak作用类似； __unsafe_unretained不能在对象释放后自动置为nil，易产生野指针问题； __unsafe_unretained可用于iOS5之前版本，为兼容ARC弱引用而引入； __autoreleasing修饰符将对象赋值给附有__autoreleasing修饰符的变量，等同于在MRC下调用对象的autorelease方法，即对象被注册到autoreleasepool ARC环境不能使用NSAutoreleasePool类也不能调用autorelease方法，代替它们实现对象自动释放的是@autoreleasepool块和__autoreleasing修饰符；两种环境下的使用情况类比如下图： 如图所示，@autoreleasepool块替换了NSAutoreleasePoool类对象的生成、持有及废弃这一过程。而附有__autoreleasing修饰符的变量替代了autorelease方法，将对象注册到了autoreleasepool; 但事实上，显式使用__autoreleasing修饰符的情况非常少见，这主要是因为ARC的很多情况下，即使是不显式的使用__autoreleasing，也能实现对象被注册到释放池中。换句话来说，ARC环境下对象会被自动加入释放池的情况包括以下几种情况： 编译器会进行优化，检查方法名是否以alloc/new/copy/mutableCopy开始，如果不是则自动将返回对象注册到Autoreleasepool; 访问附有__weak修饰符的变量时，实际上必定要访问注册到Autoreleasepool的对象，即会自动加入Autoreleasepool; id的指针或对象的指针(id*，NSError**)，在没有显式地指定修饰符时候，会被默认附加上__autoreleasing修饰符，加入Autoreleasepool； 4.ARC属性修饰符ARC中的所有权修饰与属性修饰符存在着对应关系，如果不一致还会引起编译错误。总结两者的对应关系如下： 属性修饰符 所有权修饰符 assign __unsafe_unretained copy __strong(但是赋值的是被复制的对象) retain __strong strong __strong unsafe_unretained __unsafe_unretained weak __weak 以上各种属性只有copy不是简单的赋值，它赋值的是通过NSCopying接口的copyWithZone:方法复制赋值源生成的对象。 5.ARC管理内存的规则 不能使用retain/release/retainCount/autorelease内存管理方法; 不能使用NSAllocateObject/NSDeallocateObject方法; 必须遵守内存管理的方法命名规则; 不能显式调用dealloc方法，如[super dealloc]; 使用@autoreleasepool块代替NSAutoreleasePool; 不能使用区域(NSZone); 对象类型变量不能作为C语言结构体(struct&#x2F;union)的成员； 显式转换id和void * 6.必须遵守内存管理的方法命名规则MRC下，用于对象生成&#x2F;持有的方法必须遵守alloc、new、copy、mutableCopy的命名规则。以这些名称开始的方法在返回对象时，必须返回给调用方所应当持有的对象。这在ARC环境下的规则一样。只是ARC下关于init开发的方法规则要更加严格了: 必须是实例方法，且返回对象; 返回对象应该是id类型或该方法声明类的对象，抑或该类的超类或子类; 该返回类型不注册到autoreleasepool上; 基本上，init方法只是对alloc方法返回值的对象进行初始化处理并返回对象; 7.显式转换id和void *这里说到的其实就是Core Foundation和Foundation两者之间的转换。Core Foundation是由C语言实现的，而Foundation由Objective-C实现，两者可以相互转换。 MRC不存在显式转换的问题，因为本来就是手动管理内存。但是为了在ARC也能实现对Core Foundation对象的自动内存管理，我们就必须将其与Objective-C对象的转换。Objective-C中提供了三个关键字__bridge、__bridge_retained、__bridge_transfer来实现转换。 情况1：__bridge转换 123456789/*MRC代码下，将id变量直接强制转换void*正常，但ARC下报错id obj = [[NSObject alloc] init];void *p = obj;*/ //ARC下代码使用__bridge实现单纯的赋值转换id obj = [[NSObject alloc] init];void *p = (__bridge void *)(obj); 总结： __bridge只能实现Objective-C对象和Core Foundation对象的相互转换，但是不修改对象(内存)管理权； 所以，其安全性与赋值给__unsafe_unretained修饰符相近，甚至会更低。如果管理时不注意赋值对象的所有者，就容易产生野指针错误导致程序崩溃； 情况2：__bridge_retained转换 12345678id obj = [[NSObject alloc] init];void *p = (__bridge_retained void *)(obj); /*相当于MRC代码：id obj = [[NSObject alloc] init];void *p = obj;[(id)p retain];*/ 总结： __bridge_retained转换可使要转换的变量也持有所赋值的对象，后续需要使用CFRelease或者相关方法来释放对象； 此操作类似于retain。上述代码中变量obj和变量p同时持有对象。 情况3：__bridge_transfer转换 1234567id obj = (__bridge_transfer id)p; /*相当于MRC代码：id obj = id(p)[obj retain];[(id)p release];*/ 总结： __bridge_transfer转换提供与__bridge_retained相反的动作，被转换的变量所持有的对象在该变量被赋值给转换的目标后随之释放。 此操作与release相似。 五、MRC和ARC的转换iOS5.0以后出现的ARC，即自动引用计数(Automatic Refrence Counting)，减少了代码，省去了对象释放的麻烦。 ARC项目：加入MRC：target -&gt;build phrases -&gt;compbile sources ，点击mrc的文件将其设置为 -fno-objc-arc MRC项目：加入ARC：target -&gt;build phrases -&gt;compbile sources ，点击arc的文件将其设置为 -fobjc-arc iOS通过引用计数来记录对象的引用，每次runloop完成一次循环的时候，都会检查对象的retainCount，如果说对象的retainCount为0，说明该对象没有地方需要引用了，就可以释放掉了； 六、内存泄漏问题 内存泄露就是本该废弃的对象在超出其生命周期后继续存在； 内存泄露可导致内存浪费、程序运行速度减慢甚至系统崩溃等严重后果； 总结常见的内存泄露的异常情况如下： Block、delegate、NSTimer使用不当，造成循环引用; 非OC对象不当使用，如CoreFoundation方式申请的内存，忘记释放，需要free、release方法； 第三方框架不当使用，如AFNetworking循环引用(未使用单例或者没有调用销毁NSURLSession的方法; 自定义长时间执行任务的线程，却没有添加自动释放池； 循环操作创建大量临时对象，导致内存导致内存暴涨； 地图框架使用完，要及时移除相关组件； ARC只适用于OC对象，若我们使用了Core Foundation或者malloc，此时还是手动管理内存的，还有一些循环引用的情况同样造成内存泄露； 123#define WS(weakSelf) __weak __typeof(&amp;*self)weakSelf = self; // 弱引用#define ST(strongSelf) __strong __typeof(&amp;*self)strongSelf = weakSelf; //使用这个要先声明weakSelf 七、野指针问题野指针指针就是指向一个已经删除对象或者访问受限内存区域的指针； **注意：**野指针不是nil指针，而是指向”垃圾”内存（不可用内存）的指针; 总结ARC下常见的野指针异常情况如下：","categories":[{"name":"iOS底层","slug":"iOS底层","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BA%95%E5%B1%82/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"https://wuyubeichen.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"iOS底层-Runtime基础篇","slug":"iOS底层-Runtime基础篇","date":"2019-04-15T08:16:49.000Z","updated":"2025-05-03T16:24:17.143Z","comments":true,"path":"2019/04/15/iOS底层-Runtime基础篇/","permalink":"https://wuyubeichen.github.io/2019/04/15/iOS%E5%BA%95%E5%B1%82-Runtime%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"主要内容： 理解OC是动态语言特性 理解消息机制的基本原理 与Runtime交互的三种方式","text":"主要内容： 理解OC是动态语言特性 理解消息机制的基本原理 与Runtime交互的三种方式 分析Runtime中的数据结构 深入理解Rutime消息发送原理 多继承的实现思路Rutime 参考链接 一、理解OC是动态语言特性1.静态语言和动态语言静态语言：如C语言，编译阶段就要决定调用哪个函数，如果函数未实现就会编译报错。 动态语言：如OC语言，编译阶段并不能决定真正调用哪个函数，只要函数声明过即使没有实现也不会报错。 我们常说OC是一门动态语言，就是因为它总是把一些决定性的工作从编译阶段推迟到运行时阶段。例如： 多态特性，我们可以使用父类指针指向子类对象，并且调用子类方法； 我们利用运行时特性，动态的添加方法、替换方法； 2. 理解Runtime Runtime是一套由C、C++、汇编编实现的一套API，为OC提供运行时机制； 运行时（runtime）将类型的确定由编译时推迟到了运行时； OC代码最终都会被编译器转化为运行时代码，再通过消息机制决定函数调用方式，这也是OC作为动态语言使用的基础。 OC代码的运行不仅需要编译器，还需要运行时系统(Runtime Sytem)来执行编译后的代码。 二、理解消息机制的基本原理OC的方法调用都是类似[receiver selector]的形式，其实每次都是一个运行时消息发送过程； 1.第一步：编译阶段[receiver selector]方法被编译器转化，分为两种情况： 不带参数的方法被编译为：objc_msgSend(receiver，selector)； 带参数的方法被编译为：objc_msgSend(recevier，selector，org1，org2，…)； 2.第二步：运行时阶段消息接收者recever寻找对应的selector，也分为两种情况： 接收者能找到对应的selector，直接执行接收receiver对象的selector方法； 接收者找不到对应的selector，消息被转发或者临时向接收者添加这个selector对应的实现内容，否则崩溃； 说明：OC调用方法[receiver selector]，编译阶段确定了要向哪个接收者发送message消息，但是接收者如何响应决定于运行时的判断; 三、与Runtime的交互Runtime的官方文档中将OC与Runtime的交互划分三种层次： OC源代码 NSObject方法 Runtime 函数 这其实也是按照与Runtime交互程度从低到高排序的三种方式; 1.OC源代码(Objec-C Source Code)我们已经说过，OC代码会在编译阶段被编译器转化。OC中的类、方法和协议等在Runtime中都由一些数据结构来定义。所以，我们平时直接使用OC编写代码，其实这已经是在和Runtime进行交互了，只不过这个过程对于我们来说是无感的; 2.NSObject方法(NSObject Methods)Runtime的最大特征就是实现了OC语言的动态特性。作为大部分Objective-C类继承体系的根类的NSObject，其本身就具有了一些非常具有运行时动态特性的方法，比如respondsToSelector:方法可以检查在代码运行阶段当前对象是否能响应指定的消息，所以使用这些方法也算是一种与Runtme的交互方式，类似的方法还有如下： -description：返回当前类的描述信息 -class：方法返回对象的类； -isKindOfClass和 -isMemberOfClass：检查对象是否存在于指定的类的继承体系中； -respondsToSelector：检查对象能否响应指定的消息； -conformsToProtocol ：检查对象是否实现了指定协议类的方法； -methodForSelector ：返回指定方法实现的地址； 3.使用Runtime函数(Runtime Functions)Runtime系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于/usr/include/objc目录下。在我们工程代码里引用Runtime的头文件，同样能够实现类似OC代码的效果，一些代码示例如下： 12345678//相当于：Class class = [UIView class];Class viewClass = objc_getClass(&quot;UIView&quot;); //相当于：UIView *view = [UIView alloc];UIView *view = ((id (*)(id, SEL))(void *)objc_msgSend)((id)viewClass, sel_registerName(&quot;alloc&quot;));//相当于：UIView *view = [view init];((id (*)(id, SEL))(void *)objc_msgSend)((id)view, sel_registerName(&quot;init&quot;)); 三、分析Runtime中数据结构OC代码被编译器转化为C语言，然后再通过运行时执行，最终实现了动态调用。这其中的OC类、对象和方法等都对应了C中的结构体，而且我们都可以在Rutime源码中找到它们的定义。 那么，我们如何来查看Runtime的代码呢？其实很简单，只需要我们在当前代码文件中引用头文件： 12#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt; 然后，我们需要使用组合键&quot;Command +鼠标点击&quot;，即可进入Runtime的源码文件，下面我们继续来一一分析OC代码在C中对应的结构。 1.id—&gt;objc_objectid是一个指向objc_object结构体的指针，即在Runtime中： 12///A pointer to an instance of a class.typedef struct objc_object *id; 下面是Runtime中对objc_object结构体的具体定义： 1234///Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; 我们都知道id在OC中是表示一个任意类型的类实例，从这里也可以看出，OC中的对象虽然没有明显的使用指针，但是在OC代码被编译转化为C之后，每个OC对象其实都是拥有一个isa的指针的； 2.Class - &gt;objc_classsclass是一个指向objc_class结构体的指针，即在Runtime中： 1typedef struct objc_class *Class; 下面是Runtime中对objc_class结构体的具体定义： 12345678910111213141516//usr/include/objc/runtime.hstruct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !OBJC2 Class Nullable super_class OBJC2UNAVAILABLE; const char * Nonnull name OBJC2UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * Nullable ivars OBJC2UNAVAILABLE; struct objc_method_list * Nullable * _Nullable methodLists OBJC2UNAVAILABLE; struct objc_cache * Nonnull cache OBJC2UNAVAILABLE; struct objc_protocol_list * Nullable protocols OBJC2UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 理解objc_class定义中的参数： isa指针：我们会发现objc_class和objc_object同样是结构体，而且都拥有一个isa指针。我们很容易理解objc_object的isa指针指向对象的定义，那么objc_class的指针是怎么回事呢？ 其实，在Runtime中Objc类本身同时也是一个对象。Runtime把类对象所属类型就叫做元类，用于描述类对象本身所具有的特征，最常见的类方法就被定义于此，所以objc_class中的isa指针指向的是元类，每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。 super_class指针：指向objc_class类所继承的父类，但是如果当前类已经是最顶层的类(如NSProxy),则super_class指针为NULL cache：为了优化性能，objc_class中的cache结构体用于记录每次使用类或者实例对象调用的方法。这样每次响应消息的时候，Runtime系统会优先在cache中寻找响应方法，相比直接在类的方法列表中遍历查找，效率更高; ivars：用于存放所有的成员变量和属性信息，属性的存取方法都存放在methodLists中。 methodLists：用于存放对象的所有成员方法; 3.SELSEL是一个指向objc_selector结构体的指针，即在Runtime中： 12/// An opaque type that represents a method selector.typedef struct objc_selector *SEL; SEL在OC中称作方法选择器，用于表示运行时方法的名字，然而我们并不能在Runtime中找到它的结构体的详细定义。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL； 注意： 不同类中相同名字的方法对应的方法选择器是相同的； 即使是同一个类中，方法名相同而变量类型不同也会导致它们具有相同的方法选择器； 通常我们获取SEL有三种方法： OC中，使用@selector(“方法名字符串”)； OC中，使用NSSelectorFromString(“方法名字符串”)； Runtime方法，使用sel_registerName(“方法名字符串”)； 4.IvarIvar代表类中实例变量的类型，是一个指向ojbcet_ivar的结构体的指针，即在Runtime中： 12/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar; 下面是Runtime中对objc_ivar结构体的具体定义： 12345678struct objc_ivar &#123; char * Nullable ivar_name OBJC2UNAVAILABLE; char * Nullable ivar_type OBJC2UNAVAILABLE; int ivar_offset OBJC2_UNAVAILABLE;#ifdef LP64 int space OBJC2_UNAVAILABLE;#endif&#125; 我们在objc_class中看到的ivars成员列表,其中的元素就是Ivar，我可以通过实例查找其在类中的名字，这个过程被称为反射，下面的class_copyIvarList获取的不仅有实例变量还有属性： 1234567 Ivar *ivarList = class_copyIvarList([self class], &amp;count); for (int i= 0; i&lt;count; i++) &#123; Ivar ivar = ivarList[i]; const char *ivarName = ivar_getName(ivar); NSLog(@&quot;Ivar(%d): %@&quot;, i, [NSString stringWithUTF8String:ivarName]); &#125; free(ivarList)； 5.MethodMethod表示某个方法的类型，即在Runtime中： 12/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method; 我们可以在objct_class定义中看到methodLists，其中的元素就是Method，下面是Runtime中objc_method结构体的具体定义： 12345struct objc_method &#123; SEL Nonnull method_name OBJC2UNAVAILABLE; char * Nullable method_types OBJC2UNAVAILABLE; IMP Nonnull method_imp OBJC2UNAVAILABLE;&#125; OBJC2_UNAVAILABLE; 理解objc_method定义中的参数： method_name:方法名类型SEL； method_types: 一个char指针，指向存储方法的参数类型和返回值类型； method_imp：本质上是一个指针，指向方法的实现； 这里其实就是SEL(method_name)与IMP(method_name)形成了一个映射，通过SEL，我们可以很方便的找到方法实现IMP； 6.IMPIMP是一个函数指针，它在Runtime中的定义如下： 12/// A pointer to the function of a method implementation.typedef void (IMP)(void / id, SEL, ... */ ); IMP这个函数指针指向了方法实现的首地址，当OC发起消息后，最终执行的代码是由IMP指针决定的。利用这个特性，我们可以对代码进行优化：当需要大量重复调用方法的时候，我们可以绕开消息绑定而直接利用IMP指针调起方法，这样的执行将会更加高效，相关的代码示例如下： 12345void (*setter)(id, SEL, BOOL);int i;setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];for ( i = 0 ; i &lt; 1000 ; i++ ) setter(targetList[i], @selector(setFilled:), YES); 注意：这里需要注意的就是函数指针的前两个参数必须是id和SEL； 四、深入理解Rutime消息发送我们在分析了OC语言对应的底层C结构之后，现在可以进一步理解运行时的消息发送机制。先前讲到，OC调用方法被编译转化为如下的形式： 1id _Nullable objc_msgSend(id _Nullable self, SEL _Nonnull op, ...) 其实，除了常见的objc_msgSend，消息发送的方法还有objc_msgSend_stret、objc_msgSendSuper、objc_msgSendSuper_stret等，如果消息传递给超类就使用带有super的方法，如果返回值是结构体而不是简单值就使用带有stret的值。 运行时阶段的消息发送的详细步骤如下： 检测selector是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会retain，release 这些函数了； 检测target 是不是nil 对象。ObjC 的特性是允许对一个 nil对象执行任何一个方法不会 Crash，因为会被忽略掉； 如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，若可以找得到就跳到对应的函数去执行； 如果在cache里找不到就找一下方法列表methodLists； 如果methodLists找不到就到超类的方法列表里寻找，一直找，直到找到NSObject类为止。 如果还找不到，Runtime就提供了如下三种方法来处理：动态方法解析、消息接受者重定向、消息重定向，这三种方法的调用关系如下图： 1.动态方法解析(Dynamic Method Resolution)所谓动态解析，我们可以理解为通过cache和方法列表没有找到方法时，Runtime为我们提供一次动态添加方法实现的机会，主要用到的方法如下： 12345678910111213141516171819//OC方法：//类方法未找到时调起，可于此添加类方法实现+ (BOOL)resolveClassMethod:(SEL)sel//实例方法未找到时调起，可于此添加实例方法实现+ (BOOL)resolveInstanceMethod:(SEL)sel//Runtime方法：/** 运行时方法：向指定类中添加特定方法实现的操作 @param cls 被添加方法的类 @param name selector方法名 @param imp 指向实现方法的函数指针 @param types imp函数实现的返回值与参数类型 @return 添加方法是否成功 */BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) 下面使用一个示例来说明动态解析：Perosn类中声明方法却未添加实现，我们通过Runtime动态方法解析的操作为其他添加方法实现，具体代码如下： 12345678//Person.h文件@interface Person : NSObject//声明类方法，但未实现+ (void)haveMeal:(NSString *)food;//声明实例方法，但未实现- (void)singSong:(NSString *)name;@end 123456789101112131415161718192021222324252627282930//Person.m文件#import &quot;Person.h&quot;#import &lt;objc/runtime.h&gt;@implementation Person//重写父类方法：处理类方法+ (BOOL)resolveClassMethod:(SEL)sel&#123; if(sel == @selector(haveMeal:))&#123; class_addMethod(object_getClass(self), sel, class_getMethodImplementation(object_getClass(self), @selector(zs_haveMeal:)), &quot;v@&quot;); return YES; //添加函数实现，返回YES &#125; return [class_getSuperclass(self) resolveClassMethod:sel];&#125;//重写父类方法：处理实例方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if(sel == @selector(singSong:))&#123; class_addMethod([self class], sel, class_getMethodImplementation([self class], @selector(zs_singSong:)), &quot;v@&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;+ (void)zs_haveMeal:(NSString *)food&#123; NSLog(@&quot;%s&quot;,__func__);&#125;- (void)zs_singSong:(NSString *)name&#123; NSLog(@&quot;%s&quot;,__func__);&#125; 12345//TestViewController.m文件//测试：Peson调用并未实现的类方法、实例方法，并没有崩溃Person *ps = [[Person alloc] init];[Person haveMeal:@&quot;Apple&quot;]; //打印：+[Person zs_haveMeal:][ps singSong:@&quot;纸短情长&quot;]; //打印：-[Person zs_singSong:] 注意： 我们注意到class_addMethod方法中的特殊参数“v@”，具体可参考这里； 成功使用动态方法解析还有个前提，那就是我们必须存在可以处理消息的方法，比如上述代码中的zs_haveMeal:与zs_singSong:; 2.消息接收者重定向我们注意到动态方法解析过程中的两个resolve方法都返回了布尔值，当它们返回YES时方法即可正常执行，但是若它们返回NO，消息发送机制就进入了消息转发(Forwarding)的阶段了，我们可以使用Runtime通过下面的方法替换消息接收者的为其他对象，从而保证程序的继续执行。 12345//重定向类方法的消息接收者，返回一个类- (id)forwardingTargetForSelector:(SEL)aSelector//重定向实例方法的消息接受者，返回一个实例对象- (id)forwardingTargetForSelector:(SEL)aSelector 下面使用一个示例来说明消息接收者的重定向： 我们创建一个Student类，声明并实现takeExam、learnKnowledge两个方法，然后在视图控制器TestViewController(一个继承了UIViewController的自定义类)里测试，关键代码如下： 12345678//Student.h文件@interface Student : NSObject//类方法：参加考试+ (void)takeExam:(NSString *)exam;//实例方法：学习知识- (void)learnKnowledge:(NSString *)course;@end 12345678910// Student.m文件@implementation Student+ (void)takeExam:(NSString *)exam&#123; NSLog(@&quot;%s&quot;,__func__);&#125;- (void)learnKnowledge:(NSString *)course&#123; NSLog(@&quot;%s&quot;,__func__);&#125;@end 1234567891011121314151617181920212223242526272829//TestViewConroller.m文件//重定向类方法：返回一个类对象+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector == @selector(takeExam:)) &#123; return [Student class]; &#125; return [super forwardingTargetForSelector:aSelector];&#125;//重定向实例方法：返回类的实例- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector == @selector(learnKnowledge:)) &#123; return self.student; &#125; return [super forwardingTargetForSelector:aSelector];&#125;//在TestViewConroller的viewDidLoad中测试：//调用并未声明和实现的类方法[TestViewController performSelector:@selector(takeExam:) withObject:@&quot;语文&quot;];//调用并未声明和实现的类方法self.student = [[Student alloc] init];[self performSelector:@selector(learnKnowledge:) withObject:@&quot;天文学知识&quot;];//正常打印:// +[Student takeExam:]// -[Student learnKnowledge:] 注意：动态方法解析阶段返回NO时，我们可以通过forwardingTargetForSelector可以修改消息的接收者，该方法返回参数是一个对象，如果这个对象是非nil，非self，系统会将运行的消息转发给这个对象执行。否则，继续查找其他流程。 3.消息重定向当以上两种方法无法生效，那么这个对象会因为找不到相应的方法实现而无法响应消息，此时Runtime系统会通过forwardInvocation:消息通知该对象，给予此次消息发送最后一次寻找IMP的机会： 1- (void)forwardInvocation:(NSInvocation *)anInvocation； 其实每个对象都从NSObject类中继承了forwardInvocation：方法，但是NSObject中的这个方法只是简单的调用了doesNotRecongnizeSelector:方法，提示我们错误。所以我们可以重写这个方法：对不能处理的消息做一些默认处理，也可以将消息转发给其他对象来处理，而不抛出错误。 我们注意到anInvocation是forwardInvocation唯一参数，它封装了原始的消息和消息参数。正是因为它，我们还不得不重写另一个函数：methodSignatureForSelector。这是因为在forwardInvocation: 消息发送前，Runtime系统会向对象发送methodSignatureForSelector消息，并取到返回的方法签名用于生成NSInvocation对象。 下面使用一个示例来重新定义转发逻辑：在上面的TestViewController添加如下代码： 123456789101112131415161718192021-(void)forwardInvocation:(NSInvocation *)anInvocation&#123; //1.从anInvocation中获取消息 SEL sel = anInvocation.selector; //2.判断Student方法是否可以响应应sel if ([self.student respondsToSelector:sel]) &#123; //2.1若可以响应，则将消息转发给其他对象处理 [anInvocation invokeWithTarget:self.student]; &#125;else&#123; //2.2若仍然无法响应，则报错：找不到响应方法 [self doesNotRecognizeSelector:sel]; &#125;&#125;//需要从这个方法中获取的信息来创建NSInvocation对象，因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。- (NSMethodSignature*)methodSignatureForSelector:(SEL)aSelector&#123; NSMethodSignature *methodSignature = [super methodSignatureForSelector:aSelector]; if (!methodSignature) &#123; methodSignature = [NSMethodSignature signatureWithObjCTypes:&quot;v@:*&quot;]; &#125; return methodSignature;&#125; 然后再在视图控制器里直接调用Student的方法如下： 12345//self是当前的TestViewController,调用了自己并不存在的learnKonwledge:方法[self performSelector:@selector(learnKnowledge:) withObject:@&quot;天文学”];//正常打印://-[Student learnKnowledge:] 总结： 从以上的代码中就可以看出，forwardingTargetForSelector仅支持一个对象的返回，也就是说消息只能被转发给一个对象，而forwardInvocation可以将消息同时转发给任意多个对象，这就是两者的最大区别。 虽然理论上可以重载doesNotRecognizeSelector函数实现保证不抛出异常（不调用super实现），但是苹果文档着重提出“一定不能让这个函数就这么结束掉，必须抛出异常”。(If you override this method, you must call super or raise an invalidArgumentException exception at the end of your implementation. In other words, this method must not return normally; it must always result in an exception being thrown.) forwardInvocation甚至能够修改消息的内容，用于实现更加强大的功能; 六、多继承的实现思路：Runtime我们会发现Runtime消息转发的一个特点：一个对象可以调起它本身不具备的方法。这个过程与OC中的继承特性很相似，其实官方文档中图示也很好的说明了这个问题： 图中的Warrior通过forwardInvocation：将negotiate消息转发给了Diplomat，这就好像是Warrior使用了超类Diplomat的方法一样。所以从这个思路，我们可以在实际开发需求中模拟多继承的操作; 七、参考链接 Objective-C Runtime Programming Guide Runtime官方源码下载 objc4-781 源码编译以及调试","categories":[{"name":"iOS底层","slug":"iOS底层","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BA%95%E5%B1%82/"}],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"https://wuyubeichen.github.io/tags/Runtime/"}]},{"title":"iOS底层-Runtime应用篇","slug":"iOS底层-Runtime应用篇","date":"2019-04-15T08:16:49.000Z","updated":"2025-05-03T16:24:23.374Z","comments":true,"path":"2019/04/15/iOS底层-Runtime应用篇/","permalink":"https://wuyubeichen.github.io/2019/04/15/iOS%E5%BA%95%E5%B1%82-Runtime%E5%BA%94%E7%94%A8%E7%AF%87/","excerpt":"主要内容： Runtime应用场景 动态方法交换：Method Swizzling 实现分类添加新属性","text":"主要内容： Runtime应用场景 动态方法交换：Method Swizzling 实现分类添加新属性 获取类的详细信息 解决同一方法高频率调用的效率问题 方法动态解析与消息转发 动态修改属性变量 优化自动归档和解档 实现字典与模型的转换 一、Runtime应用场景上篇讲述了iOS运行时Runtime基础，本篇将会总结Rutime的具体应用实例。 &#96;结合Runtime动态特性，其在开发中的应用大致分为以下几个方面： 二、动态方法交换：Method Swizzling实现动态方法交换(Method Swizzling)是Runtime中最常见的应用场景，其原理是：通过Runtime获取到方法实现的地址，进而动态交换两个方法的功能。使用到关键方法如下： 123456//获取类方法的MthodMethod _Nullable class_getClassMethod(Class _Nullable cls, SEL _Nonnull name)//获取实例对象方法的MthodMethod _Nullable class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)//交换两个方法的实现void method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2) 1.动态方法交换示例现在演示一个代码示例：在视图控制中，定义两个实例方法printA与printB，然后执行交换 123456789101112131415- (void)printA&#123; NSLog(@&quot;打印A......&quot;);&#125;- (void)printB&#123; NSLog(@&quot;打印B......&quot;);&#125;//交换两个实例方法的实现，并测试打印Method methodA = class_getInstanceMethod([self class], @selector(printA));Method methodB = class_getInstanceMethod([self class], @selector(printB));method_exchangeImplementations(methodA, methodB);[self printA]; //打印B......[self printB]; //打印A...... 2.拦截并替换系统方法Runtime动态方法交换更多的是应用于系统类库和第三方框架的方法替换。在不可见源码的情况下，我们可以借助Rutime交换方法实现，为原有方法添加额外功能，这在实际开发中具有十分重要的意义。 下面将展示一个拦截并替换系统方法的示例：为了实现不同机型上的字体都按照比例适配，我们可以拦截系统UIFont的systemFontOfSize方法，具体操作如下： 步骤1：在当前工程中添加UIFont的分类：UIFont+Adapt,并在其中添用以替换的方法。 12345678+ (UIFont *)zs_systemFontOfSize:(CGFloat)fontSize&#123; //获取设备屏幕宽度，并计算出比例scale CGFloat width = [[UIScreen mainScreen] bounds].size.width; CGFloat scale = width/375.0; //注意：由于方法交换，系统的方法名已变成了自定义的方法名，所以这里使用了 //自定义的方法名来获取UIFont return [UIFont zs_systemFontOfSize:fontSize * scale];&#125; 步骤2：在UIFont的分类中拦截系统方法，将其替换为我们自定义的方法，代码如下： 12345678910//load方法不需要手动调用，iOS会在应用程序启动的时候自动调起load方法，//而且load执行时间较早，所以在此方法中执行交换操作比较合适。+ (void)load&#123; //获取系统方法地址 Method sytemMethod = class_getClassMethod([UIFont class], @selector(systemFontOfSize:)); //获取自定义方法地址 Method customMethod = class_getClassMethod([UIFont class], @selector(zs_systemFontOfSize:)); //交换两个方法的实现 method_exchangeImplementations(sytemMethod, customMethod);&#125; 添加一段测试代码，切换不同的模拟器，观察在不同机型上文字的大小： 1234UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 100, 300, 50)];label.text = @&quot;测试Runtime拦截方法&quot;;label.font = [UIFont systemFontOfSize:20];[self.view addSubview:label]; 这里只是一个简单的示例，详细的用法可参考： 三、实现分类添加新属性我们在开发中常常使用类目Category为一些已有的类扩展功能。虽然继承也能够为已有类增加新的方法，而且相比类目更是具有增加属性的优势，但是继承毕竟是一个重量级的操作，添加不必要的继承关系无疑增加了代码的复杂度。 遗憾的是，OC的类目并不支持直接添加属性，如果我们直接在分类的声明中写入Property属性，那么只能为其生成set与get方法声明，却不能生成成员变量，直接调用这些属性还会造成崩溃。 所以为了实现给分类添加属性，我们还需借助Runtime的关联对象(Associated Objects)特性，它能够帮助我们在运行阶段将任意的属性关联到一个对象上，下面是相关的三个方法： 1234567891011121314151617181920212223242526272829/** 1.给对象设置关联属性 @param object 需要设置关联属性的对象，即给哪个对象关联属性 @param key 关联属性对应的key，可通过key获取这个属性， @param value 给关联属性设置的值 @param policy 关联属性的存储策略(对应Property属性中的assign,copy，retain等) OBJC_ASSOCIATION_ASSIGN @property(assign)。 OBJC_ASSOCIATION_RETAIN_NONATOMIC @property(strong, nonatomic)。 OBJC_ASSOCIATION_COPY_NONATOMIC @property(copy, nonatomic)。 OBJC_ASSOCIATION_RETAIN @property(strong,atomic)。 OBJC_ASSOCIATION_COPY @property(copy, atomic)。 */void objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy)/** 2.通过key获取关联的属性 @param object 从哪个对象中获取关联属性 @param key 关联属性对应的key @return 返回关联属性的值 */id _Nullable objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)/** 3.移除对象所关联的属性 @param object 移除某个对象的所有关联属性 */void objc_removeAssociatedObjects(id _Nonnull object) 注意：key与关联属性一一对应，我们必须确保其全局唯一性； 现在演示一个代码示例：为*UIImage*增加一个分类：UIImage+Tools，并为其设置关联属性urlString(图片网络链接属性），相关代码如下： 123456//UIImage+Tools.h文件中UIImage+Tools.m@interface UIImage (Tools)//添加一个新属性：图片网络链接@property(nonatomic,copy)NSString *urlString;@end 123456789101112131415161718192021//UIImage+Tools.m文件中#import &quot;UIImage+Tools.h&quot;#import &lt;objc/runtime.h&gt;@implementation UIImage (Tools)//set方法- (void)setUrlString:(NSString *)urlString&#123; objc_setAssociatedObject(self, @selector(urlString), urlString, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;//get方法- (NSString *)urlString&#123; return objc_getAssociatedObject(self, @selector(urlString));&#125;//添加一个自定义方法，用于清除所有关联属性- (void)clearAssociatedObjcet&#123; objc_removeAssociatedObjects(self);&#125;@end 测试文件中: 123456789UIImage *image = [[UIImage alloc] init];image.urlString = @&quot;http://www.image.png&quot;;NSLog(@&quot;获取关联属性：%@&quot;,image.urlString); [image clearAssociatedObjcet];NSLog(@&quot;获取关联属性：%@&quot;,image.urlString);//打印：//获取关联属性：http://www.image.png//获取关联属性：(null) 四、获取类的详细信息123456789101112131415161718#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;@interface ClassA : NSObject &#123; int _a; int _b; int _c; CGFloat d; //不推荐这样写&#125;@property (nonatomic, strong) NSArray *arrayA;@property (nonatomic, copy ) NSString *stringA;@property (nonatomic, assign) dispatch_queue_t testQueue;@end@implementation ClassA@end 1.获取所有成员变量123456789101112131415161718Ivar *ivarList = class_copyIvarList([self class], &amp;count);for (int i= 0; i&lt;count; i++) &#123; Ivar ivar = ivarList[i]; const char *ivarName = ivar_getName(ivar); NSLog(@&quot;Ivar(%d): %@&quot;, i, [NSString stringWithUTF8String:ivarName]);&#125;free(ivarList);/*打印结果：_a_b_cd_arrayA_stringA_testQueue*/ 2.获取属性列表1234567891011121314unsigned int count;objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);for (unsigned int i = 0; i&lt;count; i++) &#123; const char *propertyName = property_getName(propertyList[i]); NSLog(@&quot;PropertyName(%d): %@&quot;,i,[NSString stringWithUTF8String:propertyName]);&#125;free(propertyList);/*打印结果：arrayAstringAtestQueue*/ 3.获取所有方法1234567Method *methodList = class_copyMethodList([self class], &amp;count);for (unsigned int i = 0; i&lt;count; i++) &#123; Method method = methodList[i]; SEL mthodName = method_getName(method); NSLog(@&quot;MethodName(%d): %@&quot;,i,NSStringFromSelector(mthodName));&#125;free(methodList); 4.获取当前遵循的所有协议1234567__unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);for (int i=0; i&lt;count; i++) &#123; Protocol *protocal = protocolList[i]; const char *protocolName = protocol_getName(protocal); NSLog(@&quot;protocol(%d): %@&quot;,i, [NSString stringWithUTF8String:protocolName]);&#125;free(propertyList); 注意：C语言中使用Copy操作的方法，要注意释放指针，防止内存泄漏 五、解决同一方法高频率调用的效率问题Runtime源码中的IMP作为函数指针，指向方法的实现。通过它，我们可以绕开发送消息的过程来提高函数调用的效率。当我们需要持续大量重复调用某个方法的时候，会十分有用，具体代码示例如下： 123456void (*setter)(id, SEL, BOOL);int i;setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];for ( i = 0 ; i &lt; 1000 ; i++ ) setter(targetList[i], @selector(setFilled:), YES); 六、方法动态解析与消息转发其实该部分可以参考基础篇中内容，这里不再重复赘述，只是大概做出一些总结。 1.动态方法解析：动态添加方法Runtime足够强大，能够让我们在运行时动态添加一个未实现的方法，这个功能主要有两个应用场景： 场景1：动态添加未实现方法，解决代码中因为方法未找到而报错的问题； 场景2：利用懒加载思路，若一个类有很多个方法，同时加载到内存中会耗费资源，可以使用动态解析添加方法。方法动态解析主要用到的方法如下： 1234567891011121314151617181920//OC方法：//类方法未找到时调起，可于此添加类方法实现+ (BOOL)resolveClassMethod:(SEL)sel//实例方法未找到时调起，可于此添加实例方法实现+ (BOOL)resolveInstanceMethod:(SEL)sel//Runtime方法：/** 运行时方法：向指定类中添加特定方法实现的操作 @param cls 被添加方法的类 @param name selector方法名 @param imp 指向实现方法的函数指针 @param types imp函数实现的返回值与参数类型 @return 添加方法是否成功 */BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) 2.解决方法无响应崩溃问题执行OC方法其实就是一个发送消息的过程，若方法未实现，我们可以利用方法动态解析与消息转发来避免程序崩溃，这主要涉及下面一个处理未实现消息的过程： 除了上述的方法动态解析，还使用到的相关方法如下： 消息接收者重定向 12345//重定向类方法的消息接收者，返回一个类- (id)forwardingTargetForSelector:(SEL)aSelector//重定向实例方法的消息接受者，返回一个实例对象- (id)forwardingTargetForSelector:(SEL)aSelector 消息重定向 123- (void)forwardInvocation:(NSInvocation *)anInvocation；- (NSMethodSignature*)methodSignatureForSelector:(SEL)aSelector; 七、动态修改属性变量现在假设这样一个情况：我们使用第三方框架里的Person类，在特殊需求下想要更改其私有属性nickName，这样的操作我们就可以使用Runtime可以动态修改对象属性。 基本思路：首先使用Runtime获取Peson对象的所有属性，找到nickName，然后使用ivar的方法修改其值。具体的代码示例如下： 12345678910111213141516Person *ps = [[Person alloc] init];NSLog(@&quot;ps-nickName: %@&quot;,[ps valueForKey:@&quot;nickName&quot;]); //null//第一步：遍历对象的所有属性unsigned int count;Ivar *ivarList = class_copyIvarList([ps class], &amp;count);for (int i= 0; i&lt;count; i++) &#123; //第二步：获取每个属性名 Ivar ivar = ivarList[i]; const char *ivarName = ivar_getName(ivar); NSString *propertyName = [NSString stringWithUTF8String:ivarName]; if ([propertyName isEqualToString:@&quot;_nickName&quot;]) &#123; //第三步：匹配到对应的属性，然后修改；注意属性带有下划线 object_setIvar(ps, ivar, @&quot;梧雨北辰&quot;); &#125;&#125;NSLog(@&quot;ps-nickName: %@&quot;,[ps valueForKey:@&quot;nickName&quot;]); //梧雨北辰 总结：此过程类似KVC的取值和赋值 八、优化自动归档和解档归档是一种常用的轻量型文件存储方式，但是它有个弊端：在归档过程中，若一个Model有多个属性，我们不得不对每个属性进行处理，非常繁琐。 归档操作主要涉及两个方法：encodeObject 和 decodeObjectForKey，现在，我们可以利用Runtime来改进它们，关键的代码示例如下： 12345678910111213141516171819202122232425262728293031323334//原理：使用Runtime动态获取所有属性//解档操作- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self = [super init]; if (self) &#123; unsigned int count = 0; Ivar *ivarList = class_copyIvarList([self class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; Ivar ivar = ivarList[i]; const char *ivarName = ivar_getName(ivar); NSString *key = [NSString stringWithUTF8String:ivarName]; id value = [aDecoder decodeObjectForKey:key]; [self setValue:value forKey:key]; &#125; free(ivarList); //释放指针 &#125; return self;&#125;//归档操作- (void)encodeWithCoder:(NSCoder *)aCoder&#123; unsigned int count = 0; Ivar *ivarList = class_copyIvarList([self class], &amp;count); for (NSInteger i = 0; i &lt; count; i++) &#123; Ivar ivar = ivarList[i]; NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)]; id value = [self valueForKey:key]; [aCoder encodeObject:value forKey:key]; &#125; free(ivarList); //释放指针&#125; 下面是有关归档的测试代码： 1234567891011121314//--测试归档Person *ps = [[Person alloc] init];ps.name = @&quot;梧雨北辰&quot;;ps.age = 18;NSString *temp = NSTemporaryDirectory();NSString *fileTemp = [temp stringByAppendingString:@&quot;person.archive&quot;];[NSKeyedArchiver archiveRootObject:ps toFile:fileTemp];//--测试解档NSString *temp = NSTemporaryDirectory();NSString *fileTemp = [temp stringByAppendingString:@&quot;person.henry&quot;];Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:fileTemp];NSLog(@&quot;person-name:%@，person-age:%ld&quot;,person.name,person.age); //person-name:梧雨北辰，person-age:18 九、实现字典与模型的转换字典数据转模型的操作在项目开发中很常见，通常我们会选择第三方如YYModel；其实我们也可以自己来实现这一功能，主要的思路有两种：KVC、Runtime，总结字典转化模型过程中需要解决的问题如下： 现在，我们使用Runtime来实现字典转模型的操作，大致的思路是这样： 借助Runtime可以动态获取成员列表的特性，遍历模型中所有属性，然后以获取到的属性名为key，在JSON字典中寻找对应的值value；再将每一个对应Value赋值给模型，就完成了字典转模型的目的。 首先准备下面的JSON数据用于测试： 123456789101112131415161718192021&#123; &quot;id&quot;:&quot;2462079046&quot;, &quot;name&quot;: &quot;梧雨北辰&quot;, &quot;age&quot;:&quot;18&quot;, &quot;weight&quot;:140, &quot;address&quot;:&#123; &quot;country&quot;:&quot;中国&quot;, &quot;province&quot;: &quot;河南&quot; &#125;, &quot;courses&quot;:[&#123; &quot;name&quot;:&quot;Chinese&quot;, &quot;desc&quot;:&quot;语文课&quot; &#125;,&#123; &quot;name&quot;:&quot;Math&quot;, &quot;desc&quot;:&quot;数学课&quot; &#125;,&#123; &quot;name&quot;:&quot;English&quot;, &quot;desc&quot;:&quot;英语课&quot; &#125; ]&#125; 具体的代码实现流程如下： 步骤1：创建NSObject的类目NSObject+ZSModel，用于实现字典转模型123456789@interface NSObject (ZSModel)+ (instancetype)zs_modelWithDictionary:(NSDictionary *)dictionary;@end//ZSModel协议，协议方法可以返回一个字典，表明特殊字段的处理规则@protocol ZSModel&lt;NSObject&gt;@optional+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelContainerPropertyGenericClass;@end; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#import &quot;NSObject+ZSModel.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSObject (ZSModel)+ (instancetype)zs_modelWithDictionary:(NSDictionary *)dictionary&#123; //创建当前模型对象 id object = [[self alloc] init]; //1.获取当前对象的成员变量列表 unsigned int count = 0; Ivar *ivarList = class_copyIvarList([self class], &amp;count); //2.遍历ivarList中所有成员变量，以其属性名为key，在字典中查找Value for (int i= 0; i&lt;count; i++) &#123; //2.1获取成员属性 Ivar ivar = ivarList[i]; NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)] ; //2.2截取成员变量名：去掉成员变量前面的&quot;_&quot;号 NSString *propertyName = [ivarName substringFromIndex:1]; //2.3以属性名为key，在字典中查找value id value = dictionary[propertyName]; //3.获取成员变量类型, 因为ivar_getTypeEncoding获取的类型是&quot;@\\&quot;NSString\\&quot;&quot;的形式 //所以我们要做以下的替换 NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];// 替换: //3.1去除转义字符：@\\&quot;name\\&quot; -&gt; @&quot;name&quot; ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\\&quot;&quot; withString:@&quot;&quot;]; //3.2去除@符号 ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;]; //4.对特殊成员变量进行处理： //判断当前类是否实现了协议方法，获取协议方法中规定的特殊变量的处理方式 NSDictionary *perpertyTypeDic; if([self respondsToSelector:@selector(modelContainerPropertyGenericClass)])&#123; perpertyTypeDic = [self performSelector:@selector(modelContainerPropertyGenericClass) withObject:nil]; &#125; //4.1处理：字典的key与模型属性不匹配的问题，如id-&gt;uid id anotherName = perpertyTypeDic[propertyName]; if(anotherName &amp;&amp; [anotherName isKindOfClass:[NSString class]])&#123; value = dictionary[anotherName]; &#125; //4.2.处理：模型嵌套模型 if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType hasPrefix:@&quot;NS&quot;]) &#123; Class modelClass = NSClassFromString(ivarType); if (modelClass != nil) &#123; //将被嵌套字典数据也转化成Model value = [modelClass zs_modelWithDictionary:value]; &#125; &#125; //4.3处理：模型嵌套模型数组 //判断当前Vaue是一个数组，而且存在协议方法返回了perpertyTypeDic if ([value isKindOfClass:[NSArray class]] &amp;&amp; perpertyTypeDic) &#123; Class itemModelClass = perpertyTypeDic[propertyName]; //封装数组：将每一个子数据转化为Model NSMutableArray *itemArray = @[].mutableCopy; for (NSDictionary *itemDic in value) &#123; id model = [itemModelClass zs_modelWithDictionary:itemDic]; [itemArray addObject:model]; &#125; value = itemArray; &#125; //5.使用KVC方法将Vlue更新到object中 if (value != nil) &#123; [object setValue:value forKey:propertyName]; &#125; &#125; free(ivarList); //释放C指针 return object;&#125;@end 步骤2：分别创建各个数据模型Student、Address、CourseStudent类： 1234567891011121314151617181920212223//.h文件#import &quot;NSObject+ZSModel.h&quot;#import &quot;AddressModel.h&quot;#import &quot;CourseModel.h&quot;@interface StudentModel : NSObject&lt;ZSModel&gt; //遵循协议//普通属性@property (nonatomic, copy) NSString *uid;@property(nonatomic,copy)NSString *name;@property (nonatomic, assign) NSInteger age;//嵌套模型@property (nonatomic, strong) AddressModel *address;//嵌套模型数组@property (nonatomic, strong) NSArray *courses;@end// .m文件#import &quot;StudentModel.h&quot;@implementation StudentModel+ (NSDictionary *)modelContainerPropertyGenericClass &#123; //需要特别处理的属性 return @&#123;@&quot;courses&quot; : [CourseModel class],@&quot;uid&quot;:@&quot;id&quot;&#125;;&#125;@end Address类： 123456789101112//AddressModel.h文件@interface AddressModel : NSObject@property (nonatomic, copy) NSString *country; //国籍@property (nonatomic, copy) NSString *province; //省份@property (nonatomic, copy) NSString *city; //城市@end//-----------------优美的分割线------------------------//AddressModel.m文件#import &quot;AddressModel.h&quot;@implementation AddressModel@end Course类： 12345678//读取JSON数据NSDictionary *jsonData = [FileTools getDictionaryFromJsonFile:@&quot;Student&quot;];NSLog(@&quot;%@&quot;,jsonData);//字典转模型StudentModel *student = [StudentModel zs_modelWithDictionary:jsonData];CourseModel *courseModel = student.courses[0];NSLog(@&quot;%@&quot;,courseModel.name); 步骤3：测试字典转模型操作12345678//读取JSON数据NSDictionary *jsonData = [FileTools getDictionaryFromJsonFile:@&quot;Student&quot;];NSLog(@&quot;%@&quot;,jsonData);//字典转模型StudentModel *student = [StudentModel zs_modelWithDictionary:jsonData];CourseModel *courseModel = student.courses[0];NSLog(@&quot;%@&quot;,courseModel.name); 效果如下： 最后总结以上就是我们在实际开发中常用的Runtime的操作了，Runtime的强大作用远不止如此。深入的了解和学习Runtime，不仅仅有助于iOS开发，而且对于理解编程语言的底层原理也十分有用，Keep Learning！~ 参考链接： 如何正确使用 Runtime Objective-C Runtime Programming Guide Method Swizzling iOS数据持久化存储:归档 YYModel源码","categories":[{"name":"iOS底层","slug":"iOS底层","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BA%95%E5%B1%82/"}],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"https://wuyubeichen.github.io/tags/Runtime/"}]},{"title":"iOS底层-Block捕获变量原理分析","slug":"iOS底层-Block捕获变量原理分析","date":"2019-04-13T08:16:49.000Z","updated":"2025-05-03T16:23:55.369Z","comments":true,"path":"2019/04/13/iOS底层-Block捕获变量原理分析/","permalink":"https://wuyubeichen.github.io/2019/04/13/iOS%E5%BA%95%E5%B1%82-Block%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"主要内容： 分析Block捕获外部变量的过程 理解Block修改外部变量的限制 分析__block存储域类说明符的原理","text":"主要内容： 分析Block捕获外部变量的过程 理解Block修改外部变量的限制 分析__block存储域类说明符的原理 理解__block变量的存储域 探究Block对对象的捕获过程 Block的循环引用问题 一、分析Block捕获外部变量的过程为了保证Block内部能够正常访问外部的变量，Block有一个变量捕获机制，即Block语法表达式所使用变量可以被保存到Block的结构体实例(Block自身)中。 关于捕获，Block对不同的外部变量的处理有所不同，根据OC中使用变量的分类，大概包括以下几种情况： 函数参数(这里研究Block捕获，所以此处不涉及) 局部变量(简称：自动变量) 静态局部变量(常简称，静态变量) 全局变量 静态全局变量 那么，现在对Block捕获外部变量的四种情况进行测试，相关代码如下： 12345678910111213141516171819202122232425262728293031#import &lt;Foundation/Foundation.h&gt;//使用如下的命令，可将OC代码编译为C++代码//clang -rewrite-objc main.mint global_val = 1; //全局变量static int static_global_val = 1; //静态全局变量int main(int argc, char * argv[]) &#123; int val = 1; //自动变量 static int static_val = 1; //局部静态变量 void (^myBlock)(void) = ^&#123; global_val ++; static_global_val ++; static_val ++; //val++//直接修改会报错(Variable is not assignable (missing __block type specifier) NSLog(@&quot;\\nBlock内:\\nglobal_val = %d,\\nstatic_global_val = %d,\\nval = %d,\\nstatic_val= %d&quot;,global_val,static_global_val,val,static_val); &#125;; global_val ++; static_global_val ++; val ++; static_val ++; NSLog(@&quot;\\nBlock外:\\nglobal_val = %d,\\nstatic_global_val = %d,\\nval = %d,\\nstatic_val= %d&quot;,global_val,static_global_val,val,static_val); myBlock(); return 0;&#125; 运行的结果如下： 1234567891011Block外:global_val = 2,static_global_val = 2,val = 2,static_val= 2Block内:global_val = 3,static_global_val = 3,val = 1,static_val= 3 分析运行结果，我们会发现以上四种情况中，只有静态局部变量、静态全局变量、全局变量可以在Block里被修改，而且直接修改自动变量就会报错； 此时，考虑以下两个问题： 为什么在Block里不允许更改自动变量？ Block捕获不同的变量并修改时，有什么区别吗？ 为了具体分析，现在将上述代码转化为C++的源码，转换后的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int global_val = 1;static int static_global_val = 1;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int *static_val; //对应静态局部变量 int val; //对应自动变量 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_val, int _val, int flags=0) : static_val(_static_val), val(_val) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int *static_val = __cself-&gt;static_val; // bound by copy int val = __cself-&gt;val; // bound by copy global_val ++; static_global_val ++; (*static_val) ++; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_78fd5a_mi_0,global_val,static_global_val,val,(*static_val)); &#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main(int argc, char * argv[]) &#123; int val = 1; static int static_val = 1; void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val, val)); global_val ++; static_global_val ++; val ++; static_val ++; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_78fd5a_mi_1,global_val,static_global_val,val,static_val); ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock); return 0;&#125; 在代码分析之前，我们有必要对程序中的内存区域划分有所了解，其大致的分类如下： 内存区域 具体说明 栈区 存放局部变量的值，系统自动分配和释放;特点：容量小，速度快，有序 堆区 存放通过malloc系列函数或new操作符分配的内存，如对象；一般由程序员分配和释放，如果不释放，则出现内存泄露;特点：容量大，速度慢，无序； 静态区 存放全局变量和静态变量(包括静态局部变量和静态全局变量)；当程序结束时，系统回收； 常量区 存放常量的内存区域；程序结束时，系统回收； 代码区 存放二进制代码的区域 了解了这些之后，我们再来具体分析代码和执行结果： 1.全局变量和静态全局变量这两种变量都存储在静态区，在任何时候都可以访问，所以Block无所谓捕获，而是采用了直接访问的方式成功的修改了它们的值；这一点从Block对应的构造函数中就可以看出来： 1__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_var, int _var, int flags=0) : static_var(_static_var), var(_var); 可以看到，Block的构造函数的参数里只使用到了静态局部变量和自动变量，并没有涉及到全局变量和静态全局变量。 而且我们也在Block的结构体中，也只发现了对应的静态变量和自动变量的属性，这进一步说明Block是直接使用全局变量和静态全局变量，而非捕获的方式； 12int *static_val; //对应静态局部变量int val; //对应自动变量 2.自动变量与静态局部变量虽然自动变量与静态局部变量都被Block捕获，但是只有静态局部变量才可以被修改成功。通过Block中对应的函数__main_block_func_0，可以观察到Block对外部变量的修改过程，相关代码如下： 12345678static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int *static_var = __cself-&gt;static_var; // bound by copy int var = __cself-&gt;var; // bound by copy global_var ++; static_global_var ++; (*static_var) ++; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_TestBlock_b539f1_mi_0,global_var,static_global_var,var,(*static_var));&#125; 可以看到，Block为了访问到对应的自动变量和静态局部变量都使用了__cself，这些操作其实都是针对Block自身属性的，但不同的是： 外部静态局部变量，由于是指针传递，所以修改的是同一个变量，可以修改成功； 外部自动变量，由于是值传递，所以即使修改成功，也无法改变外部自动变量的值； 因此，也许是出于安全的目的，在编译阶段我们就会收到错误提示：Block不能修改其捕获的外部自动变量，即: 1Variable is not assignable(missing __block type specifier) 3.静态局部变量也在静态区，为什么不可以像全局变量一样直接修改？其实，关键原因还是&quot;局部&quot;两个字，我们看到C++代码中的函数__main_block_func_0被设置在了包含Block语法的main函数之外，而静态局部变量就是在main函数中定义的； 所以，__main_block_func_0和静态局部变量的作用域是不同的，当然不能像全局变量一样随时访问它。因此，还是采用了捕获和指针传递的方式来修改静态局部变量。 4.为什么自动变量不能像静态变量一样指针传递呢？这主要还是因为自动变量和静态变量的存储域的不同。 自动变量存在栈上，其被销毁的时间不定，这很有可能导致Block执行的时候自动变量已经被销毁，那么此时访问被销毁的地址就会产生野指针错误。 二、理解Block修改外部变量的限制通过以上的代码示例，我们可以将Block修改外部变量成功的情况分为两种： 第一种：Block直接访问全局性的变量，如全局变量、静态全局变量； 第二种：Block间接访问静态局部变量，捕获外部变量并使用指针传递的方式； 此时，我们把Block中不允许修改外部变量的值的问题，变成了不允许修改自动变量的问题，但这也并非最终答案，其实最根本的原因还是Block不允许修改栈中指针的内容； 下面的一段代码，可以从侧面来验证我们的想法： 123456789101112131415#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; NSMutableString *mStr = @&quot;mStr&quot;.mutableCopy; void (^myBlock)(void) = ^&#123; //mStr = @&quot;newMstr&quot;.mutableCopy; //代码1：直接修改了mStr指针内容； [mStr appendString:@&quot;-ExtraStr&quot;]; //代码2：修改mStr指向的堆中内容； NSLog(@&quot;Block内：mStr:%@&quot;,mStr); &#125;; NSLog(@&quot;Block外：%@&quot;,mStr); myBlock(); return 0;&#125;//打印结果：//Block外：mStr//Block内：mStr:mStr-ExtraStr 上述代码是操作一个自动变量的可变字符串，经过测试mStr不可以直接赋值，却可以通过appendString修改字符串，这其中的原因是什么呢？ 首先还是将代码转化为C++源码，具体如下： 12345678910111213141516171819202122232425262728293031323334353637struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; NSMutableString *mStr; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSMutableString *_mStr, int flags=0) : mStr(_mStr) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; NSMutableString *mStr = __cself-&gt;mStr; // bound by copy ((void (*)(id, SEL, NSString * _Nonnull))(void *)objc_msgSend)((id)mStr, sel_registerName(&quot;appendString:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_fe0cca_mi_1); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_fe0cca_mi_2,mStr); &#125; static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;mStr, (void*)src-&gt;mStr, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;mStr, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main(int argc, const char * argv[]) &#123; NSMutableString *mStr = ((id (*)(id, SEL))(void *)objc_msgSend)((id)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_fe0cca_mi_0, sel_registerName(&quot;mutableCopy&quot;)); void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, mStr, 570425344)); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_fe0cca_mi_3,mStr); ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock); return 0;&#125; 作为对象的字符串会涉及到释放的问题，所以此处转换后的源码与基本类型有所区别(但不影响此处分析，后续会讲到)。 我们发现Block捕获了mStr，而且采用了指针传递的方式，这与上面的静态局部变量被捕获的方式很相似，但是mStr依然不可以直接赋值新的字符串。 其实弄清楚问题的关键是理解下面这句代码究做了什么？ 1mStr = @&quot;newMstr&quot;.mutableCopy; 这句代码的含义可以归纳为： 第一步：@&quot;mStr&quot;.mutableCopy创建了新的字符串对象，并将新对象的地址返回； 第二步：将新对象地址赋值给了mStr； 我们知道mStr指针是在栈上的，它随时可能被释放，直接修改就有可能造成野指针错误，这刚好对应了先前自动变量不可修改的问题； 但通过appendString为什么又可以修改字符串呢？这主要因为mStr通过指针传递被Block捕获后，Block只是借助其内部的指针(和mStr同名，且指向同一个地址)，找到了可变字符串的位置，向这块内存追加新的内容，但是并未改变mStr的内存地址； 重要总结：Block修改外部变量的限制，其实是指Block不允许修改栈中指针的内容； 说白了， block内部可以修改的是堆中的内容， 但不能直接修改栈中的任何东西； 三、理解__block存储域类说明符的原理通过以上的分析，我们可以将Block理解为”可以带有自动变量值的匿名函数“，但由于存储域的关系，Block并不能直接修改捕获的自动变量。为了解决这个问题，总结起来有两种方案： 使用存储域在静态区的变量(如全局变量、静态全局变量、静态局部变量)； 使用存储域类说明符__block； 第一种方案我们已经分析过了，现在重点来理解__block存储域说明符的用法，其实C语言中的还有许多其他存储域类说明符，如： typedef extern static auto register __block说明符就类似于static、auto、register，它们可以用于指定变量值设置到哪个存储域中。例如，auto表示自动变量存储在栈中(默认)，static表示静态变量存储在数据区中。 下面我们来实际使用__block，使用它来修改被Block捕获的自动变量，具体的代码如下： 12345678910//__block存储域修饰符int main(int argc, const char * argv[]) &#123; __block int val = 10; void (^myBlock)(void) = ^&#123; val = 20;&#125;; val = 30; myBlock(); NSLog(@&quot;val: %@&quot;,val); return 0;&#125; 可以看到，Block中修改自动变量却没有像之前那样报错，这说明__block说明符是有效的，为了探究其中原理，现在我们再次把上述代码转换C++代码，具体如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243struct __Block_byref_val_0 &#123; void *__isa;__Block_byref_val_0 *__forwarding; int __flags; int __size; int val;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_val_0 *val; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags=0) : val(_val-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref (val-&gt;__forwarding-&gt;val) = 20;&#125; static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;val, (void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main(int argc, const char * argv[]) &#123; __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 10&#125;; void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, 570425344)); (val.__forwarding-&gt;val) = 30; ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_wd_fhcn9bn91v56nlzv9mt5z8ym0000gn_T_main_a9f88e_mi_0,(val.__forwarding-&gt;val)); return 0;&#125; 分析代码，我们会发现__block变量的初始化已经发生了根本的变化，此时的自动变量val对应的是C++源码中的__Block_byref_val_0结构体。该结构体包含了五个成员变量，具体定义如下： 1234567struct __Block_byref_val_0 &#123; void *__isa; //isa指针__Block_byref_val_0 *__forwarding; //初始化传递的是自身结构体实例的指针 int __flags; //标记flag int __size; //大小 int val; //对应原自动变量val的值&#125;; 我们看到__block变量val的初始值为10，而这个值也出现在了调用__Block_byref_val_0结构体构造方法的时候，总结__block变量被捕获的过程如下： 自动变量__block int varl被封装为__Block_byref_val_0结构体，保存原始变量的指针和值； __Block_byref_val_0结构体包含一个与__block变量同名的成员变量val，对应外部自动变量的值； __Block_byref_val_0结构体包含一个__forwarding指针，初始化传递的是自己的地址; 在Block初始化的过程中，调用__main_block_impl_0结构体构造函数时，会将__block变量的__Block_byref_val_0结构体实例的指针作为参数； 接下来分析给__block变量赋值的代码，转换后的源码如下： 1234static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref (val-&gt;__forwarding-&gt;val) = 20;&#125; 在这里，我们看到函数首先通过cself-&gt;val拿到了对应__block变量的结构体实例，然后又通过__Block_byref_val_0结构体实例的成员变量__forwarding，最终访问到了结构体成员变量val； 具体的过程，如下图所示： 分析当前情况，我就会发现这里有两个很关键问题： 为什么要使用多余的__forwarding指针来间接访问变量？ 当前__block说明符的作用仅仅体现在：将__block变量封装为__Block_byref_val_0结构体，这并未从根本上改变自动变量的性质，自动变量究竟是如何被修改的呢？ 为了理解上述问题，我们首先应该对下面的代码有一个更加清晰的了解： 1void (^myBlock)(void) = ^&#123; val = 10;&#125;; 代码中创建后的Block直接赋值给了强指针，这其实满足了ARC环境下编辑器对Block的优化： 编译器会自动将Block从栈拷贝到堆上，而Block中的用到的__block变量也会被一并拷贝，并且被堆上的Block持有。 所以，即使是Block语法所在的作用域结束，堆上的Block和__block变量依然继续存在，自然也就不存在自动变量创建在栈上被释放的问题了。 借助图示，理解如下： 另外，当__block变量结构体实例在从栈上被拷贝到堆上时，会将成员变量的__forwarding的值替换为复制目标堆上的__block变量结构体实例的地址。 通过这种功能，无论是在Block语法中、Block语法外使用__block变量，还是__block变量配置在栈上或堆上，都可以顺利访问同__block变量。这就是__forwarding指针存在的意义。 使用图示，理解如下： 重要总结： __block修饰的自动变量被封装为结构体，作为一个对象随着Block被拷贝到了堆上，解决了自动变量容易因作用域结束而释放的问题。 而__block变量结构体中的__forwarding则保证了无论在栈上还是堆上访问的都是同一个__block变量； 我们能够成功修改__block变量的值，其实是修改了堆上被Block持有的__block变量的内部成员变量val； 其他问题： ARC存在编译器的自动优化，自动拷贝Block的情况还包含了很多种，这里只是其中一种情况，上篇已分析过； 上述代码中，__block说明符将基本类型的数据封装为结构体类型(其中包含了isa指针)，这其实就说明__block变量已经是作为了一个对象在使用； 而对象类型被Block捕获之后都会涉及一些释放的问题，所以源码也出现了许多与对象释放相关的函数如：__main_block_copy_0、__main_block_dispose_0等。这个问题后续会详细分析； 四、__block变量的存储域Block的存储域通常涉及到拷贝的操作，那么对于__block变量又是如何处理的呢？使用__block变量的Block从栈上拷贝到堆上时，__block变量也会受到影响； 1.单个Block中使用__block变量若一个Block中使用__block变量，则当该Block从栈拷贝到堆上时，使用的所有__block变量也全部被从栈上拷贝到堆上。使用图示理解如下： 2.多个Block使用__block变量多个Block使用__block变量时，任何一个Block从栈上拷贝到堆上，__block变量就会一并从栈上拷贝到堆上并被该Block所持有。当剩下的Block从栈拷贝到堆上时，被拷贝的Block持有__block变量，并增加__block变量的引用计数。使用图示理解如下： 3.__block变量的释放如果拷贝到堆上的Block被释放，那么它使用的__block变量的引用计数会减一，如果引用计数为0就会被释放。使用图示理解如下： **重要总结：**无论是对基本类型还是对象使用__block修饰符，从转化后的源码来看，它们都会被转化为对应的结构体实例来使用，具有引用类型数据的特性。因此__block变量随着Block被拷贝到堆上后，它们的内存管理与普通的OC对象引用计数内存管理模式完全相同。 五、理解Block对对象的捕获仔细观察之前的源码我们就会发现，Block捕获对象类型和__block类型的变量(在底层被封装为结构体，也属于对象)明显比基本类型要复杂多，其实这里主要是因为对象类型还要涉及到释放的问题。下面的代码演示了Block对对象的捕获的过程，具体如下： 123456789101112131415161718192021typedef void(^AddBlock)(NSString *); //定义一种携带字符串参数的Blockint main(int argc, const char * argv[]) &#123; AddBlock blk = nil; &#123; NSMutableArray *mArr = @[].mutableCopy; blk = ^(NSString *string)&#123; [mArr addObject:string]; NSLog(@&quot;mArr count = %ld&quot;,[mArr count]); &#125;; &#125;//NSMutableArray所在的作用域结束 blk(@&quot;A&quot;); blk(@&quot;B&quot;); blk(@&quot;C&quot;); return 0;&#125;//打印结果：mArr count = 1mArr count = 2mArr count = 3 分析代码：当前为ARC环境下，编译器自动对访问了自动变量的mArr的blk进行了拷贝；所以mArr离开其所在的作用域结束时并没有被释放。虽然mArr指针已经不能使用，但是blk依然保留有对mArr的引用可以找到这块内存。所以代码也是运行正常的； 现在查看编译器转换后的源码如下： 12345678910111213141516171819202122struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; NSMutableArray *mArr; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSMutableArray *_mArr, int flags=0) : mArr(_mArr) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;mArr, (void*)src-&gt;mArr, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;mArr, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;; 由于代码量较大，这里只提供了与捕获基本类型不同的部分；我们发现： 当Block捕获对象类型的变量时，此处的__main_block_desc_0结构体中多了copy与dispose两个成员变量； 而且它们的初始化分别使用了__main_block_copy_0和__main_block_dispose_0的函数指针； 这里主要的原因是： 在Objective-C中，C语言结构体不能含有__strong、__weak修饰符的变量，因为编译器不知道应该如何进行C语言结构的初始化和废弃操作，不能很好地管理内存； 但是OC的运行时库能够准确把握Block从栈复制到堆以及堆上Block被废弃的时机，所以这里才会增加与内存管理相关的变量和函数。 1.__main_block_copy_0函数结构体__main_block_desc_0中的copy成员变量对应了__main_block_copy_0函数。 当Block从栈上拷贝到堆上时，__main_block_copy_0函数会被调用，然后再调用其内部的_Block_object_assign函数。_Block_object_assign函数就相当于retain操作，会自动根据__main_block_impl_0结构体内部的mArr是什么类型的指针，对mArr对象产生强引用或者弱引用。如果mArr指针是__strong类型，则为强引用，引用计数+1，如果mArr指针是__weak类型，则为弱引用，引用计数不变。 2.__main_block_dispose_0函数结构体__main_block_desc_0中的dispose成员变量对应了__main_block_dispose_0函数。当Block被废弃时，__main_block_dispose_0函数会被调用，__main_block_dispose_0函数就相当于release操作，将mArr对象的引用计数减1，如果此时引用计数为0，那么遵循引用计数的规则mArr也就被释放了。 3.Block捕获对象与__block变量的区别其实Block捕获对象与__block变量后，对于它们的内存管理的方式相同，也都是使用copy函数持有和disposde函数释放；两者体现在源码上的不同，我们可以观察下面的函数： 1static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;mArr, (void*)src-&gt;mArr, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125; _Block_object_assign函数中的最后一个参数用于区分Block捕获的是对象还是__block变量。 对象变量 __block变量 BLOCK_FIELD_IS_OBJECT BLOCK_FIELD_IS_BYREF 六、Block的循环引用问题Block在从栈拷贝到堆上时，如果其中捕获了强类型的对象，该对象就会被Block所持有。这样很容易就会引起循环引用，我们来看下面的代码： 1234567891011121314151617181920212223242526272829typedef void(^MyBlock)(void);@interface MyObject : NSObject@property(nonatomic,copy) MyBlock block;@end@implementation MyObject- (instancetype)init &#123; self = [super init]; return self;&#125;- (void)dealloc &#123; NSLog(@&quot;MyObject dealloc!&quot;);&#125;@endint main(int argc, char * argv[]) &#123; @autoreleasepool &#123; MyObject *myObject = [[MyObject alloc] init]; myObject.block = ^&#123; //Capturing &#x27;myObject&#x27; strongly in this block is likely to lead to a retain cycle NSLog(@&quot;捕获对象:%@&quot;, myObject ); &#125;; &#125; NSLog(@&quot;myObject的作用域结束了&quot;); return 0;&#125; 不仅编译器给出了内存泄漏的警告，而且测试结果也证实了MyObject的dealloc实例方法并没有执行，这里发生了循环引用。原因就在与myObject的block在被自动拷贝到堆上的过程中持有了myObject，而myObject本身就持有了block，所以两者相互持有就产生了问题。 现在就来总结类似情况下的Block循环引用的处理方法，可分为ARC和MRC两种情况： 1.解决ARC环境下的循环引用问题方法1：使用弱引用修饰符__weak、和__unsafe_unretained修饰符；使用__weak解决上述问题，需要改进的代码如下： 1234567891011int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; MyObject *myObject = [[MyObject alloc] init]; __weak typeof(myObject) weakObject = myObject; myObject.block = ^&#123; NSLog(@&quot;捕获对象:%@&quot;, weakObject ); &#125;; &#125; NSLog(@&quot;myObject的作用域结束了&quot;); return 0;&#125; 上述代码使用弱引用修饰符__weak ，在block内部对 myObject设置为弱引用，弱引用不会导致Block捕获对象的引用计数增加(这在上述分析中已经讲过)。 注意__weak和__unsafe_unretained的区别： __weak：iOS4之后才提供使用，而且比__unsafe_unretained更加安全，因为当它指向的对象销毁时，会自动将指针置为nil；推荐使用。 __unsafe_unretained：在__weak出现以前常用修饰符，其指向的对象销毁时，指针存储的地址值不变，所以没有__weak安全。 方法2：使用__block说明符回忆__block修饰基本类型的C++源码，我们可以知道__block修饰对象时其实也会封装一个结构体类型，而这个结构体中会持有自动变量对象，这样就会造成下图的情况：使用__block解决上述问题，需要改进的代码如下： 12345678910111213int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; MyObject *myObject = [[MyObject alloc] init]; __block MyObject *tempObject = myObject; myObject.block = ^&#123; NSLog(@&quot;捕获对象:%@&quot;, tempObject ); tempObject = nil; //关键代码1 &#125;; myObject.block(); //关键代码2：执行持有的block； &#125; NSLog(@&quot;myObject的作用域结束了&quot;); return 0;&#125; 上述代码有两句关键，已经通过注释标注；在block中通过 tempObject = nil这句代码，__block变量tempObject对于MyObject类对象的强引用失效了，而这句代码生效的前提又是block被调用了(关键代码2)；这种方式避免了循环引用的产生的过程如下图： **特别注意：**如果关键代码2没有被调用，同样会造成循环引用。 使用__block变量相比弱引用修饰符的优缺点:优点： 通过执行block的方式，可动态决定__block变量可以控制对象的持有时间； 在不能使用__weak修饰符的环境下，避免使用__unsafe_unretained(因为要考虑野指针问题)； 缺点：为了避免循环引用，必须执行Block; 2.解决MRC环境下的循环引用问题方法1：使用弱引用修饰符__unsafe_unretained修饰符；在MRC环境下不支持使用__weak，所以只能使用__unsafe_unretained；使用原理同ARC环境下相同，这里不再赘述。 方法2：使用__block说明符MRC环境下，__block说明符被用来避免循环引用。这是因为当Block从栈拷贝到堆时，若Block使用的变量是附有__block说明符的id类型或者对象类型的自动变量，不会被retain，否则就会被retain。这一点和ARC环境是不同的。现在我们在MRC环境下改进代码，具体如下: 12345678910111213int main(int argc, char * argv[]) &#123; MyObject *myObject = [[MyObject alloc] init]; __unsafe_unretained MyObject *tempObject = myObject; myObject.block = ^&#123; NSLog(@&quot;捕获对象:%@&quot;, tempObject ); &#125;; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; [myObject autorelease]; [pool drain]; //等同于[myObject release]; return 0;&#125;//打印结果：//MyObject dealloc! 上述操作将代码改为了MRC下的自动释放池，相比之前在ARC中使用__block，这里没有在Block内部置nil的操作，也没有调用block，但同样解决了循环引用的问题； 重要总结：__block说明符在ARC与MRC环境下的用途有很大区别，因此在编写代码时我们必须区分好这两种环境；","categories":[{"name":"iOS底层","slug":"iOS底层","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BA%95%E5%B1%82/"}],"tags":[{"name":"Block","slug":"Block","permalink":"https://wuyubeichen.github.io/tags/Block/"}]},{"title":"iOS底层-Block本质及存储域问题","slug":"iOS底层-Block本质及存储域问题","date":"2019-04-12T08:16:49.000Z","updated":"2025-05-03T16:23:50.871Z","comments":true,"path":"2019/04/12/iOS底层-Block本质及存储域问题/","permalink":"https://wuyubeichen.github.io/2019/04/12/iOS%E5%BA%95%E5%B1%82-Block%E6%9C%AC%E8%B4%A8%E5%8F%8A%E5%AD%98%E5%82%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"主要内容： 分析Block的源码 验证Block的本质是对象 理解Block的存储域分类","text":"主要内容： 分析Block的源码 验证Block的本质是对象 理解Block的存储域分类 验证Block的不同存储域 分析Block的Copy原理 一、分析Block的源码为了分析Block的源码，从一个最简单的Block使用示例说起，测试代码如下： 12345678//main.m文件：#import &lt;Foundation/Foundation.h&gt;int main(int argc, char * argv[]) &#123; int num = 10; void (^block)(void) =^&#123;NSLog(@&quot;num = %d&quot;,num);&#125;; block(); return 0;&#125; Objective-C语言是基于C、C++的，为了深入理解Block的底层结构，我们可以通过如下的编译器命令将上述代码转换成C++源码： 1clang -rewrite-objc 源代码文件名(如此例中的main.m) 转化后的C++源码如下: 1234567891011121314151617181920212223242526272829303132333435struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int num; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _num, int flags=0) : num(_num) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int num = __cself-&gt;num; // bound by copyNSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_wd_fhcn9bn91v56nlzv9mt5z8ym0000gn_T_main_9e3646_mi_0,num);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main(int argc, char * argv[]) &#123; int num = 10; void (*myBlock)(void) =((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, num)); ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock); return 0;&#125; 对比OC代码与C++源码中的main函数，我们发现： 创建Block其实是调用了__main_block_impl_0结构体的构造函数； Block中待执行代码也都被封装到了__main_block_func_0函数中； 另外值得注意的是，这些C++的结构体和函数的命名，是根据Block语法所属的函数名(此处为main)和Block语法在该函数出现的顺序值(此处为0)来设定的； 根据这些对应关系，我们对C++源码中的内容一一分析： 1.__main_block_imp_0结构体__main_block_impl_0结构体对应了Block的定义，结构体内部包含了三个成员变量impl、Desc、num。 num其实就是被捕获的变量(后续再讲)，另外还有一个同名的构造函数__main_block_impl_0。可以看到相关的代码如下： 1234567891011struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int num; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _num, int flags=0) : num(_num) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; Block通过调用这里的构造函数得以创建，调用时需传入了四个参数：(void *fp, struct __main_block_desc_0 *desc, int _num, int flags=0)，前三个参数对应成员变量的初始化，而最后一个参数flags携带默认值可暂不考虑； 2.__block_impl结构体__main_block_imp_0结构体的第一个成员变量impl，就是__block_impl结构体类型； 尤其注意： 该结构体中包含有isa指针，从这一点就可以说明Block本质上还是一个OC对象，因为OC中只有对象才会具有isa指针的概念； FuncPtr是一个函数指针，在__main_block_imp_0构造函数调用时被赋值； 3.__main_block_desc_0结构体__main_block_imp_0结构体构造函数中传入参数desc，其实就是__main_block_desc_0对象。该结构体包含两个成员变量： reserved：系统保留值； Block_size：代表Block的大小； 4.__main_block_func_0函数__main_block_imp_0结构体构造函数中传入函数指针fp，其实就是__main_block_func_0函数的地址； 该函数是将Block中所有的代码封装为函数，以待被调用； 5.总结Block的特点 Block本质上一个OC对象：比如这里的Block，其底层对应了__main_block_impl_0结构体，而且内部包含有isa指针； Block中携带了函数执行的环境：此处Block里待执行的代码，在底层被封装为__main_block_func_0函数，以实现调用； Block相当于其他语言中的闭包或者匿名函数：它与函数区别在于，Block相当于函数+函数执行的上下文环境(捕获外部变量下面会讲到)； 二、验证Block的本质是对象下面通过打印的方式验证Block对象本质，测试代码如下： 12345678910111213141516- (void)testBlock5 &#123; void(^block)(int a) = ^(int a) &#123; NSLog(@&quot;This is a block&quot;); &#125;; NSLog(@&quot;%@&quot;,[block class]); NSLog(@&quot;%@&quot;,[[block class] superclass]); NSLog(@&quot;%@&quot;,[[[block class] superclass] superclass]); NSLog(@&quot;%@&quot;,[[[[block class] superclass] superclass] superclass]);&#125;//打印结果：//__NSGlobalBlock__//__NSGlobalBlock//NSBlock//NSObject 观察打印结果： 我们看到Block最终继承于NSObject类型，这里再一次验证了Block本质就是OC对象的结论； 而打印结果中出现的__NSGlobalBlock__，说明此处的Block的存储域为静态区； 三、理解Block的存储域分类在之前Block结构体构造函数中，我们很容易能找到这样一句代码： 1impl.isa = &amp;_NSConcreteStackBlock; 我们已经知道Block也是一个OC对象，而每个OC对象都有一个isa指针指向其类对象，这里的情况也是类似的； 这里Block的isa指针指向了_NSConcreteStackBlock类对象，即此时的Block是以_NSConcreteStackBlock类为模板创建的实例； 除此之外，其实还有两个与之类似的类_NSConcreteGlobalBlock和_NSConcreteMallocBlock，不同的Block类创建的对象用于不同的存储域，也对应了对应不同的OC类型，具体整理如下： clang类 OC类 内存区域 _NSConcreteStackBlock __NSStackBlock__ 栈区 _NSConcreteMallocBlock __NSMallocBlock__ 堆区 _NSConcreteGlobalBlock __NSGlobalBlock__ 静态区 四、验证Block的不同存储域不同存储域的Block使用方式有很大差别，而正确区分Block类型的关键在于：Block中是否引用了自动变量(需要MRC下测试)，总结起来如下： Block类型 环境 内存区域 _NSConcreteGlobalBlock(__NSGlobalBlock__) 没有访问自动变量；或者只用到静态区变量 静态区 _NSConcreteStackBlock( __NSStackBlock__) 访问了自动变量 栈区 _NSConcreteMallocBlock(__NSMallocBlock__) __NSStackBlock__调用了copy 堆区 为了验证上述情况，我们需要切换到MRC环境下，因为在ARC环境下的编译器为我们做了很多优化的工作，比如自动将栈区的Block拷贝到堆区，这样我们也就不容易捕获到Block初始状态的位置了。 所以，这里暂时将开发环境切换至MRC下来测试，相关的测试代码如下： 1234567891011121314151617181920212223- (void)testBlock7 &#123; //1.Block内部没有调用外部自动变量 void (^block1)(void) = ^&#123; NSLog(@&quot;Block&quot;); &#125;; //2.Block内部调用外部自动变量 int a = 10; void (^block2)(void) = ^&#123; NSLog(@&quot;Block-%d&quot;,a); &#125;; //3.拷贝栈上的block void (^block3)(void) = ^&#123; NSLog(@&quot;Block-%d&quot;,a); &#125;; //打印Block类型 NSLog(@&quot;%@ %@ %@&quot;, [block1 class], [block2 class], [[block3 copy] class]);&#125;//打印结果：//__NSGlobalBlock__ __NSStackBlock__ __NSMallocBlock__ 1.NSGlobalBlock(静态区) 判断依据：Block中没有引用自动变量或者只用到静态区变量； 此类型的Block与全局变量一样设置在程序的静态区，直到程序结束才会被回收； 此类型的Block不依赖执行时的状态，所以整个程序只需一个实例，用的也较少； 2.NSStackBlock(栈区) 判断依据：Block中访问自动变量，并且存放在栈中； 栈中的内存由系统自动分配和释放，作用域执行完毕之后就会被立即释放； 所以我们有可能遇到Block内存销毁之后才使用它的情况，开发中遇到的很多问题也都是因此而起； 3.NSMallocBlock(堆区) _NSStackBlock__执行copy操作会生成__NSMallocBlock__； 栈Block被拷贝后存放在堆中后，需要我们自己进行内存管理，否则还可能造成一些循环引用的问题； 五、分析Block的Copy原理Block有着不同的存储域类型，尤其是配置在栈上的Block(即__NSStackBlock__类型的Block)，如果其所属的作用域结束，该Block就会被释放，此时若继续使用Block，就会造成野指针问题； 所以，我们通常的做法就是执行copy操作，将其由栈区拷贝到堆区得到__NSMallocBlock__，而__NSMallocBlock__也会在其引用计数为0的时候被释放； 进一步分析Block的拷贝，需要分为MRC和ARC两种环境来考虑。 1.MRC下的Block拷贝在MRC环境下，我们只能显式的通过copy来实现Block的拷贝；通常为了避免Block的释放，我们定义Block属性的时候必须使用copy修饰符也正是基于这个原因。 下面是在MRC环境下测试栈Block的使用，具体代码如下： 1234567891011121314151617181920212223242526272829303132typedef void(^PrintBlock)(void);@interface ViewController ()@property (nonatomic ,copy)PrintBlock block1;@property (nonatomic ,copy)PrintBlock block2;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self createBlock]; self.block1(); self.block2(); NSLog(@&quot;block1:%@&quot;, [self.block1 class]); //报错Thread 1: EXC_BAD_ACCESS (code=1, address=0x7ffeeb90b8c0) NSLog(@&quot;block2:%@&quot;, [self.block2 class]);&#125;- (void)createBlock &#123; int a = 10; //此处采用直接赋值的方式，不会触发setter方法 _block1 = ^&#123; NSLog(@&quot;This is block1-%d&quot;,a); &#125;; self.block2 = ^&#123; NSLog(@&quot;This is block2-%d&quot;,a); &#125;; //离开此作用域，block1就会被释放 NSLog(@&quot;block1:%@、block2:%@&quot;, [self.block1 class],[self.block2 class]);&#125;@end 打印结果及分析如下： 123block1:__NSStackBlock__、block2:__NSMallocBlock__This is block1-10This is block2-10 由于block1采用的是直接赋值的方式，没有调用setter方法，所以block1并没有被拷贝到堆上，是一个栈上的Block，这样也就直接导致了第二次打印block1时所发生的野指针崩溃； 2.ARC下的Block拷贝在ARC环境下，编译器会根据情况自动将栈上的Block复制到堆上，总结有以下几种情况: Block作为函数返回值时；这就类似于MRC中对返回值Block执行了[[returnedBlock copy] autorelease]; Block被强引用，如Block被赋值给__strong或者id类型； Block作为GCD API的方法参数时； Block作为系统方法名含有usingBlock的方法参数时; 下面的代码演示了这些情况： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051typedef void(^Block)(void);-(Block)getBlock&#123; //ARC下的Block中访问了auto变量，此时block类型应为__NSStackBlock__ int a = 10; return ^&#123; NSLog(@&quot;---------%d&quot;, a); &#125;;&#125;- (void)testBlock9 &#123; //1.测试block作为函数返回值时 NSLog(@&quot;bock1-：%@&quot;,[[self getBlock] class]); //2.测试将block赋值给__strong指针时 int a = 10; //2.1.block内没有访问auto变量 Block block21 = ^&#123; NSLog(@&quot;block21&quot;); &#125;; NSLog(@&quot;block21-%@&quot;,[block21 class]); //2.2.block内访问了auto变量，但没有赋值给__strong指针 NSLog(@&quot;block22-%@&quot;,[^&#123; NSLog(@&quot;block22-%d&quot;, a); &#125; class]); //2.3.block赋值给__strong指针 Block block23 = ^&#123; NSLog(@&quot;block23&quot;); &#125;; NSLog(@&quot;block23-%@&quot;,[block23 class]); //3.block作为Cocoa API中方法名含有usingBlock的方法参数时 NSArray *array = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;]; [array enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; &#125;]; //4.block作为GCD API的方法参数时 //Block中的延时操作完成时，系统将会对Block进行释放 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; &#125;);&#125;//打印结果如下://bock1-：__NSMallocBlock__//block21-__NSGlobalBlock__//block22-__NSStackBlock__//block23-__NSGlobalBlock__ 3.其他存储域Block的拷贝上面讲述的重点都于对栈Blok的拷贝，若是对于已经配置在堆上或者配置在静态区的上的Block调用copy方法又将如何呢？下面是不同存储域的Block执行copy进行的总结： Block类型 副本源的配置存储域 复制效果 _NSConcreteStackBlock 栈区 从栈复制到堆 _NSConcreteGlobalBlock 静态区 什么也不做 _NSConcreteMallocBlock 堆区 引用增加 4. 总结Block需要拷贝的原理Block默认创建于其所在函数的函数栈上，所以当函数作用域结束时就会随之销毁； 在MRC环境下，没有编译器的优化，所以我们非常强调要使用copy将Block拷贝到堆上，从而避免Block在其作用域结束时被直接释放; 在ARC环境下，编译器会根据情况自动将栈上的Block复制到堆上，对于Block使用copy还是strong效果是一样的，所以写不写copy都行。在ARC环境下对于Block依然使用copy，更像是从MRC遗留下来的“传统”，时刻提醒我们：编译器自动对Block进行了拷贝操作。如果不写copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对Block进行了拷贝操作”，他们有可能会在调用之前自行拷贝属性值，这种操作多余而低效。 最后，总结Block修饰符的使用： 123456//MRC下block属性的建议写法：@property (copy, nonatomic) void (^block)(void);//ARC下block属性的建议写法：@property (strong, nonatomic) void (^block)(void);@property (copy, nonatomic) void (^block)(void); 参考链接 苹果官方Block文档 深入研究 Block 捕获外部变量和 __block 实现原理 Block 到底啥时候会崩溃 为何调用block应先判空 iOS底层原理总结 - 探寻block的本质(一) 在block内如何修改block外部变量引发的思考 二级指针的作用详解 iOS Block底层探索 iOS底层-Block底层原理 苹果开源代码-libClosure 漫谈Block(理解Block_layout)","categories":[{"name":"iOS底层","slug":"iOS底层","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BA%95%E5%B1%82/"}],"tags":[{"name":"Block","slug":"Block","permalink":"https://wuyubeichen.github.io/tags/Block/"}]},{"title":"iOS开发-ReactiveCocoa基础篇","slug":"iOS开发-ReactiveCocoa基础篇","date":"2019-03-03T06:58:39.000Z","updated":"2025-05-03T16:11:28.661Z","comments":true,"path":"2019/03/03/iOS开发-ReactiveCocoa基础篇/","permalink":"https://wuyubeichen.github.io/2019/03/03/iOS%E5%BC%80%E5%8F%91-ReactiveCocoa%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"ReactiveCocoa(简称RAC)，Reactive表示响应式，Cocoa是苹果整个框架的简称，许多苹果框架都以Cocoa结尾。所以RAC是Github上为我们提供函数响应式编程方法的iOS开发框架。","text":"ReactiveCocoa(简称RAC)，Reactive表示响应式，Cocoa是苹果整个框架的简称，许多苹果框架都以Cocoa结尾。所以RAC是Github上为我们提供函数响应式编程方法的iOS开发框架。 主要内容： 了解函数响应式编程 ReactiveCocoa简介 ReactiveCocoa集成 理解什么是信号 从源码理解RAC的信号机制 本篇总结 一、了解函数响应式编程 函数式编程(Funcational Programming)使用高阶函数编程，即函数可采用多种函数作为它们的参数和返回值。 响应式编程(Reactive Programming)一种面向数据流和变化传播的编程范式 函数响应式编程(Funcational Reacitve Programming)简称FRP，ReactiveCocoa就是一个典型的FRP框架，响应式的编程思想，函数式的代码形式。 二、ReactiveCocoa简介iOS开发中，我们需要使用按钮点击、代理、通知等这些方法来处理响应事件。而RAC框架使用Category为很多基本的UIKit控件添加信号Signal，这样我们可以通过信号来监听数据流与变化传播，把将监听的代码与处理代码放在一起，从而方便我们管理。利用此特点结合MVVM架构，RAC也有十分显著的作用。 三、ReactiveCocoa集成RAC.5.0相对于之前版本对于自身项目结构进行了较大调整，被拆分ReactiveCocoa、ReactiveSwift、ReactiveObjC、ReactiveObjCBridge四个库，我们需要根据不同的情况来集成。GitHub地址：https://github.com/ReactiveCocoa/ReactiveCocoa通常，我们都使用Cocoapods集成RAC，需要注意的是Podfile文件中必须使用user_framework!，然后，针对于不同的代码环境，有三种集成情况： 1.纯OC工程ReactiveObjc库包含原RAC2的全部代码，在纯OC工程中使用 12345platform :ios, &#x27;8.0&#x27;use_frameworks! #必须添加target &#x27;ZSTest&#x27; do #工程名#pod &#x27;ReactiveObjC&#x27; #默认导入最新的RAC版本 end 2.纯Swift工程纯Swfit工程继续使用ReactiveCocoa，但RAC依赖ReactiveSwift，所以相当于引入两个库。集成方法同上，只不过将ReactiveObjc换成ReactiveCocoa。 3.OC与Swift混编工程混编工程需要同时引入ReactiveCocoa与ReactiveObjCBridge，但是ReactiveObjCBridge库依赖于ReactiveObjc库，所以相当于同时引入四个库了。示例如下： 1234567platform :ios, &#x27;8.0&#x27;use_frameworks! #必须添加target &#x27;ZSTest&#x27; do #工程名pod &#x27;ReactiveCocoa&#x27;pod &#x27;ReactiveObjC&#x27; pod &#x27;ReactiveObjCBridge&#x27;end 四、ReactiveCocoa信号理解我觉得学习RAC的第一个关口就是理解信号RACSignal了，什么是信号也许是困惑我们的第一个问题。 作为RAC中最为核心的一个类，信号可以理解为传递数据变化信息的工具，信号会在数据发生变化时发送事件流给它的订阅者，然后订阅者执行响应方法。信号本身不具备发送信号的能力，而是交给一个订阅者去发出。 首先上一段代码，演示信号的一个基本使用。测试场景：我们要对一个用于输入用户名的UITextFiled进行检测，每次输入内容变化的时候都打出输入框的内容，使用RAC来实现此操作的关键代码如下： 123[self.userNameTxtField.rac_textSignal subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@&quot;测试：%@&quot;,x);&#125;]; 1234控制台打印：2018-03-23 17:57:00.497956+0800 ZSTest[4351:263810] 测试：12018-03-23 17:57:00.498237+0800 ZSTest[4351:263810] 测试：122018-03-23 17:57:00.498375+0800 ZSTest[4351:263810] 测试：123 没错的，不使用代理方法，也没有action的响应处理，我们仅仅使用了一行方法就实现了对文本框输入内容的实时打印。由此，RAC的实用性可见一斑。 五、ReactiveCocoa信号机制我们会对上面的代码产生疑问，RAC是怎么做到上述代码功能的呢？而且我们常说的订阅者又在哪里呢？ 其实RAC已经使用Category的形式为我们基本的UI控件创建了信号(如上例中的rac_textSignal)，所以这里我们才可以很方便的实现信号订阅，而且订阅者在整个过程中也是对于我们隐藏的。 现在我们使用自定义信号的方法，从创建信号到订阅信号细致的了解一下这个过程。首先上一段创建信号的测试代码如下： 12345678910111213141516171819202122232425//创建信号RACSignal *testSignal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; //1.订阅者发送信号内容 [subscriber sendNext:@&quot;发送信号内容&quot;]; //2.订阅者发送信号完成的信息，不需要再发送数据时，最好发送信号完成，可以内部调起清理信号的操作。 [subscriber sendCompleted]; //3.创建信号的Block参数，需要返回一个RACDisposable对象 ，可以返回nil。 //RACDisposable对象用于取消订阅信号，此block在信号完成或者错误时调用。 RACDisposable *racDisposable = [RACDisposable disposableWithBlock:^&#123; NSLog(@&quot;信号Error或者Complete时销毁&quot;); &#125;]; return racDisposable;&#125;]; //订阅信号[testSignal subscribeNext:^(id _Nullable x) &#123; //新变化的值 NSLog(@&quot;订阅信号：subscribeNext:%@&quot;,x);&#125; error:^(NSError * _Nullable error) &#123; //信号错误，被取消订阅,被移除观察 NSLog(@&quot;订阅信号：Error:%@&quot;,error.description);&#125; completed:^&#123; //信号已经完成，被取消订阅，被移除观察 NSLog(@&quot;订阅信号：subscribeComplete&quot;);&#125;]; 1234控制台打印:2018-03-23 17:57:00.497956+0800 ZSTest[4351:263810] 订阅信号：subscribeNext:发送信号内容2018-03-23 17:57:00.498237+0800 ZSTest[4351:263810] 订阅信号：subscribeComplete2018-03-23 17:57:00.498375+0800 ZSTest[4351:263810] 信号Error或者Complete时销毁 我们通过观察源码来理解整个过程: 1.创建信号创建信号，我们需要使用RACSignal的类方法createSignal。该方法需要一个Block作为参数。查看源码，我们就会发现RACSignal最终是通过调用自己子类RACDynamicSignal的createSignal方法，将这个Block设置给了自己的didSubscribe属性的。 1234//RACSignal.m文件+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123; return [RACDynamicSignal createSignal:didSubscribe];&#125; 12345//RACDynamicSignal.h文件@interface RACDynamicSignal ()// The block to invoke for each subscriber.@property (nonatomic, copy, readonly) RACDisposable * (^didSubscribe)(id&lt;RACSubscriber&gt; subscriber);@end 123456//RACDynamicSignal.m文件+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123; RACDynamicSignal *signal = [[self alloc] init]; signal-&gt;_didSubscribe = [didSubscribe copy]; return [signal setNameWithFormat:@&quot;+createSignal:&quot;];&#125; didSubscribe：这是创建信号时候需要传入的一个block，它的传入参数是订阅者subscriber，而返回值是需要是一个RACDisposable对象。创建信号后的didSubscrib是一个等待执行的block。 RACSubscriber：表示订阅者，创建信号时订阅者发送信号，这里的订阅者是一个协议而非一个类。信号需要订阅者帮助其发送数据。查看RACSubscriber的协议，我可以看到以下几个方法： 12345678//发送信息- (void)sendNext:(nullable id)value;//发送错误消息- (void)sendError:(nullable NSError *)error;//发送完成信息- (void)sendCompleted;//- (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable; 在创建一个信号的时候，订阅者使用sendNext发送信息。而且如果我们不再发送数据，最好在这里执行一次sendCompleted方法，这样的话，信号内部会自动调用对应的方法取消信号订阅。 RACDisposable：这个类用于取消订阅信号和清理资源，在信号出现错误或者信号完成的时候，信号会自动调起RACDisposable对象的block方法。在代码中我们也可以看到，创建RACDisposable对象是使用disposableWithBlock方法设置了一个block操作，执行block操作之后，信号就不再被订阅了。 总结：创建信号就是使用createSignal方法，创建一个信号，并为信号设置了一个didSubscribe属性(也就是一系列订阅者需要做的操作)。 2.订阅信号进入订阅信号的源码我们看到如下代码： 12345678- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock error:(void (^)(NSError *error))errorBlock completed:(void (^)(void))completedBlock &#123; NSCParameterAssert(nextBlock != NULL); NSCParameterAssert(errorBlock != NULL); NSCParameterAssert(completedBlock != NULL); RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:errorBlock completed:completedBlock]; return [self subscribe:o];&#125; 在此方法中，我们可以看到订阅信号有两个过程：过程1：使用subscribeNext的方法参数，创建出一个订阅者subscriber。过程2：信号对象执行了订阅操作subscribe，方法中传入参数是刚创建的订阅者。 注：这也就解释了我们常提起却看不见的订阅者存在哪里的问题。真实开发中我们只关心订阅者需要发送的值就行了，而不需要关心其内部订阅的过程。 继续打开信号的subscribe方法，看到源码如下： 12345678910111213- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123; NSCParameterAssert(subscriber != nil); RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]; subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable]; if (self.didSubscribe != NULL) &#123; RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123; RACDisposable *innerDisposable = self.didSubscribe(subscriber); [disposable addDisposable:innerDisposable]; &#125;]; [disposable addDisposable:schedulingDisposable]; &#125; return disposable;&#125; 上面的代码中我们不难看出：除了对于订阅者和清理对象的再次封装外，最重要的就是创建信号时为信号设置Block(didSubscribe)被调用了，而且Block参数使用了我们创建的订阅者。 六、本篇总结1.自创建信号会传入一个Block(didSubscribe)，Block中遵循协议的订阅者会调用sendNext方法发送消息。而在订阅信号subscribeNext时，会在内部创建一个订阅者，并将其传递给原先赋值的didSubscribe，并执行这个Block。 2.但是我们应该注意：上述的分析只是其中信号机制的一种情况罢了。RAC对于UI组件信号的封装可能有所不同，比如之前我们看到的输入框信号，执行订阅信号subscribeNext时并不立即执行打印，而是监听到输入时打印。这其实是该信号使用了concat又做了一系列的操作。对于不同的信号我们只需要理解上述分析中提到几个关键属性，就可以结合源码很好的理解信号机制的使用了。 本篇的重点在于对RAC的基本介绍，是为了更好的理解信号机制，这仅相当于打开一个切入口来认识RAC。关于RAC的详细用法可以参考下一篇：ReactiveCocoa函数响应式编程-应用篇，这里将总结RAC关于信号的各种用法。 其他参考链接：1.ReactiveCocoa入门教程：第一部分2.最快让你上手ReactiveCocoa之基础篇3.这样好用的ReactiveCocoa,根本停不下来4.函数式编程与面向对象的比较","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"响应式编程","slug":"响应式编程","permalink":"https://wuyubeichen.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"iOS开发-ReactiveCocoa应用篇","slug":"iOS开发-ReactiveCocoa应用篇","date":"2019-03-02T06:58:39.000Z","updated":"2025-05-03T16:11:31.345Z","comments":true,"path":"2019/03/02/iOS开发-ReactiveCocoa应用篇/","permalink":"https://wuyubeichen.github.io/2019/03/02/iOS%E5%BC%80%E5%8F%91-ReactiveCocoa%E5%BA%94%E7%94%A8%E7%AF%87/","excerpt":"使用RAC其实就是一个创建信号订阅信号的过程。上篇ReactiveCocoa函数响应式编程-基础篇，主要简单介绍了RAC的信号机制，本篇则以信号为核心，就信号常用的类、操作信号的方法，替换响应处理等方面总结RAC的使用。","text":"使用RAC其实就是一个创建信号订阅信号的过程。上篇ReactiveCocoa函数响应式编程-基础篇，主要简单介绍了RAC的信号机制，本篇则以信号为核心，就信号常用的类、操作信号的方法，替换响应处理等方面总结RAC的使用。 主要内容 RAC中常用的类 RAC中常用的宏 RAC中信号的常用操作 RAC常用的处理事件响应的方法本篇总结 本篇还提供了关于RAC使用的两个测试工程，结合代码学习更加直观：项目1：1.测试RAC对信号的各类操作。2.使用RAC改进一个普通的登录界面。项目2：MVVM架构结合RAC响应式编程的开发示例。实现登录界面和的分页数据界面。效果图如下： 一、RAC中常用的类1.RACSubjectRACSubject是信号RACSignal的一个子类，但它的底部实现与RACSignal有所不同。其订阅信号subscribeNext的方法只是使用nextBlock创建了一个订阅者并保存起来待用，多次调用subscribeNext会保存多个订阅者。只有发送信号sendNext方法执行时，订阅者才会执行nextBlock里的内容，多个订阅者会执行多次。使用示例： 123456789101112131415161718//1.创建信号//创建RACSubject不需要block参数RACSubject *subject = [RACSubject subject];//2.订阅信号//这里信号被订阅两次，那么订阅者也创建了两次，保存在RACSubject的subscribers属性数组中。//那么每当信号有新值发出的时候，每个订阅者都会执行。 [subject subscribeNext:^(id x) &#123; //block在信号发出新值时调用 NSLog(@&quot;第一个订阅者:%@&quot;,x);&#125;];[subject subscribeNext:^(id x) &#123; NSLog(@&quot;第二个订阅者:%@&quot;,x);&#125;]; //3.发送信号[subject sendNext:@&quot;6”]; 123控制台打印：2018-03-24 13:07:51.425569+0800 ZSTest[2840:124915] 第一个订阅者:62018-03-24 13:07:51.426113+0800 ZSTest[2840:124915] 第二个订阅者:6 应用示例：替换代理我们测试这样一个功能：在当前视图控制器A中点击按钮调转到下一视图控制器B，在B的文本框中输入内容，点击编辑完成按钮回到A，显示B中输入的内容到A的UILabel上。通常我们使用代理来解决这样的问题，那么现在我们可以利用RACSubject的特性来代替常用的代理的功能，其实就跟我们使用block回调一样。具体代码如下： 12345//1.下一视图控制中添加RACSubject属性。//SecondViewController.h文件@interface SecondViewController : BaseViewController@property (nonatomic, strong) RACSubject *racSubject;@end 12345678//2.点击编辑完成按钮时，检查代理信号并发送消息，这里传递出一个字典(包含输入的文字)//SecondViewController.m文件- (IBAction)completeBtnClick:(id)sender &#123; if(self.racSubject)&#123; [self.racSubject sendNext:@&#123;@&quot;text&quot;:self.txtField.text&#125;]; &#125; [self.navigationController popViewControllerAnimated:YES];&#125; 1234567891011121314//3.当前视图控制器A的跳转按钮响应方法中，创建secondVC，并为其添加信号属性和订阅信号。//TestViewCotroller.m文件- (IBAction)testBtnClick:(id)sender &#123; SecondViewController *secondVC = [[SecondViewController alloc] initWithNibName:@&quot;SecondViewController&quot; bundle:nil]; //为secondVC设置RACSubject属性，并订阅信号 secondVC.racSubject = [RACSubject subject]; __weak typeof(self) weakSelf = self; //定阅信号的block会更新文字的显示 [secondVC.racSubject subscribeNext:^(id _Nullable x) &#123; NSDictionary *infoDic =(NSDictionary *)x; weakSelf.showLabel.text = infoDic[@&quot;text&quot;]; &#125;]; [self.navigationController pushViewController:secondVC animated:YES]; &#125; 2.RACTuple与RACSequenceRACTuple：类似OC的数组，是RAC中用来封装值的元组类，可以配合RACTupleUnpack解元组。RACSequeue：数组和字典经过rac_sequence方法会被转化为RACSequeue类型，并进一步转为我们常用的信号。订阅此类信号的时候，信号就会被激活并遍历其中的所有值。 使用示例： 123456789101112//遍历数组NSArray *characters = @[@&quot;A&quot;,@&quot;C&quot;,@&quot;B&quot;,@&quot;E&quot;,@&quot;D&quot;]; [characters.rac_sequence.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;char:%@&quot;,x);&#125;];控制台打印：char:Achar:Cchar:Bchar:Echar:D 123456789101112//遍历字典NSDictionary *myInfoDic = @&#123;@&quot;name&quot;:@&quot;zs&quot;,@&quot;nickname&quot;:@&quot;FengZi&quot;,@&quot;age&quot;:@&quot;18&quot;&#125;;\\[myInfoDic.rac_sequence.signal subscribeNext:^(id _Nullable x) &#123; //解元组，注意一一对应 RACTupleUnpack(NSString *key,NSString *value) = x; NSLog(@&quot;myInfoDic:%@-%@&quot;,key,value);&#125;];控制台打印：myInfoDic:name-zsmyInfoDic:nickname-FengZimyInfoDic:age-18 3.RACMulticastConnectionRACMulticastConnection用于解决一个信号被多次订阅后，创建信号中的block被重复调用的问题，所以在实际开发中，使用RACMulticastConnection可以解决网络重复请求的问题。测试1:普通的信号 12345678910111213141516171819RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;发送信号A&quot;); [subscriber sendNext:@&quot;发送信号A&quot;]; return nil;&#125;];[signalA subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;第一次订阅：%@&quot;,x);&#125;]; [signalA subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;第二次订阅：%@&quot;,x);&#125;];控制台打印：2018-03-28 10:02:00.702607+0800 ZSTest[2446:48444] 发送信号A2018-03-28 10:02:00.702856+0800 ZSTest[2446:48444] 第一次订阅：发送信号A2018-03-28 10:02:00.703069+0800 ZSTest[2446:48444] 发送信号A2018-03-28 10:02:00.703325+0800 ZSTest[2446:48444] 第二次订阅：发送信号A 测试2：使用RACMulticastConnection 12345678910111213141516171819202122232425262728//1.创建信号RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;发送信号B&quot;); [subscriber sendNext:@&quot;发送信号B&quot;]; return nil;&#125;]; //2.连接信号：publish或者muticast方法//连接后的信号使用订阅方法时，并不能激活信号，而是将其订阅者保存到数组中。//在连接对象执行connect方法时，信号中的订阅者会统一调用sendNext方法。RACMulticastConnection *signalBconnect = [signalB publish]; //3.订阅信号//使用signalBconnect而不再是signalB[signalBconnect.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;第一次订阅：%@&quot;,x);&#125;];[signalBconnect.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;第二次订阅：%@&quot;,x);&#125;];//4.连接后激活信号[signalBconnect connect];控制台打印：2018-03-28 10:02:00.704209+0800 ZSTest[2446:48444] 发送信号B2018-03-28 10:02:00.704368+0800 ZSTest[2446:48444] 第一次订阅：发送信号B2018-03-28 10:02:00.704543+0800 ZSTest[2446:48444] 第二次订阅：发送信号B 4.RACCommand：用于处理事件的类RACCommand可以把事件如何处理，如何传递都封装到类中，之后就可以方便的调起它的执行方法。在实际开发中，我们可以用它来封装一个网络操作。注意：1.创建方法中block返回一个信号，且不能为nil，但是可以使用[RACSignal empty]表示空信号2.RACCommand必须被强引用，否则容易被释放 12345678910111213141516171819202122232425262728293031323334353637383940//1.创建RACCommand：initWithSignalBlockself.command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id _Nullable input) &#123; //我们常在这里创建一个网络请求的信号，也就是封装一个请求数据的操作。 RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;网络请求的信号&quot;]; //数据传递完成，必须调用sendComplleted.,否则永远处于执行中。 [subscriber sendCompleted]; return nil; &#125;]; return signal;&#125;]; //2.订阅RACCommand中的信号，要等到RACCommand执行后，才能收到消息[self.command.executionSignals subscribeNext:^(id _Nullable x) &#123; //这里是一个信号中信号 [x subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;收到信号：%@&quot;,x); &#125;];&#125;];//改进订阅方法：switchToLatest可以直接获取信号中信号[self.command.executionSignals.switchToLatest subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;改进-收到信号：%@&quot;,x);&#125;]; //3.监听RACCommand命令是否执行完毕的信号//默认会监测一次，所以可以使用skip表示跳过第一次信号。//这里可以用于App网络请求时，控制加载提示视图的隐藏或者显示[[self.command.executing skip:1] subscribeNext:^(NSNumber * _Nullable x) &#123; if([x boolValue] == YES)&#123; NSLog(@&quot;RACCommand命令正在执行...&quot;); &#125;else&#123; NSLog(@&quot;RACCommand命令不在执行中！！！&quot;) &#125;&#125;]; //4.执行RACComand//方法：- (RACSignal *)execute:(id)input[self.command execute:@&quot;&quot;]; 12345控制台打印：2018-03-24 14:43:06.571968+0800 ZSTest[3725:171859] RACCommand命令正在执行...2018-03-24 14:43:06.572526+0800 ZSTest[3725:171859] 收到信号：网络请求的信号2018-03-24 14:43:06.572662+0800 ZSTest[3725:171859] 改进-收到信号：网络请求的信号2018-03-24 14:43:06.573506+0800 ZSTest[3725:171859] RACCommand命令不在执行中！！！ 二、RAC常用的宏定义1.RAC(对象，对象属性)：绑定属性输入框背景色绑定了映射后的validUserNameSignal信号，信号变化时背景色更新 123RAC(self.userNameTxtField,backgroundColor) = [validUserNameSignal map:^id _Nullable(NSNumber *userNameValid) &#123; return [userNameValid boolValue] ? [UIColor whiteColor] : [UIColor yellowColor];&#125;]; 2.RACObserve(被观察的对象，被观察对象的属性) ：代替KVO监听某个对象的某个属性123456[RACObserve(self.view, backgroundColor) subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;测试：%@&quot;,x);&#125;];//颜色变化时将打印self.view.backgroundColor = [UIColor whiteColor];self.view.backgroundColor =[UIColor redColor]; 3.RACTuplePack与RACTupleUnpackRACTuplePack：将数据封装成元组RACTupleUnpack：将元组解包为数据 1234567//使用RACTuplePack封装元组RACTuple *racTuple = RACTuplePack(@&quot;字符串1&quot;,@&quot;字符串2&quot;);NSLog(@&quot;测试racTuple:%@&quot;,racTuple);//使用RACTupleUnpack解元组RACTupleUnpack(NSString *str1,NSString *str2) = racTuple;NSLog(@&quot;测试RACTupleUnpack：%@-%@&quot;,str1,str2); 123456控制台打印：2018-03-26 19:27:27.568399+0800 ZSTest[23113:380213] 测试racTuple:&lt;RACTwoTuple: 0x60400000ed70&gt; ( &quot;\\U5b57\\U7b26\\U4e321&quot;, &quot;\\U5b57\\U7b26\\U4e322&quot;)2018-03-26 19:27:27.568623+0800 ZSTest[23113:380213] 测试RACTupleUnpack：字符串1-字符串2 4.@weakify、@strongifyRAC中使用@weakify、@strongify解决Block循环引用的问题。在block内部使用@strongify(self)后就可以使用self操作属性了，但是一定注意这两个宏定义一定要配合使用，可参考源码分析。 1234567@weakify(self);//RAC处理手势，点击页面，隐藏键盘[self.tapGesture.rac_gestureSignal subscribeNext:^(__kindof UIGestureRecognizer * _Nullable x) &#123; @strongify(self); //经过宏定义处理后就可以使用self了，但此self非彼self。具体可查看源码分析 [self.view endEditing:YES];&#125;]; 三、RAC中关于信号的常用操作本节整理了以下几种常用信号操作：1.信号映射：map与flattenMap2.信号过滤：filter、ignore、 distinctUntilChanged3.信号合并： combineLatest、reduce、merge、zipWith4.信号连接：concat、then5.信号操作时间：timeout、interval、dely6.信号取值：take、takeLast、takeUntil、7.信号跳过：skip8.信号发送顺序：donext、cocompleted9.获取信号中的信号：switchToLatest10.信号错误重试：retry11.信号节流：throttle12.信号操作多线程：deliverON、subscribeOn 1.信号映射：map与flattenMapmap：将信号内容修改为另一种新值。改变了传递的值flattenMap：将源信号映射修改为另一种新的信号。修改了信号本身 1.1、map将信号文本值修改为文本长度 1234567//block中return的是你希望接收到的值[[self.txtField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return @(value.length);//必须返回一个对象&#125;] subscribeNext:^(id _Nullable x) &#123; //输入abcd，打印了输入字符的长度 NSLog(@&quot;打印x:%@&quot;,x);&#125;]; 12345控制台打印：2018-03-23 10:52:41.831785+0800 ZSTest[1143:44274] 打印x:12018-03-23 10:52:42.575238+0800 ZSTest[1143:44274] 打印x:22018-03-23 10:52:43.602008+0800 ZSTest[1143:44274] 打印x:32018-03-23 10:52:44.054940+0800 ZSTest[1143:44274] 打印x:4 1.2、flattenMapflattenMap的block返回的是你想要的信号 1234567891011121314151617181920212223242526//创建一个普通信号RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;发送信号：1&quot;]; [subscriber sendCompleted]; return nil;&#125;];//创建一个发送信号的信号，信号的信号RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:signal]; [subscriber sendCompleted]; return nil;&#125;]; //订阅信号中的信号[signalOfSignals subscribeNext:^(id _Nullable x) &#123; //不使用flattenMap，会打印出内部信号 NSLog(@&quot;订阅signalOfSignals：%@&quot;,x);&#125;]; [[signalOfSignals flattenMap:^__kindof RACSignal * _Nullable(id _Nullable value) &#123; return value; &#125;] subscribeNext:^(id _Nullable x) &#123; //使用flattenMap，会打印内部信号的值 NSLog(@&quot;使用flattenMap后订阅signalOfSignals：%@&quot;,x);&#125;]; 123控制台打印：2018-03-23 11:23:42.920455+0800 ZSTest[1363:61658] 订阅signalOfSignals：&lt;RACDynamicSignal: 0x60400023a320&gt; name: 2018-03-23 11:23:42.920791+0800 ZSTest[1363:61658] 使用flattenMap后订阅signalOfSignals：发送信号：1 特别说明：信号中信号常出现在我们封装一个网络请求为信号的时候，这时候注意flattenMap的使用。 2.信号过滤：filter、ignore、 distinctUntilChanged2.1、filter过滤信号，符合条件的信号才能发出消息。示例：输入1234，当输入到4(文本长度大于3)的时候才开始打印如下的信息 12345678[[self.txtField.rac_textSignal filter:^BOOL(NSString * _Nullable value) &#123; return value.length &gt; 3; &#125;] subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@&quot;打印x：%@&quot;,x);&#125;];控制台打印：2018-03-23 11:39:23.371432+0800 ZSTest[1428:68939] 打印x：1234 2.2、ignore忽略信号，针对信号值的某一种状态进行忽略，忽略时不会发送消息。示例：监听每次的输入，但是当文本框内的内容是”a”时不会打印 123[[self.txtField.rac_textSignal ignore:@&quot;a&quot;] subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@&quot;ignore测试打印：%@&quot;,x);&#125;]; 2.3、distinctUntilChanged当上次的值与当前值有变化时才会发出消息，否则信息被忽略 12345678910111213141516//为了方便测试，我们监测控制器的currentText属性来修改Label的文本值。__weak typeof(self)weakSelf = self;[[RACObserve(self, currentText) distinctUntilChanged] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;使用%@更新testLabel的值&quot;,x); weakSelf.testLabel.text = x;&#125;];//currentTxt未被赋初值，所以第一次打印null,我们自己修改三次值，只打印两次self.currentText = @&quot;hello&quot;;self.currentText = @&quot;world&quot;;self.currentText = @&quot;world&quot;;控制台打印:2018-03-23 16:43:54.617385+0800 ZSTest[3598:220992] 使用(null)更新testLabel的值2018-03-23 16:43:54.618026+0800 ZSTest[3598:220992] 使用hello更新testLabel的值2018-03-23 16:43:54.618380+0800 ZSTest[3598:220992] 使用world更新testLabel的值 3.信号合并：combineLatest、reduce、merge、zipWith为了便于测试，这里先创建两个RACSubject类型的信号用于测试，此类信号只有发送信号sendNext方法执行时，订阅者才会执行nextBlock里的内容; 123456789RACSubject *signalOne = [RACSubject subject];[signalOne subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;订阅信号one：%@&quot;,x);&#125;];RACSubject *signalTwo = [RACSubject subject];[signalTwo subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;订阅信号Two：%@&quot;,x);&#125;]; 3.1、combineLatest：合并信号合并信号的效果就是，这多个信号都至少有过一次订阅信号sendNext的操作，才会触发合并的信号。下面的测试如果只有signalOne执行sendNext方法，那么combineLatest后的信号不会被触发。 12345678[[RACSignal combineLatest:@[signalOne,signalTwo]] subscribeNext:^(RACTuple * _Nullable x) &#123; //解元组：合并信号得到的是一个元组,里面存放的是两个信号发送的消息 RACTupleUnpack(NSString *str1,NSString *str2) = x; NSLog(@&quot;combineLatest:str1-%@,str2-%@&quot;,str1,str2);&#125;];[signalOne sendNext:@&quot;1&quot;];[signalTwo sendNext:@&quot;2”]; 1234567控制台打印：2018-03-23 14:29:53.198724+0800 ZSTest[2172:143774] 订阅信号one：12018-03-23 14:29:53.199673+0800 ZSTest[2172:143774] 订阅信号Two：22018-03-23 14:29:53.200075+0800 ZSTest[2172:143774] combineLatest:&lt;RACTuple: 0x60000000d9a0&gt; ( 1, 2) 3.2、reduce：聚合信号combineLatest合并后的信号订阅后，得到的是一个元组(包含每个被合并信号的新值)。然而在开发中，我们往往需要检测多个信号合并后的效果(比如用户名和密码信号有效时，登录按钮才可以点击)，这里就用到了reduce来实现信号聚合。reduce聚合操作中的block参数个数随合并信号的数量而定，有多少个信号被合并，blcok中的参数就有多少个。这些参数一一对应被合并的信号，是它们对应的新值。 1234567[[RACSignal combineLatest:@[signalOne,signalTwo] reduce:^id(NSString *strOne,NSString *strTwo)&#123; return [NSString stringWithFormat:@&quot;%@-%@&quot;,strOne,strTwo];&#125;] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;combineLatest-reduce：%@&quot;,x);&#125;];[signalOne sendNext:@&quot;1&quot;];[signalTwo sendNext:@&quot;2&quot;]; 1234控制台打印：2018-03-23 14:40:08.977580+0800 ZSTest[2288:149816] 订阅信号one：12018-03-23 14:40:08.978566+0800 ZSTest[2288:149816] 订阅信号Two：22018-03-23 14:40:08.979587+0800 ZSTest[2288:149816] combineLatest-reduce：1-2 3.3、merge：合并信号当合并后的信号被订阅时，就会订阅里面所有的信号测试1：将多个信号合并之后，当其中任何一个信号发送消息时，都能被监测到。 123456RACSignal *mergeSignal = [signalOne merge:signalTwo];[mergeSignal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;mergeSignal：%@&quot;,x);&#125;];//只调用其中一个信号,就会触发merge合并的信号[signalOne sendNext:@&quot;测试信号1&quot;]; 123控制台打印：2018-03-23 14:53:34.342899+0800 ZSTest[2577:160009] 订阅信号one：测试信号12018-03-23 14:53:34.343124+0800 ZSTest[2577:160009] mergeSignal：测试信号1 测试2：当合并后的信号被订阅时，就会订阅里面所有的信号 1234567891011121314RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;signal1&quot;]; return nil;&#125;];RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;signal2&quot;]; return nil;&#125;];RACSignal *mergeSignals = [signal1 merge:signal2]; [mergeSignals subscribeNext:^(id x) &#123; NSLog(@&quot;mergeSignals：%@&quot;,x);&#125;]; 123控制台打印：2018-03-23 18:10:29.623099+0800 ZSTest[4444:270816] mergeSignals：signal12018-03-23 18:10:29.623721+0800 ZSTest[4444:270816] mergeSignals：signal2 3.4、zipWith：压缩信号1.zipWith把两个信号压缩成为一个信号。2.只有当两个信号同时发出信号时，两个信号的内容才会被合并为一个元组，触发压缩流的next事件。比如：当一个界面多个请求的时候，要等所有请求完成才更新UI。元组内元素顺序只与压缩信号的顺序有关，与发送信号的顺序无关。 123456789RACSignal *zipSignal = [signalOne zipWith:signalTwo];[zipSignal subscribeNext:^(id _Nullable x) &#123; //解元组：合并信号得到的是一个元组,里面存放的是两个信号发送的消息 RACTupleUnpack(NSString *str1,NSString *str2) = x; NSLog(@&quot;zipSignal：str1-%@,str2-%@&quot;,str1,str2);&#125;];[signalOne sendNext:@&quot;测试zipSignalMsgOne&quot;];[signalTwo sendNext:@&quot;测试zipSignalMsgTwo&quot;]; 1234控制台打印：2018-03-23 15:23:58.989780+0800 ZSTest[2926:177798] 订阅信号one：测试zipSignalMsgOne2018-03-23 15:23:58.990012+0800 ZSTest[2926:177798] 订阅信号Two：测试zipSignalMsgTwo2018-03-23 15:23:58.991056+0800 ZSTest[2926:177798] zipSignal：str1-测试zipSignalMsgOne,str2-测试zipSignalMsgTwo 4.信号拼接：concat、then4.1、concat1.使用concat可以按序拼接多个信号，拼接后的信号按序执行。2.使用concat连接信号后，每个信号无需再单独订阅，其内部会按序自动订阅3.前面的信号必须执行sendCompleted，后面的信号才会被激活 1234567891011121314151617181920212223RACSignal *signalOne = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;signalOne&quot;]; [subscriber sendCompleted]; return nil;&#125;]; RACSignal *signalTwo = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;signalTwo&quot;]; [subscriber sendCompleted]; return nil;&#125;];RACSignal *signalThree = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;signalThree&quot;]; [subscriber sendCompleted]; return nil;&#125;]; //拼接了三个信号，订阅之后，三个信号依次激活RACSignal *concatSignal = [[signalOne concat:signalThree] concat:signalTwo];[concatSignal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;信号被激活:%@&quot;,x);&#125;]; 1234控制台打印：2018-03-22 17:36:47.565105+0800 ZSTest[6018:274201] 信号被激活:signalOne2018-03-22 17:36:47.565403+0800 ZSTest[6018:274201] 信号被激活:signalThree2018-03-22 17:36:47.565609+0800 ZSTest[6018:274201] 信号被激活:signalTwo 4.2、then:连接信号使用then连接信号，上一个信号完成后，才会连接then返回的信号，所以then连接的上一个信号必须使用sendCompleted，否则后续信号无法执行。then连接的多个信号与concat不同的是：之前的信号会被忽略掉，即订阅信号只会接收到最后一个信号的值 1234567891011121314151617181920212223[[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;信号1&quot;); [subscriber sendNext:@&quot;发送信号1&quot;]; [subscriber sendCompleted]; return nil; &#125;] then:^RACSignal *&#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;信号2&quot;); [subscriber sendNext:@&quot;发送信号2&quot;]; [subscriber sendCompleted]; return nil; &#125;]; &#125;]then:^RACSignal * _Nonnull&#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;信号3&quot;); [subscriber sendNext:@&quot;发送信号3&quot;]; [subscriber sendCompleted]; return nil; &#125;]; &#125;] subscribeNext:^(id x) &#123; //只能接收到最后一个信号的值 NSLog(@&quot;订阅信号：%@&quot;,x);&#125;]; 12345控制台打印：2018-03-23 16:53:52.819003+0800 ZSTest[3668:227466] 信号12018-03-23 16:53:52.819762+0800 ZSTest[3668:227466] 信号22018-03-23 16:53:52.820008+0800 ZSTest[3668:227466] 信号32018-03-23 16:53:52.820139+0800 ZSTest[3668:227466] 订阅信号：发送信号3 5.信号操作时间：timeout、interval、dely5.1、interval创建定时器信号，每固定时间发送一次信号 1234567RACSignal *intervalSignal = [RACSignal interval:1 onScheduler:[RACScheduler currentScheduler]];//只知道使用take结束定时器这一种方法，不知道还有没有其他方法[[intervalSignal take:5]subscribeNext:^(id _Nullable x) &#123; //订阅定时器信号，启动定时器，只打印5次 NSLog(@&quot;interval,定时器打印&quot;); &#125;]; 5.2、timeout可以设置超时操作，让一个信号在规定时间之后自动报错创建信号时不能使用sendCompleted，因为这样的话一旦发送了消息就取消订阅了。 123456789101112131415RACSignal *timeOutSignal = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;timeOutSignal发送信号&quot;]; //[subscriber sendCompleted]; return nil;&#125;] timeout:5 onScheduler:[RACScheduler currentScheduler]]; [timeOutSignal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;timeOutSignal:%@&quot;,x); &#125; error:^(NSError * _Nullable error) &#123; //5秒后执行打印： //timeOutSignal:出现Error-Error Domain=RACSignalErrorDomain Code=1 &quot;(null)&quot; NSLog(@&quot;timeOutSignal:出现Error-%@&quot;,error);&#125; completed:^&#123; NSLog(@&quot;timeOutSignal:complete&quot;);&#125;]; 5.3、delay延迟发送sendNext 123456789RACSignal *delaySignal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;delaySignal-sendNext&quot;]; return nil;&#125;]; //10秒后才收到消息，执行打印[[delaySignal delay:10] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;delaySignal:%@&quot;,x);&#125;]; 6.信号取值take、takeLast、takeUntil首先创建一个signal来测试这三个方法： 12345678RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;发送消息1&quot;]; [subscriber sendNext:@&quot;发送消息2&quot;]; [subscriber sendNext:@&quot;发送消息3&quot;]; [subscriber sendNext:@&quot;发送消息4&quot;]; [subscriber sendCompleted]; return nil;&#125;]; 6.1、take：从开始共取N次的next值1234567[[signal take:2] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;订阅信号:%@&quot;,x);&#125;];控制台打印：2018-03-23 17:15:09.865290+0800 ZSTest[3835:237999] 订阅信号:发送消息12018-03-23 17:15:09.865617+0800 ZSTest[3835:237999] 订阅信号:发送消息2 6.2、takeLast：从最后共取值N次next的值12345678[[signal takeLast:3]subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;订阅信号：%@&quot;,x);&#125;];控制台打印：2018-03-23 17:19:51.343909+0800 ZSTest[3933:241042] 订阅信号：发送消息22018-03-23 17:19:51.344063+0800 ZSTest[3933:241042] 订阅信号：发送消息32018-03-23 17:19:51.344177+0800 ZSTest[3933:241042] 订阅信号：发送消息4 6.3、takeUntil:(RACSignal *)使用RACSubject类型的信号来测试，直到某个信号执行完成 ,才获取信号 12345678910111213141516171819RACSubject *signalA = [RACSubject subject];[signalA subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;订阅信号A：%@&quot;,x);&#125;]; __weak typeof(self)weakSelf = self;//[RACObserve(self, currentText)发送消息知道signalA信号结束[[RACObserve(self, currentText) takeUntil:signalA] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;使用%@更新testLabel的值&quot;,x); weakSelf.testLabel.text = x;&#125;];self.currentText = @&quot;0&quot;;self.currentText = @&quot;1&quot;;self.currentText = @&quot;2&quot;;[signalA sendCompleted];//信号A结束之后，监听testLabel文本的信号也不在发送消息了self.currentText = @&quot;3&quot;;NSLog(@&quot;代码执行到此行。。。。&quot;); 123456控制台打印：2018-03-23 17:31:08.907925+0800 ZSTest[4044:247412] 使用(null)更新testLabel的值2018-03-23 17:31:08.908531+0800 ZSTest[4044:247412] 使用0更新testLabel的值2018-03-23 17:31:08.908957+0800 ZSTest[4044:247412] 使用1更新testLabel的值2018-03-23 17:31:08.909194+0800 ZSTest[4044:247412] 使用2更新testLabel的值2018-03-23 17:31:08.909725+0800 ZSTest[4044:247412] 代码执行到此行。。。。 7.信号跳过：skip使用skip跳过几个信号 123456789101112131415RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;第一次发送消息&quot;]; [subscriber sendNext:@&quot;第二次发送消息&quot;]; [subscriber sendNext:@&quot;第三次发送消息&quot;]; [subscriber sendNext:@&quot;第四次发送消息&quot;]; return nil;&#125;];[[signal skip:2] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];控制台打印：2018-03-23 17:48:06.479104+0800 ZSTest[4284:259095] 第三次发送消息2018-03-23 17:48:06.479376+0800 ZSTest[4284:259095] 第四次发送消息 8.信号发送顺序：doNext、doCompleted发送信号前与发送信号后操作：doNext、doCompleteddoNext：在订阅者发送消息sendNext之前执行doCompleted：在订阅者发送完成sendCompleted之后执行 12345678910111213RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;发送信号：1&quot;]; [subscriber sendCompleted]; return nil;&#125;]; [[[signal doNext:^(id _Nullable x) &#123; NSLog(@&quot;执行doNext&quot;);&#125;] doCompleted:^&#123; NSLog(@&quot;执行doComplete&quot;);&#125;] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;订阅信号：%@&quot;,x);&#125;]; 1234控制台打印：2018-03-28 11:20:42.881535+0800 ZSTest[2656:81106] 执行doNext2018-03-28 11:20:42.881841+0800 ZSTest[2656:81106] 订阅信号：发送信号：12018-03-28 11:20:42.882583+0800 ZSTest[2656:81106] 执行doComplete 9.获取信号中的信号：switchToLatestswitchToLatest只能用于信号中的信号(否则崩溃)，获取最新发送的信号。 12345678910111213141516171819//创建一个普通信号RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;发送信号：1&quot;]; [subscriber sendCompleted]; return nil;&#125;];//创建一个发送信号的信号，信号的信号RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:signal]; [subscriber sendCompleted]; return nil;&#125;]; //订阅最近发出的信号[signalOfSignals.switchToLatest subscribeNext:^(id _Nullable x) &#123; //控制台打印：switchToLatest打印：发送信号：1 NSLog(@&quot;switchToLatest打印：%@&quot;,x);&#125;]; 特别说明：可以看出switchToLatest和flattenMap的功能很相似，但是它们有一主要区别： 10.信号错误重试：retryretry：只要失败就重新执行信号 12345678910111213141516171819static int signalANum = 0;RACSignal *signalA = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; if (signalANum == 5) &#123; [subscriber sendNext:@&quot;signalANum is 5&quot;]; [subscriber sendCompleted]; &#125;else&#123; NSLog(@&quot;signalANum错误！！!&quot;); [subscriber sendError:nil]; &#125; signalANum++; return nil;&#125;]; [[signalA retry] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;StringA-Next：%@&quot;,x);&#125; error:^(NSError * _Nullable error) &#123; //特别注意：这里并没有打印 NSLog(@&quot;signalA-Errror&quot;);&#125;] ; 1234567控制台打印：2018-03-24 09:46:38.996888+0800 ZSTest[818:14322] signalANum错误！！!2018-03-24 09:46:39.063427+0800 ZSTest[818:14322] signalANum错误！！!2018-03-24 09:46:39.064203+0800 ZSTest[818:14322] signalANum错误！！!2018-03-24 09:46:39.064567+0800 ZSTest[818:14322] signalANum错误！！!2018-03-24 09:46:39.064819+0800 ZSTest[818:14322] signalANum错误！！!2018-03-24 09:46:39.065199+0800 ZSTest[818:14322] StringA-Next：signalANum is 5 11.信号节流：throttle当某个信号发送比较频繁时，可以使用throttle节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。 1234567891011121314151617181920212223[[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;发送消息11&quot;]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;发送消息21&quot;]; [subscriber sendNext:@&quot;发送消息22&quot;]; &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;发送消息31&quot;]; [subscriber sendNext:@&quot;发送消息32&quot;]; [subscriber sendNext:@&quot;发送消息33&quot;]; &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;发送消息41&quot;]; [subscriber sendNext:@&quot;发送消息42&quot;]; [subscriber sendNext:@&quot;发送消息43&quot;]; [subscriber sendNext:@&quot;发送消息44&quot;]; &#125;); return nil; &#125;] throttle:2] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;Next:%@&quot;,x); &#125;]; 123控制台打印：2018-03-24 11:05:48.411464+0800 ZSTest[2063:62521] Next:发送消息112018-03-24 11:05:52.426162+0800 ZSTest[2063:62521] Next:发送消息44 12.信号关于线程的操作副作用：关于信号与线程,我们把在创建信号时block中的代码称之为副作用。deliverON：切换到指定线程中，可用于回到主线中刷新UI,内容传递切换到指定线程中，subscribeOn：内容传递和副作用都会切换到指定线程中。deliverOnMainThread：能保证原信号subscribeNext，sendError，sendCompleted都在主线程MainThread中执行。 1234567891011121314151617181920212223242526272829303132333435//测试1：系统并行队列中异步执行,未使用deliverON切换线程 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;测试1-endNext&quot;]; NSLog(@&quot;测试1-当前线程：%@&quot;,[NSThread currentThread]); return nil; &#125;] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;测试1-Next:%@&quot;,x); NSLog(@&quot;测试1-Next当前线程：%@&quot;,[NSThread currentThread]); &#125;]; &#125;) ; //测试2：系统并行队列中异步执行,使用deliverON切换线程 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;测试2-endNext&quot;]; NSLog(@&quot;测试2-当前线程：%@&quot;,[NSThread currentThread]); return nil; &#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;测试2-Next:%@&quot;,x); NSLog(@&quot;测试2-Next当前线程：%@&quot;,[NSThread currentThread]); &#125;]; &#125;) ; //测试3：系统并行队列中异步执行,使用subscribeOn切换线程 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;测试3-sendNext&quot;]; NSLog(@&quot;测试3-sendNext当前线程：%@&quot;,[NSThread currentThread]); return nil; &#125;] subscribeOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;测试3-Next:%@&quot;,x); NSLog(@&quot;测试3-Next当前线程：%@&quot;,[NSThread currentThread]); &#125;]; &#125;) ; 123456789101112控制台打印：2018-03-24 12:37:48.025872+0800 ZSTest[2624:109537] 测试1-Next:测试1-endNext2018-03-24 12:37:48.026152+0800 ZSTest[2624:109537] 测试1-Next当前线程：&lt;NSThread: 0x60400046e640&gt;&#123;number = 5, name = (null)&#125;2018-03-24 12:37:48.026746+0800 ZSTest[2624:109537] 测试1-sendNext当前线程：&lt;NSThread: 0x60400046e640&gt;&#123;number = 5, name = (null)&#125;2018-03-24 12:37:48.027784+0800 ZSTest[2624:109537] 测试2-sendNext当前线程：&lt;NSThread: 0x60400046e640&gt;&#123;number = 5, name = (null)&#125;2018-03-24 12:37:48.073294+0800 ZSTest[2624:109360] 测试2-Next:测试2-sendNext2018-03-24 12:37:48.073890+0800 ZSTest[2624:109360] 测试2-Next当前线程：&lt;NSThread: 0x60400006a280&gt;&#123;number = 1, name = main&#125;2018-03-24 12:37:48.074181+0800 ZSTest[2624:109360] 测试3-Next:测试3-sendNext2018-03-24 12:37:48.074511+0800 ZSTest[2624:109360] 测试3-Next当前线程：&lt;NSThread: 0x60400006a280&gt;&#123;number = 1, name = main&#125;2018-03-24 12:37:48.074646+0800 ZSTest[2624:109360] 测试3-sendNext当前线程：&lt;NSThread: 0x60400006a280&gt;&#123;number = 1, name = main&#125; 分析：测试1：未切换线程，发送消息与接收消息都在异步线程中测试2：使用deliverON，发送消息还在原来的线程，但是接收消息切换到主线程。测试2：使用subscribeON，发送消息和接收消息都被切换到了主线程中执行。 四、RAC常用的处理事件响应的方法1.代替代理的使用基础篇里已经有一种使用RACSubject替换代理的方法，这里是另一种形式的替换。在视图控制中添加自定义视图CustomView，其上有一按钮testBtn添加了响应方法testBtnClick:。此时可以使用RAC在不使用代理的情况下，在视图控制中监听自定义视图中按钮的点击:关键方法：rac_signalForSelector使用说明：1.通过rac_signalForSelector方法，以按钮响应方法为参数，得到一个信号。2.订阅信号，在按钮点击时会发出信号。经过测试，即使testBtnClick方法没有在自定义视图的.h文件中声明，执行也是正常的。 123[[_customView rac_signalForSelector:@selector(testBtnClick:)] subscribeNext:^(RACTuple * _Nullable x) &#123; NSLog(@&quot;testBtn点击了。。。&quot;);&#125;]; 2.代替按钮等控制视图的响应事件创建一个类似按钮的响应控件，我们可以不必再为其添加响应方法。使用RAC可以将按钮点击事件转化为信号，点击按钮会发送信号，执行订阅方法。关键方法：rac_signalForControlEvents 123[[testBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) &#123; NSLog(@&quot;testBtn点击了。。。&quot;);&#125;]; 3.代替KVO，监听对象属性变化关键方法：rac_valuesAndChangesForKeyPath使用说明：1.自定义视图_customView属性frame的变化被转化信号，frame发生变化的时候，会发送信号。2.observer可以为nil,但是会报警告。 1234[[_customView rac_valuesAndChangesForKeyPath:@&quot;frame&quot; options:NSKeyValueObservingOptionNew observer: nil] subscribeNext:^(id x) &#123; NSLog(@&quot;CustomView的Frame值变化了：%@&quot;,x);&#125;];_customView.frame = CGRectZero; 4.监听文本输入变化关键方法：rac_textSignalUITextField与UITextView输入视图内容的变化，我们也可以采用RAC的方法来监听 123[[_testTxtView rac_textSignal] subscribeNext:^(NSString * _Nullable x) &#123; NSLog(@&quot;当前文本输入内容：%@&quot;,x);&#125;]; 5.代替通知的使用关键方法：rac_addObserverForName 1234567891011//步骤1： 添加通知[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@&quot;SecondVCNotificaitonName&quot; object:nil] subscribeNext:^(NSNotification * _Nullable x) &#123; NSDictionary *objectDic = (NSDictionary *)x.object; NSLog(@&quot;获取到通知里的文本：%@&quot;,objectDic[@&quot;text&quot;]);&#125;];//步骤2：发起通知//SecondVC中点击按钮，将输入框中的文本封装成字典，将其作为参数发起通知- (IBAction)completeBtnClick:(id)sender &#123; [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;SecondVCNotificaitonName&quot; object:@&#123;@&quot;text&quot;:self.txtField.text&#125;];&#125; 6.多请求汇总处理关键方法：rac_liftSelector：withSignals： 123456789101112131415161718192021//下载任务1RACSignal *downLoad1 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&#123;@&quot;data2&quot;:@&quot;value1&quot;&#125;]; [subscriber sendCompleted]; return nil;&#125;];//下载任务2RACSignal *downLoad2 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&#123;@&quot;data2&quot;:@&quot;value2&quot;&#125;]; [subscriber sendCompleted]; return nil;&#125;]; //多信号对应多参数，注意顺序与格式[self rac_liftSelector:@selector(handleAllTasksWithT1:withT2:) withSignals:downLoad1,downLoad2, nil];//集中处理所有的请求- (void)handleAllTasksWithT1:(id)data1 withT2:(id)data2&#123; NSLog(@&quot;下载任务全部完成：%@，%@&quot;,data1,data2);&#125; 五、本篇总结写到这里，其实RAC还是有好多东西没有在这里涉及，本篇也只是对于它最常用的部分进行了归纳总结，尤其是我对于RAC在MVVM架构中的使用还不太熟练。RAC的学习，这仅仅是一个开始，继续努力吧！ 参考链接：1.RAC核心元素与信号流2.iOS常用API整理","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"响应式编程","slug":"响应式编程","permalink":"https://wuyubeichen.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"iOS开发-DTCoreText的集成与使用","slug":"iOS开发-DTCoreText的集成与使用","date":"2019-02-26T08:16:49.000Z","updated":"2025-05-03T16:24:56.214Z","comments":true,"path":"2019/02/26/iOS开发-DTCoreText的集成与使用/","permalink":"https://wuyubeichen.github.io/2019/02/26/iOS%E5%BC%80%E5%8F%91-DTCoreText%E7%9A%84%E9%9B%86%E6%88%90%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"主要内容： DTCoreText简介 DTCoreText的集成 DTCoreText的使用","text":"主要内容： DTCoreText简介 DTCoreText的集成 DTCoreText的使用 DTAttributedLabel DTAttributedTextView DTAttributedTextCell 可能遇到的错误 一、DTCoreText简介DTCoreText是可以将HTML字符串转化为富文本使用的工具，既保证原生实现又能适应灵活的样式修改，而且相比于使用WebView显示内容在性能上也有很大优势，本篇就这一技术的使用进行总结。 DTCoreText相关资源如下： DTCoreText源码下载 DTCoreText官方文档 DTCoreText集成文档 本文DTCoreText测试工程 温馨提示：文中代码量比较大，看起来可能比较费劲，所以先将本文的Demo链接放在这里，结合代码看更方便，毕竟代码才是硬道理嘛！ 二、DTCoreText的集成在项目中使用DTCoreText需要它的两个静态库：DTCoreText.framework和DTFoundation.framework，但是从Github下载的文件却不能直接使用。 起初，我是直接从网上其他地方下载打包好的静态库来使用的，但这样会遗漏掉更新。所以，这里总结了集成DTCoreText的具体步骤。 1.下载源码创建一个文件夹DTCoreText，使用终端命令下载源码： 1git clone --recursive [https://github.com/Cocoanetics/DTCoreText.git](https://github.com/Cocoanetics/DTCoreText.git) Externals/DTCoreText 2.设置编译配置修改DTCoreText工程的编译配置，然后运行工程就得到适合不同平台的静态库； 为了获取到适合iOS设备使用的SDK，选择工程Target为DTCoreText(iOS)，并依次选择DTCoreText(iOS) -&gt; Deployment Info -&gt; 选择需要最低支持的系统版本； 3.设置Scheme选择Product -&gt; Scheme -&gt; Edit Scheme，修改编译环境修改为Release模式： 4.模拟器和真机分别编译使用commadn+B执行代码编译，注意一定要选择正确的Target，既然是用于iOS，就应该选择DTCoreText (iOS)这个Target进行编译 5.打开编译缓存，获取静态库在Xcode依次打开File -&gt; File Setting -&gt; DerivedData，然后点击之后的路径箭头可以找到DTCoreText的编译缓存文件夹： 然后我们再依次打开Build-&gt;Products，将会看到适合模拟器和真机使用的两个静态库文件夹： 6.合并静态库经过上述步骤，我分别得到了适合模拟器和真机使用的静态库，现在我们把它们合并。首先我们把Products文件拷贝到一个合适的位置，然后在控制台执行合并静态库的命令如下： 如图，我们使用lipo命令合并了适合模拟器和真机使用的可执行文件： 然后，我们需要将两个文件分别对应拷贝到Release-iphones文件夹中的DTCoreText.framework和DTFoundation.framework中，这样最终我们就得到想要的静态库。 三、DTCoreText的使用在这之前我们准备一段测试用的Html如下： 1_html = @&quot;&lt;span style=\\&quot;color:#333;font-size:15px;\\&quot;&gt;&lt;strong&gt;标题1&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span align=\\&quot;left\\&quot; style=\\&quot;color:#333;font-size:15px;\\&quot;&gt;详细介绍详细介绍详细介绍详细介绍详细介绍详细介绍。&lt;/span&gt;&lt;br/&gt;&lt;img src=\\&quot;http://cn-qinqimaifang-uat.oss-cn-hangzhou.aliyuncs.com/img/specialist/upload/spcetiicwlz1v_54e2e00fa8a6faf66168571654dbfee2.jpg\\&quot; _src=\\&quot;http://cn-qinqimaifang-uat.oss-cn-hangzhou.aliyuncs.com/img/specialist/upload/spcetiicwlz1v_54e2e00fa8a6faf66168571654dbfee2.jpg\\&quot;&gt;&lt;br/&gt;&lt;br/&gt;&lt;span style=\\&quot;color:#333;font-size:15px;\\&quot;&gt;百度:&lt;a href=\\&quot;http://www.baidu.com.cn\\&quot;&gt;my testlink&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span style=\\&quot;color:#333;font-size:15px;\\&quot;&gt;电话：&lt;a href=\\&quot;tel:4008001234\\&quot;&gt;my phoneNum&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span style=\\&quot;color:#333;font-size:15px;\\&quot;&gt;我邮箱:&lt;a href=\\&quot;mailto:dreamcoffeezs@163.com\\&quot;&gt;my mail&lt;/a&gt;&lt;/span&gt;&quot;; 关于DTCoreText，我们主要用到它的三个控件，分别是DTAttributedLabel，DTAttributedTextView和DTAttributedTextCell，下面对它们的使用进行具体说明。 四、使用DTAttributedLabel顾名思义，我们会把DTAttributedLabel当做一个UILabel来使用，但事实上DTAttributedLabel并不属于UILabel的子类，下面针对DTAttributedLabel使用的三个问题进行介绍。 1.显示基本文本1234567891011121314151617181920//1.创建DTAttributedLabel_attributedLabel = [[DTAttributedLabel alloc] initWithFrame:CGRectZero];_attributedLabel.delegate = self;[self.view addSubview:self.attributedLabel];//2.Html转化富文本NSData *data = [_html dataUsingEncoding:NSUTF8StringEncoding];NSAttributedString *attributedString = [[NSAttributedString alloc] initWithHTMLData:data documentAttributes:NULL];//3.计算Frame//预设一个最大的Frame,限宽不限高，方便以后计算布局_viewMaxRect = CGRectMake(15, 15, ZSToolScreenWidth - 15*2, CGFLOAT_HEIGHT_UNKNOWN); DTCoreTextLayouter *layouter = [[DTCoreTextLayouter alloc] initWithAttributedString:attributedString];NSRange entireStringRange = NSMakeRange(0, [attributedString length]);DTCoreTextLayoutFrame *layoutFrame = [layouter layoutFrameWithRect:_viewMaxRect range:entireStringRange];CGSize textSize = [layoutFrame frame].size;self.attributedLabel.frame = CGRectMake(_viewMaxRect.origin.x, _viewMaxRect.origin.y, _viewMaxRect.size.width, textSize.height); //4.设置富文本self.attributedLabel.attributedString = [self getAttributedStringWithHtml:self.html]; 2.显示图片既然是富文本，DTAttributedLabel也会显示图片。但是如果我们的Html字符串里图片链接没有包含大小，图片并不能正常显示。为了显示图片我们需要懒加载获取宽高再刷新显示，这就需要用到DTAttributedLabel的代理方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#pragma mark - Delegate：DTAttributedTextContentViewDelegate//DTCoretText在解析Html的时候，如果遇到网络图片会插入一个占位符//对于图片类型(DTImageTextAttachmentd)的占位符，我们使用DTLazyImageView来显示- (UIView *)attributedTextContentView:(DTAttributedTextContentView *)attributedTextContentView viewForAttachment:(DTTextAttachment *)attachment frame:(CGRect)frame&#123; if([attachment isKindOfClass:[DTImageTextAttachment class]])&#123; NSString *imageURL = [NSString stringWithFormat:@&quot;%@&quot;, attachment.contentURL]; DTLazyImageView *imageView = [[DTLazyImageView alloc] initWithFrame:frame]; imageView.delegate = self;//图片懒加载代理 imageView.contentMode = UIViewContentModeScaleAspectFit; imageView.image = [(DTImageTextAttachment *)attachment image]; imageView.url = attachment.contentURL; //处理gif图片 if ([imageURL containsString:@&quot;gif&quot;]) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSData *gifData = [NSData dataWithContentsOfURL:attachment.contentURL]; dispatch_async(dispatch_get_main_queue(), ^&#123; imageView.image = DTAnimatedGIFFromData(gifData); &#125;); &#125;); &#125; return imageView; &#125; return nil;&#125;#pragma mark Delegate：DTLazyImageViewDelegate//懒加载图片代理- (void)lazyImageView:(DTLazyImageView *)lazyImageView didChangeImageSize:(CGSize)size &#123; NSURL *url = lazyImageView.url; CGSize imageSize = size; NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;contentURL == %@&quot;, url]; BOOL didUpdate = NO; //update all attachments that match this URL (possibly multiple images with same size) //更新所有匹配URL的占位符视图 for (DTTextAttachment *oneAttachment in [self.attributedLabel.layoutFrame textAttachmentsWithPredicate:pred])&#123; //update attachments that have no original size, that also sets the display size //更新没有自带尺寸的占位视图(如网络图片) if (CGSizeEqualToSize(oneAttachment.originalSize, CGSizeZero))&#123; //原始图片不带宽高，被识别后修改Html oneAttachment.originalSize = imageSize; //使用新拿到的图片尺寸更新HTML字符串 [self configNoSizeImageView:url.absoluteString size:imageSize]; didUpdate = YES; &#125; &#125; if (didUpdate)&#123; //重新显示富文本 CGSize textSize = [self getAttributedTextHeightHtml:self.html with_viewMaxRect:_viewMaxRect]; self.attributedLabel.frame = CGRectMake(_viewMaxRect.origin.x, _viewMaxRect.origin.y, _viewMaxRect.size.width, textSize.height); self.attributedLabel.attributedString = [self getAttributedStringWithHtml:self.html]; self.attributedLabel.layouter = nil; [self.attributedLabel relayoutText]; &#125;&#125;#pragma mark - private Methods//使用得到的新图片尺寸，更新HtmlString字符串- (void)configNoSizeImageView:(NSString *)url size:(CGSize)size&#123; //_viewMaxRect是预设的最大Frame CGFloat imgSizeScale = size.height/size.width; CGFloat widthPx = _viewMaxRect.size.width; CGFloat heightPx = widthPx * imgSizeScale; NSString *imageInfo = [NSString stringWithFormat:@&quot;_src=\\&quot;%@\\&quot;&quot;,url]; NSString *sizeString = [NSString stringWithFormat:@&quot;style=\\&quot;width:%.fpx; height:%.fpx;\\&quot;&quot;,widthPx,heightPx]; NSString *newImageInfo = [NSString stringWithFormat:@&quot;_src=\\&quot;%@\\&quot;%@&quot;,url,sizeString]; if ([self.html containsString:imageInfo]) &#123; NSString *newHtml = [self.html stringByReplacingOccurrencesOfString:imageInfo withString:newImageInfo]; self.html = newHtml; &#125;&#125;//使用HtmlString,和预设的Frame，计算富文本视图自适应后的高度- (CGSize)getAttributedTextHeightHtml:(NSString *)htmlString with_viewMaxRect:(CGRect)_viewMaxRect&#123; //获取富文本 NSAttributedString *attributedString = [self getAttributedStringWithHtml:htmlString]; //获取布局器 DTCoreTextLayouter *layouter = [[DTCoreTextLayouter alloc] initWithAttributedString:attributedString]; NSRange entireString = NSMakeRange(0, [attributedString length]); //获取Frame DTCoreTextLayoutFrame *layoutFrame = [layouter layoutFrameWithRect:_viewMaxRect range:entireString]; //得到大小 CGSize sizeNeeded = [layoutFrame frame].size; return sizeNeeded;&#125; 3.响应事件如果我们希望在DTAttributedLabel上操作点击事件，那么对应的我们也应该在Html中使用超链接A标签。这里我们需要用到如下的代理方法如下: 12345678910- (UIView *)attributedTextContentView:(DTAttributedTextContentView *)attributedTextContentView viewForLink:(NSURL *)url identifier:(NSString *)identifier frame:(CGRect)frame&#123; //此方法需要我们在这里返回一个可以点击响应的控件如Button,然后就可以很方便的处理响应事件了，其中： //url:Html中的超链接(可以根据需要设置http、tel、mailto等) //identifier:属于该视图的唯一性标识 //frame:超链接字符串所在的位置,需要将自定义响应按钮设置为此Frame return nil;&#125; 注意：如果我们需要显示一些输入框之类的视图，也可以借助此方法。 最终效果图： 五、DTAttributedTextView其实，DTAttributedTextView和DTAttributedLabel的用法几乎一样； 从其源码上就能看出，DTAttributedLabel继承于DTAttributedTextContentView的，而DTAttributedTextView包含DTAttributedTextContentView属性。可以说DTAttributedTextView就是借助DTAttributedLabel实现的视图。 DTAttributedTextView是支持滑动显示的富文本视图，在使用时计算富文本的Frame也就没那么必要了，一般我们都会指定它的Frame，其在这里的用法就不累述了。 六、DTAttributedTextCell如果我们需要在单元格上显示富文本，DTCoretText也为我们提供了特有的类来解决这个问题，那就是DTAttributedTextCell。通过这个单元格类，我们可以方便的设置富文本以及获取单元格高度。以下是使用DTAttributedTextCell显示富文本的核心代码： 1. 声明控制器内属性1234567891011121314@interface TestTableViewController ()&lt;UITableViewDataSource,UITableViewDelegate,DTAttributedTextContentViewDelegate,DTLazyImageViewDelegate&gt;@property(nonatomic,strong)UITableView *tableView;//普通单元格与富文本单元格@property (nonatomic, copy) NSString *cellID_Normal;@property (nonatomic, copy) NSString *cellID_DTCoreText;//类似tabelView的缓冲池，用于存放图片大小@property (nonatomic, strong) NSCache *imageSizeCache;@property (nonatomic,strong)NSCache *cellCache;//表视图数据源@property (nonatomic, strong) NSArray *dataSource;//当前表视图是否在滑动@property (nonatomic,assign)BOOL isScrolling;@end 2.表视图代理方法返回单元格及其高度12345678910111213141516171819202122232425262728293031323334353637383940//代理方法：返回单元格- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; switch (indexPath.section) &#123; case 0:&#123; //普通单元格 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:_cellID_Normal]; cell.textLabel.text = self.dataSource[indexPath.section][indexPath.row]; return cell; break; &#125; case 1:&#123; //自定义方法，创建富文本类型的单元格 ZSDTCoreTextCell *dtCell = (ZSDTCoreTextCell *) [self tableView:tableView prepareCellForIndexPath:indexPath]; return dtCell; break; &#125; default: break; &#125; return nil;&#125;//返回单元格高度- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(nonnull NSIndexPath *)indexPath&#123; switch (indexPath.section) &#123; case 0:&#123; return 50; break; &#125; case 1:&#123; //返回富文本类型单元格的方法 ZSDTCoreTextCell *cell = (ZSDTCoreTextCell *)[self tableView:tableView prepareCellForIndexPath:indexPath]; return [cell requiredRowHeightInTableView:tableView]; break; &#125; default: break; &#125; return 0;&#125; 3.懒加载处理无宽高属性的图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma mark - DTAttributedTextContentViewDelegate//对于没有在Html标签里设置宽高的图片，在这里为其设置占位- (UIView *)attributedTextContentView:(DTAttributedTextContentView *)attributedTextContentView viewForAttachment:(DTTextAttachment *)attachment frame:(CGRect)frame&#123; if([attachment isKindOfClass:[DTImageTextAttachment class]])&#123; //自定义的ZSDTLazyImageView继承于DTLazyImageView，增加了一个属性textContentView //用于更新图片大小 ZSDTLazyImageView *imageView = [[ZSDTLazyImageView alloc] initWithFrame:frame]; imageView.delegate = self; imageView.image = [(DTImageTextAttachment *)attachment image]; imageView.textContentView = attributedTextContentView; imageView.url = attachment.contentURL; return imageView; &#125; return nil;&#125;//对于无宽高的图片懒加载，缓存记录其大小,然后执行表视图更新- (void)lazyImageView:(ZSDTLazyImageView *)lazyImageView didChangeImageSize:(CGSize)size&#123; BOOL needUpdate = NO; NSURL *url = lazyImageView.url; NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;contentURL == %@&quot;, url]; /* update all attachments that matchin this URL (possibly multiple images with same size) */ for (DTTextAttachment *oneAttachment in [lazyImageView.textContentView.layoutFrame textAttachmentsWithPredicate:pred])&#123; // update attachments that have no original size, that also sets the display size if (CGSizeEqualToSize(oneAttachment.originalSize, CGSizeZero))&#123; oneAttachment.originalSize = size; NSValue *sizeValue = [_imageSizeCache objectForKey:oneAttachment.contentURL]; if (!sizeValue) &#123; //将图片大小记录在缓存中，但是这种图片的原始尺寸可能很大，所以这里设置图片的最大宽 //并且计算高 CGFloat aspectRatio = size.height / size.width; CGFloat width = ZSToolScreenWidth - 15*2; CGFloat height = width * aspectRatio; CGSize newSize = CGSizeMake(width, height); [_imageSizeCache setObject:[NSValue valueWithCGSize:newSize]forKey:url]; &#125; needUpdate = YES; &#125; &#125; if (needUpdate)&#123; //有新的图片尺寸被缓存记录的时候，需要刷新表视图 [self reloadCurrentCell]; &#125;&#125; 4.创建富文本单元格的方法1234567891011121314151617181920212223242526272829303132#pragma mark - private Methods//创建富文本单元格，并更新单元格上的数据//ZSDTCoreTextCell是自定义的继承于DTCoreTextCell的单元格- (ZSDTCoreTextCell *)tableView:(UITableView *)tableView prepareCellForIndexPath:(NSIndexPath *)indexPath&#123; NSString *key = [NSString stringWithFormat:@&quot;dtCoreTextCellKEY%ld-%ld&quot;, (long)indexPath.section, (long)indexPath.row]; ZSDTCoreTextCell *cell = [_cellCache objectForKey:key]; if (!cell)&#123; cell = [[ZSDTCoreTextCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:_cellID_DTCoreText]; cell.attributedTextContextView.edgeInsets = UIEdgeInsetsMake(0, 15, 0, 15); [cell setSelectionStyle:UITableViewCellSelectionStyleNone]; cell.accessoryType = UITableViewCellAccessoryNone; cell.hasFixedRowHeight = NO; cell.textDelegate = self; cell.attributedTextContextView.shouldDrawImages = YES; //记录在缓存中 [_cellCache setObject:cell forKey:key]; &#125; //2.设置数据 //2.1为富文本单元格设置Html数据 [cell setHTMLString:self.dataSource[indexPath.section][indexPath.row]]; //2.2为每个占位图(图片)设置大小，并更新 for (DTTextAttachment *oneAttachment in cell.attributedTextContextView.layoutFrame.textAttachments) &#123; NSValue *sizeValue = [_imageSizeCache objectForKey:oneAttachment.contentURL]; if (sizeValue) &#123; cell.attributedTextContextView.layouter=nil; oneAttachment.displaySize = [sizeValue CGSizeValue]; [cell.attributedTextContextView relayoutText]; &#125; &#125; [cell.attributedTextContextView relayoutText]; return cell;&#125; 5.处理表视图的刷新如果当前表视图在滑动就不执行刷新，因为滑动时候会自动调用表视图的刷新方法 1234567891011121314151617181920- (void)reloadCurrentCell&#123; if (self.isScrolling) &#123; return; &#125; //如果当前表视图没有在滑动，就手动刷新当前在屏幕显示的单元格 NSArray *indexPaths = [self.tableView indexPathsForVisibleRows]; if(indexPaths)&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.tableView reloadRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationNone]; &#125;); &#125;&#125;- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView&#123; _isScrolling = NO;&#125;- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; _isScrolling = YES;&#125; 6.set方法创建表视图与数据源123456789101112131415161718192021222324252627282930313233343536#pragma mark - set/get方法- (UITableView *)tableView&#123; if (_tableView == nil) &#123; _tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0, ZSToolScreenWidth, ZSToolScreenHeight-64) style:UITableViewStylePlain]; _tableView.dataSource = self; _tableView.delegate = self; [_tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:_cellID_Normal]; //[_tableView registerClass:[ZSDTCoreTextCell class] forCellReuseIdentifier:_cellID_DTCoreText]; &#125; return _tableView;&#125;- (NSArray *)dataSource&#123; if(_dataSource == nil)&#123; NSMutableArray *noramDataArray = @[].mutableCopy; NSMutableArray *htmlDataArray = @[].mutableCopy; NSArray *images = @[@&quot;https://i0.hdslb.com/bfs/archive/d5ad3cf95d32f3d2f2e3471a39120237200d84d8.jpg&quot;, @&quot;https://i0.hdslb.com/bfs/archive/71d2fed927d9351e759f408ca7d66c556c37a6b4.jpg&quot;, @&quot;https://i0.hdslb.com/bfs/archive/7f520b31b67cd5d89dd30b61b40711327bb00288.png&quot;, @&quot;https://i0.hdslb.com/bfs/archive/6edbe81bf74c106087ad139aca169d6e8d9d963b.jpg&quot;, @&quot;https://i0.hdslb.com/bfs/archive/805aa8f7ae722fcc277f425bb9927e29ec1d2468.jpg&quot;, @&quot;https://i0.hdslb.com/bfs/archive/a7c61d94c583363a970d2a2e339eea97f8f32317.jpg&quot;, @&quot;https://i0.hdslb.com/bfs/archive/b447ee1fd63b4cf6f4465a5621cc12898867d26b.jpg&quot;]; for(int i = 0;i&lt;1000;i++)&#123; if(i &lt;6)&#123; [noramDataArray addObject:[NSString stringWithFormat:@&quot;测试普通单元格:%d&quot;,i]]; &#125; //这里提供的Html图片链接，没有宽高属性，代码中已经演示了如何处理 int k = i % 6; NSString *htmlString =[NSString stringWithFormat:@&quot;&lt;span style=\\&quot;color:#333;font-size:15px;\\&quot;&gt;&lt;strong&gt;测试富文本单元格%d：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span style=\\&quot;color:#333;font-size:15px;\\&quot;&gt;记住！砍价是由你自己先砍，砍不动时再由砍价师继续砍；由砍价师多砍下的部分，才按照下列标准收费：&lt;/span&gt;&lt;br/&gt;&lt;span style=\\&quot;color:#333;font-size:15px;\\&quot;&gt;&lt;img src=%@ _src=%@&gt;&lt;/span&gt;&quot;,i,images[k],images[k]]; [htmlDataArray addObject:htmlString]; &#125; _dataSource = @[noramDataArray,htmlDataArray]; &#125; return _dataSource;&#125; 使用DTAttributedTextCell的最终效果图如下： 七、可能遇到的错误原本上，在项目中使用只需将Release-iphones的DTCoreText.framework和DTFoundation.framework中拖入工程就可以使用了。 然而，我在编译工程却会遇到这样一个错误：&quot;image not found&quot; 解决方法如下图：","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"UI问题","slug":"UI问题","permalink":"https://wuyubeichen.github.io/tags/UI%E9%97%AE%E9%A2%98/"}]},{"title":"iOS开发-屏幕旋转适配","slug":"iOS开发-屏幕旋转适配","date":"2019-02-24T06:58:39.000Z","updated":"2025-05-03T16:11:16.741Z","comments":true,"path":"2019/02/24/iOS开发-屏幕旋转适配/","permalink":"https://wuyubeichen.github.io/2019/02/24/iOS%E5%BC%80%E5%8F%91-%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%AC%E9%80%82%E9%85%8D/","excerpt":"前段时间抽空总结了一下iOS视频播放的基本用法，发现这其中还有一个我们无法绕过的问题，那就是播放界面的旋转与适配。的确，视频播放与游戏类型的App经常会遇到这个的问题。由于至今接手的项目中不常涉及这块知识疏于总结，在搜索了一些资料后也发现都很散乱，所以决定在这里重新整理一下。","text":"前段时间抽空总结了一下iOS视频播放的基本用法，发现这其中还有一个我们无法绕过的问题，那就是播放界面的旋转与适配。的确，视频播放与游戏类型的App经常会遇到这个的问题。由于至今接手的项目中不常涉及这块知识疏于总结，在搜索了一些资料后也发现都很散乱，所以决定在这里重新整理一下。 主要内容： 最让人纠结的三种枚举 两种屏幕旋转的触发方式 屏幕旋转控制的优先级 开启屏幕旋转的全局权限 开启屏幕旋转的局部权限(视图控制器) 实现需求：项目主要界面竖屏，部分界面横屏 默认横屏无效的问题 关于旋转后的适配问题 APP启动即全屏 一、最让人纠结的三种枚举刚开始接触屏幕旋转这块知识的时候，最让人抓狂的也许就是三种相关的枚举类型了，它们就是： UIDeviceOrientation UIInterfaceOrientation UIInterfaceOrientationMask 1.设备方向UIDeviceOrientationUIDeviceOrientation： 这是硬件设备(iPhone、iPad等)本身的当前旋转方向，共有7种(包括一种未知的情况)； 设备方向只能取值，不能设置； 判断设备的方向是以Home键的位置作为参照的； UIDeviceOrientation在源码中的定义如下： 1234567891011//Portrait 表示纵向，Landscape 表示横向。typedef NS_ENUM(NSInteger, UIDeviceOrientation) &#123; UIDeviceOrientationUnknown, UIDeviceOrientationPortrait, // Device oriented vertically, home button on the bottom UIDeviceOrientationPortraitUpsideDown, // Device oriented vertically, home button on the top UIDeviceOrientationLandscapeLeft, // Device oriented horizontally, home button on the right UIDeviceOrientationLandscapeRight, // Device oriented horizontally, home button on the left UIDeviceOrientationFaceUp, // Device oriented flat, face up UIDeviceOrientationFaceDown // Device oriented flat, face down &#125; __TVOS_PROHIBITED; 获取设备当前设备的旋转方向使用：[UIDevice currentDevice].orientation； 为了监测设备方向的变化，可以在Appdelegate文件中使用通知如下： 123456789101112131415161718192021222324252627282930313233343536373839[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onDeviceOrientationDidChange) name:UIDeviceOrientationDidChangeNotification object:nil];[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications]; - (BOOL)onDeviceOrientationDidChange&#123; //获取当前设备Device UIDevice *device = [UIDevice currentDevice] ; //识别当前设备的旋转方向 switch (device.orientation) &#123; case UIDeviceOrientationFaceUp: NSLog(@&quot;屏幕幕朝上平躺&quot;); break; case UIDeviceOrientationFaceDown: NSLog(@&quot;屏幕朝下平躺&quot;); break; case UIDeviceOrientationUnknown: //系统当前无法识别设备朝向，可能是倾斜 NSLog(@&quot;未知方向&quot;); break; case UIDeviceOrientationLandscapeLeft: NSLog(@&quot;屏幕向左橫置&quot;); break; case UIDeviceOrientationLandscapeRight: NSLog(@&quot;屏幕向右橫置&quot;); break; case UIDeviceOrientationPortrait: NSLog(@&quot;屏幕直立&quot;); break; case UIDeviceOrientationPortraitUpsideDown: NSLog(@&quot;屏幕直立，上下顛倒&quot;); break; default: NSLog(@&quot;無法识别&quot;); break; &#125; return YES;&#125; 2.页面方向UIInterfaceOrientationUIInterfaceOrientation是开发的程序界面的当前旋转方向，它是可以设置的； UIInterfaceOrientation的源码定义如下： 12345678910 // Note that UIInterfaceOrientationLandscapeLeft is equal to UIDeviceOrientationLandscapeRight (and vice versa). // This is because rotating the device to the left requires rotating the content to the right. typedef NS_ENUM(NSInteger, UIInterfaceOrientation) &#123; UIInterfaceOrientationUnknown = UIDeviceOrientationUnknown, UIInterfaceOrientationPortrait = UIDeviceOrientationPortrait, UIInterfaceOrientationPortraitUpsideDown = UIDeviceOrientationPortraitUpsideDown, UIInterfaceOrientationLandscapeLeft = UIDeviceOrientationLandscapeRight, UIInterfaceOrientationLandscapeRight = UIDeviceOrientationLandscapeLeft &#125; __TVOS_PROHIBITED; 值得注意的两个枚举： 12UIInterfaceOrientationLandscapeLeft = UIDeviceOrientationLandscapeRight, UIInterfaceOrientationLandscapeRight = UIDeviceOrientationLandscapeLeft 我们可以发现设备方向与页面方向的枚举值大多是可以对应上的。只有左右旋转的时候是UIInterfaceOrientationLandscapeLeft 与UIDeviceOrientationLandscapeRight相等，反之亦然，这是因为向左旋转设备需要旋转程序界面右边的内容。 3.页面方向UIInterfaceOrientationMaskUIInterfaceOrientationMask是iOS6之后增加的一种枚举，其源码如下: 123456789typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) &#123; UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait), UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft), UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight), UIInterfaceOrientationMaskPortraitUpsideDown = (1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown), UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight), UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown), UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),&#125; __TVOS_PROHIBITED; 我们已经知道UIDeviceOrientation与UIInterfaceOrientation的区别在于：前者是真实的设备方向，后者是页面方向； 而UIInterfaceOrientation和UIInterfaceOrientationMask的区别是什么呢？其实观察源码，我们就会发现，这是一种为了支持多种UIInterfaceOrientation而定义的类型； 下面的示例将很好的说明这点： 在iOS6之后，控制单个界面的旋转我们通常是下面三个方法来控制： 1234567//方法1- (BOOL)shouldAutorotate NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED;//方法2- (UIInterfaceOrientationMask)supportedInterfaceOrientations NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED;// Returns interface orientation masks.//方法3- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED; 方法2：用于设置当前界面支持的所有方向，所以返回值是UIInterfaceOrientationMask，更加方便的表达支持多方向旋转的情况； 方法3：用于设置进入界面默认支持的方向，使用了返回值类型UIInterfaceOrientation，默认进入界面的方向是个确定的方向，所以使用UIInterfaceOrientation更适合； 二、两种屏幕旋转的触发方式我们开发的App的，大多情况都是大多界面支持竖屏，几个特别的界面支持旋转横屏，两种界面相互切换，触发其旋转有两种情况： 情况1：系统没有关闭自动旋转屏幕功能这种情况，支持旋转的界面跟随用户手持设备旋转方向自动旋转。我们需要在当前视图控制器中添加如下方法： 12345678910111213141516//1.决定当前界面是否开启自动转屏，如果返回NO，后面两个方法也不会被调用，只是会支持默认的方向- (BOOL)shouldAutorotate &#123; return YES;&#125;//2.返回支持的旋转方向//iPad设备上，默认返回值UIInterfaceOrientationMaskAllButUpSideDwon//iPad设备上，默认返回值是UIInterfaceOrientationMaskAll- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123; return UIInterfaceOrientationMaskAll;&#125;//3.返回进入界面默认显示方向- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123; return UIInterfaceOrientationPortrait;&#125; 情况2：单个界面强制旋转在程序界面，通过点击等方式切换到横屏(尤其是视频播放的情况)，有以下两种方法： 123456789101112131415161718192021// 方法1：- (void)setInterfaceOrientation:(UIDeviceOrientation)orientation &#123; if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123; [[UIDevice currentDevice] setValue:[NSNumber numberWithInteger:orientation] forKey:@&quot;orientation&quot;]; &#125; &#125;// 方法2：- (void)setInterfaceOrientation:(UIInterfaceOrientation)orientation &#123; if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123; SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;); NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]]; [invocation setSelector:selector]; [invocation setTarget:[UIDevice currentDevice]]; int val = orientation; [invocation setArgument:&amp;val atIndex:2]; [invocation invoke]; &#125; &#125; 注意：使用这两个方法的时候，也要确保shouldAutorotate方法返回YES，这样这两个方法才会生效。还要注意两者使用的参数类型不同； 三、屏幕旋转控制的优先级事实上，如果我们只用上面的方法来控制旋转的开启与关闭，并不能符合我们的需求，而且方法无效。这是因为我们忽略了旋转权限优先级的问题； 屏幕旋转的设置有3个地方： Xcode的General设置； info.plist的设置； 通过代码设置； 这么多的设置很是繁杂，但是这些其实都是在不同级别上实现旋转的设置，我们会遇到设置后无效的情况，这就很可能是被上一级别控制的原因； 这里先有个大致的了解，控制屏幕旋转优先级为：工程Target属性配置(全局权限) &#x3D; Appdelegate&amp;&amp;Window &gt; 根视图控制器&gt; 普通视图控制器。 四、开启屏幕旋转的全局权限这里我使用全局权限来描述这个问题可能不太准确，其实是设置我们的设备能够支持的方向有哪些，这也是实现旋转的前提； 开启屏幕旋转的全局权限有三种方法，包括通过Xcode直接配置的两种方法和代码控制的一种方法。 这三种方法作用相同，但是由于代码的控制在程序启动之后，所以也是最有效的。下面分别对三种方法的用法介绍： 1.Device Orientation属性配置我们创建了新工程，Xcode就默认替我们选择了支持旋转的几个方向，这就是Device Orientation属性的默认配置。在Xcode中依次打开：General—&gt;Deployment Info—&gt;Device Orientation,我们可以看到默认支持的设备方向如下： 可以发现，UpsideDown没有被默认支持，因为对于iPhone即使勾选也没有UpSideDown的旋转效果。我们可以在这里勾选或者取消以修改支持的旋转方向。如果是iPad设备勾选之后会同时支持四个方向； 特殊情况：对于iPhone，如果四个属性我们都选或者都不选，效果和默认的情况一样。 2.Info.Plist设置其实我们设置了Device Orientation之后，再到info.plist中查看Supported interface orientation，我们会看到： 没错，此时Supported interface orientation里的设置和UIDevice Orientation的值一致的，并且我们在这里增加或者删除其中的值，UIDevice Orientation的值也会随之变化，两者属于同一种设置； 3.Appdelegate&amp;&amp;Window中设置正常情况下，我们的App从Appdelegate中启动，而Appdelegate所持有唯一的Window对象是全局的，所以在Appdelegate文件中设置屏幕旋转也是全局有效的。 下面的代码设置了只支持竖屏和右旋转： 12345- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123; return UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft;&#125; 需要注意：如果我们实现了Appdelegate的这一方法，那么我们的App的全局旋转设置将以这里的为准，即使前两种方法的设置与这里的不同。 五、开启屏幕旋转的局部权限(视图控制器)在设置了全局所支持的旋转方向后，接着就开始设置具体的控制器界面了。我们在上面已经说明了关于旋转的优先级了。而这里主要涉及了三种视图控制器： UITabbarViewController UINavigationBarController UIViewController 自全局权限开启之后，接下来具有最高权限的就是Window的根视图控制器rootViewController了。如果我们要具体控制单个界面UIViewController的旋转就必须先看一下根视图控制器的配置情况了； 当然，在一般情况下，我们的项目都是用UITabbarViewController作为Window的根视图控制器，然后管理着若干个导航控制器UINavigationBarController，再由导航栏控制器去管理普通的视图控制器UIViewController； 若以此为例的话，关于旋转的优先级从高到低就是UITabbarViewController&gt;UINavigationBarController &gt;UIViewController了。如果具有高优先级的控制器关闭了旋转设置，那么低优先级的控制器是无法做到旋转的； 比如说我们设置要单个视图控制器可以自动旋转，这需要在视图控制器中增加shouldAutorotate方法返回YES或者NO来控制。但如果存在上层根视图控制器，而我们只在这个视图控制器中实现方法，会发现这个方法是不走的，因为这个方法被上层根视图控制器拦截了； 理解这个原理后，我们有两种方法实现自动可控的旋转设置： 方法1：逐级设置各视图控制器，高优先级的视图控制器影响低优先级控制器解决上述的问题我们需要设置UITabbarViewController如下： 1234567891011121314//是否自动旋转-(BOOL)shouldAutorotate&#123; return self.selectedViewController.shouldAutorotate;&#125;//支持哪些屏幕方向- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123; return [self.selectedViewController supportedInterfaceOrientations];&#125;//默认方向- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123; return [self.selectedViewController preferredInterfaceOrientationForPresentation];&#125; 设置导航控制器UINavigationController如下： 12345678910111213141516//是否自动旋转//返回导航控制器的顶层视图控制器的自动旋转属性，因为导航控制器是以栈的原因叠加VC的//topViewController是其最顶层的视图控制器，-(BOOL)shouldAutorotate&#123; return self.topViewController.shouldAutorotate;&#125;//支持哪些屏幕方向- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123; return [self.topViewController supportedInterfaceOrientations];&#125;//默认方向- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123; return [self.topViewController preferredInterfaceOrientationForPresentation];&#125; 到这里，我们就应该明白了，其实就是高优先级的视图控制器要跟随低优先级控制器的旋转配置。这样就能够达到目的; 方法2: 另辟蹊径，使用模态视图使用模态视图可以不受这种根视图控制器优先级的限制。这个也很容易理解，模态弹出的视图控制器是隔离出来的，不受根视图控制的影响。具体的设置和普通视图器代码相同，这里就不累述了； 六、实现需求：项目主要界面竖屏，部分界面横屏这其实也是一个我们做屏幕旋转最常见的需求，在根据上面的讲述之后，我们实现这个需求会很容易，但是具体的实现却有着不同的思路，我在这里总结了两种方法： 方法1：使用基类控制器逐级控制具体步骤： 开启全局权限设置项目支持的旋转方向； 根据第五节中的方法1，自定义标签控制器和导航控制器来设置屏幕的自动旋转； 自定义基类控制器设置不支持自动转屏，并默认只支持竖屏； 对项目中需要转屏幕的控制器开启自动转屏、设置支持的旋转方向并设置默认方向； Demo1链接: https://github.com/DreamcoffeeZS/Demo_TestRotatesOne.git 方法2：Appdelegate增设旋转属性具体步骤： 在Applegate文件中增加一个用于记录当前屏幕是否横屏的属性； 需要横屏的界面，进入界面后强制横屏，离开界面时恢复竖屏； Demo2链接: https://github.com/DreamcoffeeZS/Demo_TestRotatesTwo.git 七、默认横屏无效的问题在上面的项目中，我们可能会遇到一个关于默认横屏的问题，把它拿出来细说一下。 我们项目中有支持竖屏的界面A，也有支持横竖屏的界面B，而且界面B需要进入时就显示横屏。从界面A到界面B中，如果我们使用第五节中的方法1会遇到无法显示默认横屏的情况，因为没有旋转设备，shouldAutorotate就没被调用，也就没法显示我们需要的横屏。这里有两个解决方法： 方法1：在自定义导航控制器中增加以下方法1234567#pragma mark -UINavigationControllerDelegate//不要忘记设置delegate- (void)navigationController:(UINavigationController *)navigationController didShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; [self presentViewController:[UIViewController new] animated:NO completion:^&#123; [self dismissViewControllerAnimated:NO completion:nil]; &#125;];&#125; 这个方法的缺点是，原理上利用弹出模态视图来调用转屏，造成切换界面的时候有闪烁效果，体验不佳。所以这里也只是提供一种思路，不推荐使用； 方法2:在需要默认横屏的界面里设置，进入时强制横屏，离开时强制竖屏关于这种使用，这个具体可以参考第五节中的demo2 注意：两种方法不可同时使用 八、关于旋转后的适配问题屏幕旋转的实现会带来相应的UI适配问题，我们需要针对不同方向下的界面重新调整视图布局。首先我们要能够监测到屏幕旋转事件，这里分为两种情况： 1.视图控制器UIViewController里的监测当发生转屏事件的时候，下面的UIViewControoller方法会监测到视图View的大小变化，从而帮助我们适配 12345678910/*This method is called when the view controller&#x27;s view&#x27;s size ischanged by its parent (i.e. for the root view controller when its window rotates or is resized).If you override this method, you should either call super topropagate the change to children or manually forward the change to children. */- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator NS_AVAILABLE_IOS(8_0); 从注释里可以看出此方法在屏幕旋转的时候被调用，我们使用时候也应该首先调用super方法，具体代码使用示例如下： 12345678910111213//屏幕旋转之后，屏幕的宽高互换，我们借此判断重新布局//横屏：size.width &gt; size.height//竖屏: size.width &lt; size.height- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator&#123; [super viewWillTransitionToSize:size withTransitionCoordinator:coordinator]; if (size.width &gt; size.height) &#123; //横屏设置，为防止遮挡键盘,调整输入视图的高度 self.textView_height.constant = 50; &#125;else&#123; //竖屏设置 self.textView_height.constant = 200; &#125;&#125; 2.子视图横竖屏监测如果是类似于表视图的单元格，要监测到屏幕变化实现适配，我们需要用到layoutSubviews方法，因为屏幕切换横竖屏时会触发此方法，然后我们根据状态栏的位置就可以判断横竖屏了，代码示例如下： 123456789- (void)layoutSubviews &#123; [super layoutSubviews]; //通过状态栏电池图标判断横竖屏 if ([UIApplication sharedApplication].statusBarOrientation == UIInterfaceOrientationMaskPortrait) &#123; //竖屏布局 &#125; else &#123; //横屏布局 &#125;&#125; 九、APP启动即全屏有时项目需要从App启动就默认是横屏，这里有个很方便的方法，就是我们在Device Orientation属性配置里设置如下： 但是只这样处理的话，会让项目只支持横屏，所以我们可以在Appdelegate里再次调整我们所支持的方向，方法已经说过，这里就不累述了; 最后总结：关于屏幕旋转的使用大致总结到这里了，如果存在疏漏与错误欢迎路过的朋友指正！谢谢~","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"UI问题","slug":"UI问题","permalink":"https://wuyubeichen.github.io/tags/UI%E9%97%AE%E9%A2%98/"}]},{"title":"iOS开发-多Target配置","slug":"iOS开发-多Target配置","date":"2019-02-20T09:20:47.000Z","updated":"2025-04-05T09:43:37.374Z","comments":true,"path":"2019/02/20/iOS开发-多Target配置/","permalink":"https://wuyubeichen.github.io/2019/02/20/iOS%E5%BC%80%E5%8F%91-%E5%A4%9ATarget%E9%85%8D%E7%BD%AE/","excerpt":"我们在iOS开发中可能会遇到同时开发多个类似项目的情况。这些项目大同小异，有诸多代码可以共用，如果每个项目都分别开发，这在后期的迭代中会十分繁琐。为了解决这个问题，使用多Target开发是一种比较好的选择，本文就这一技术实现进行简要总结。","text":"我们在iOS开发中可能会遇到同时开发多个类似项目的情况。这些项目大同小异，有诸多代码可以共用，如果每个项目都分别开发，这在后期的迭代中会十分繁琐。为了解决这个问题，使用多Target开发是一种比较好的选择，本文就这一技术实现进行简要总结。 一、理解项目中的Porject与Target使用Xcode来开发项目，其中的Project是一个整体项目相当于一个仓库，包括了所有的代码和资源文件。而Target相当于一个具体的产品，包含了对于代码，资源文件的具体使用规则和配置。一个Project可以包含多个Target，也就是说通过不同Target我们可以生成不同的APP。 二、多Target开发项目的实践步骤使用多Target来创建项目，就以我当前正在开发的亲戚买房APP为例。需求是这样的：亲戚买房是一个为买房人提供砍价服务的APP，APP的用户需要区分为用户，专家和砍价师三个用户群体。所以这里以Customer，Consul，Bargain三个Target来开发应用 1.以QQMF(亲戚买房)为名创建一个新的工程如下: 2.创建三种Target创建新Target的方式有两种：第一种：依次选择File-&gt;New-&gt;Target，然后选择一个模板(通常是Single View App)来创建。只是这样创建的target带有Appdelegate和main等文件，在这里并不会用到这些文件，所以我们采用第二种方式创建。第二种：在Targets中点击已有的Target，右键选择Duplicate可以复制生成一个copy的新Target，并且在文件目录中生成对应的copy-Info.plist文件。这样生成的target与被拷贝的target相似度很大，减少了过多的修改。通常为了减少后期的修改，我们也会首先在原有的Target中修改一些配置之后再Duplicate。 执行了Duplicate操作之后的效果如下： 3.修改Targe和plist文件的名称为自己需要的名称在Target里可以直接修改Target的名称，在文件目录下也可以直接修改plist文件的名称。如果我们不想文件结构那么乱，也可以像其他文件一样移动plist文件的位置并重新引用到工程中，如下：特别注意：我们在移动文件的时候可能需要重新引用文件到工程中，此时add文件的时候一定要注意选择Target，如果是共用文件一定要勾选对应的Target，类似AppDelegate这样文件的操作如下： 4.修改Xcode左上角的Target名称选中Xcode左上角的创建工程时的Target(QQMF)，选择Manage schemes在如下的schemes中修改Target的名称，这里也可以删除多余的最初的QQMF 特别说明：QQMF是我们创建工程自带的Target,其实也可以修改它的名字以供自定义使用，而这里我们是直接删掉了它，这样之后，项目自带的info.plist也是没用的了，也可以删掉。 5.设置Target与plist文件对应切换到Target目录下，我们可以在这里删掉用不到的QQMF，选择其中一个Target之后并选择general，然后可以看到每个Target的右侧都有对应的choose info.plist file选项，点击可以选择与Target对应的plist文件。这也就相当于不同的Target项目对应了不同的plist配置。 6.为每个Target设置Display Name，Bundle Identifier等信息点击Target-&gt;选择General，我们分别设置不同项目的名称和BundleID信息，以及证书等 7.同一份代码区分不同Target的操作使用多Target是为了共用一部分代码，但是有些共用的文件在不同的Target下是有细微不同的，那么我们在具体实现的时候就需要作出区分。这里解决的方法是针对不同的Target定义宏。首先选择一个Target,如Customer，依次选择Build Settings -&gt;搜索PreprocessorMacros, 在找到PreprocessorMacros之后，我们分别在Debug和Release中设置TargetType&#x3D;1如下图进行设置： 其他的Target也是同样的设置方式，只是要区分TargetType的值，分别是2，3(TargetType及其值都是自定义的)。然后就是在代码中的使用如下图，分别选择Xcode左上角不同的Target运行，查看控制台验证是否成功。 8.解决使用Cocoapods的问题因为存在多个Target，我们需要区别的设置不同target需要的第三方库，如下图。这里可能出现的问题是如果有很多类似AFNetworking这样的被多个Target需要的类库，我们在删除和增加的时候就会频繁的操作而且会代码冗余。解决上述问题的比较优雅的做法是如下： 三、遇到的问题 问题：invalid token at start of a preprocessor expression原因：这是我在pch文件中判断target类型出现的错误，这句话的大致意思是：在预编译阶段，代码并未运行，无法判断宏定义的值。最后查找到原因是我在上述步骤设置宏定义的时候，手误设置了TargetType&#x3D;&#x3D;1，这本是一句需要执行才能得到结果的代码。所以无法在#if的条件编译中通过。解决：在条件编译中不使用代码运行时才生成的量即可。","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://wuyubeichen.github.io/tags/Xcode/"},{"name":"环境配置","slug":"环境配置","permalink":"https://wuyubeichen.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"iOS开发-CPU架构问题","slug":"iOS开发-CPU架构问题","date":"2019-02-18T10:18:44.000Z","updated":"2025-05-03T16:11:21.366Z","comments":true,"path":"2019/02/18/iOS开发-CPU架构问题/","permalink":"https://wuyubeichen.github.io/2019/02/18/iOS%E5%BC%80%E5%8F%91-CPU%E6%9E%B6%E6%9E%84%E9%97%AE%E9%A2%98/","excerpt":"首先，之所以提到CPU架构的问题，其实是因为我们iOS开发使用的静态库与动态库与之紧密相连。每一个开发的App都要运行在模拟器或者真机上，在编译的时候，Xcode需要去分析当前运行平台的CPU架构，然后确定所使用的静态库是否支持这个CPU架构。如果不支持就会报错。","text":"首先，之所以提到CPU架构的问题，其实是因为我们iOS开发使用的静态库与动态库与之紧密相连。每一个开发的App都要运行在模拟器或者真机上，在编译的时候，Xcode需要去分析当前运行平台的CPU架构，然后确定所使用的静态库是否支持这个CPU架构。如果不支持就会报错。 一、什么是CPU架构“CPU架构是CPU厂商给属于同一系列的CPU产品定的一个规范，主要目的是为了区分不同类型CPU的重要标示。目前市面上的CPU分类主要分有两大阵营，一个是intel、AMD为首的复杂指令集CPU，另一个是以IBM、ARM为首的精简指令集CPU。两个不同品牌的CPU，其产品的架构也不相同，例如，Intel、AMD的CPU是X86架构的，而IBM公司的CPU是PowerPC架构，ARM公司是ARM架构”（摘自百度）通常，我们知道电脑的CPU架构有X86和X64等，但是手机的主流CPU架构是ARM架构，因为采用ARM架构的CPU是一种微处理器，这种处理器功耗低，体积小，更适合手机使用，iPhone的CPU也是如此。 二、iPhone移动设备默认指令集那么，总结iPhone设备默认指令集的使用情况如下： 三、有关指令集使用特点 上述arm处理器指令集，在原则上它们都是向下兼容的。比如iPhone6s的CPU默认指令集是arm64,但是也同时支持armv7s等以前版本的指令集，只是效率变低了而已。 xcode模拟器其实是在电脑上的，所以iOS模拟器并没有使用arm指令集。它编译运行使用的是x86指令集(或者i386)。而在真机上使用的才是arm类型的指令集。 在Xcode中设置二进制包所支持的指令集，对于编译后的二进制包的大小影响显著，设置支持的指令集个数越少，安装包也越小。 四、Xcode中关于指令集的配置与使用具体在Xcode中的使用，我们在Xcode中选择将要设置的target，然后打开build setting, 可以看到有关指令集设置的Architectures选项。 在这里的关键设置有三个，可以通过这里设置Xcode生成二进制包的指令集 1.Architectures:作用：设置工程被编译后将支持哪些指令集，支持指令集是通过编译生成对应的二进制数据包实现的。特点：设置支持的指令集数据越多，编译出的二进制包包含的指令集代码越多，这样就会使最后编译的包很大。 2.valid Architectures：作用：设置可能支持的指令集，这里的指令集选项和Architectures列表中指令集选项的交集，将决定最后Xcode生成二进制包所支持的指令集。举例：Architectures支持armv7, Valid Architecture支持armv7、armv7s、armv64，那么Xcode只会生成一个armv7指令集的二进制包。 3.build Active Architecture only作用：设置是否只编译当前使用设备所对应的arm指令集。也就是说当该项设置为YES的时候，上述规则(Architectures和valid Architectures交集决定二进制包所支持指令集)将被打破。举列：设置该选项是YES,并且连接一个armv7指令集设备，无论前面两项如何设置，Xcode最终生成armv7指令集的二进制包。不过设置为YES生效有个前提条件就是，Xcode必须成功连接了调试的设备。 一般的情况下，build Active Architecture only选项默认在Debug模式下是YES, Release模式下是NO，但是我们在开发的时候，有时候也会遇到一些第三方文件找不到路径的问题，这时要求我们设置Debug模式下也为NO。 五、遇到的问题在这里记录一个在开发中遇到的问题。曾经在使用CocoaPods管理第三方的时候，遇到了“library not found for -lXXX”的错误，当时使用了Masonry的库。Xcode报错如下：其实这是因为CocoaPods在引入第三方类库的时候，默认build Active Architecture only在Debug模式下是YES导致的，修改为NO就可以了。","categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://wuyubeichen.github.io/tags/Xcode/"},{"name":"CPU架构","slug":"CPU架构","permalink":"https://wuyubeichen.github.io/tags/CPU%E6%9E%B6%E6%9E%84/"},{"name":"环境配置","slug":"环境配置","permalink":"https://wuyubeichen.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"Charles抓包HTTP、HTTPS","slug":"Charles抓包HTTP、HTTPS","date":"2019-02-14T08:16:49.000Z","updated":"2025-05-03T16:23:37.863Z","comments":true,"path":"2019/02/14/Charles抓包HTTP、HTTPS/","permalink":"https://wuyubeichen.github.io/2019/02/14/Charles%E6%8A%93%E5%8C%85HTTP%E3%80%81HTTPS/","excerpt":"抓包分析数据在移动开发中十分重要，可以帮助我们更快的了解数据构成，提高开发效率。但是在苹果要求上线的App必须使用HTTS之后，HTTPS数据包的抓取分析较为麻烦，在此总结了在mac上使用Charles抓包的详细步骤。","text":"抓包分析数据在移动开发中十分重要，可以帮助我们更快的了解数据构成，提高开发效率。但是在苹果要求上线的App必须使用HTTS之后，HTTPS数据包的抓取分析较为麻烦，在此总结了在mac上使用Charles抓包的详细步骤。 首先我们下载最先版本的Charles官网下载：https://www.charlesproxy.com/download/免费版下载：http://xclient.info/search/s/charles/ 一、开启网络请求记录，设置系统网络代理安装Charles之后，我们选择Proxy-&gt;Start Recording，开始记录网络请求，然后勾选MacOS Proxy(和其他的代理对象如：Mozilla Firefox Proxy火狐浏览器）,将系统代理设置通过Charles Proxy。 此时打开系统偏好设置-&gt;网络-&gt;高级，我们可以看到本机HTTP和HTTPS请求被代理到127.0.0.1，端口号是8888。至此，我们已经完成了基本的网路请求设置，通过此Mac发起的HTTP请求，我们都可以通过Charles分析。 注：在Charles关闭的时候，这里的web代理和安全web代理也会变成无勾选状态。保证无代理时，Mac也能够访问网络。 二、iPhone数据包的抓取1.打开Charles的代理功能为了使用Charles抓取到iPhone设备的数据包，我们首先要打开Charles的代理功能。选择Proxy -&gt;Proxy Setting，设置Port:8888，选择Enable TransParent HTTP Proxying。 2.获取本机电脑IP接下来我们要将手机的网络代理IP设置为Charles运行所在的电脑IP，获取本机电脑的IP方法如下：方法一：Mac电脑上使用Control +空格键，并输入Terminal 可以进入控制台，然后键入 ifconfig en0命令 ，我们查看到当前电脑的IP地址。 方法二：通过Charles查看本机的IP地址：打开Charles -&gt;Help-&gt;Local IP Address 3. 设置手机网络代理IP我们依次打开iphone “设置-&gt;无线局域网”，点击当前连接Wifi右侧的详情按钮。这里显示了当前连接Wifi的基本信息，我们需要将这里底部的HTTP代理改为手动，然后填上Charles运行所在电脑的IP和端口号8888。如图： 此时，iPhone的网络代理就设置完成了，手机上请求将会被代理到mac上，我们可以很方便的通过Charles查看到手机应用发起的网络请求数据包。 三、抓取HTTPS数据包相对于HTTP类的网络请求，HTTPS请求更加安全，这也使得抓取这类的数据包进行分析要麻烦一些。抓取HTTPS请求数据包进行分析，关键的步骤如下： 1.安装Charles根证书打开charles,依次点击Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate，安装根证书 2.设置证书信任在安装证书之后，我们查看钥匙串。选择所有项目，我们会看到一个带有红叉标记不被信任的Charles证书。Charles证书默认是不信任的，需要我们手动设置。右键-&gt;显示简介-&gt;点击信任，我们如图设置始终信任。 3.设置 SSL 代理打开charles应用，选择Proxy-&gt;SSL Proxying Settings,我们在这里设置SSL Proxy,点击面板上的add，如下图： 在这里我们设置主机地址Host是*,使用通配符表示检测所有网络请求。然后设置端口号是443 4.iOS设备安装证书最后我们还需要在iOS设备上安装证书。点击 Charles 的顶部菜单，选择 Help –&gt; SSL Proxying–&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser，然后就可以看到 Charles 显示如下弹窗： 然后我们需要打开safari ,输入网址： http://charlesproxy.com/getssl，这时候会弹出安装证书的界面，我们点击安装证书，如图：目前为止，我们就完成了Charles抓取HTTPS数据包的所有设置了。查看Charles,我们可以看到数据包的内容了。 5.失败请求的处理iOS10.3之后，在上述设置完成之后，所有的https请求都会失败。提示错误：Failure SSLHandshake: Received fatal alert: unknown_ca 和You may need to configure your browser or application to trust the Charles Root Certificate.原因：charles的根证书虽然已经在安装列表中,但在iOS 10.3之后,安装新的自定义证书默认是不受信任的。如果要信任已安装的自定义证书,需要手动打开开关以信任证书。解决：设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy custom root certificate然后信任该证书即可. 模拟器也是这样处理。 四、使用Charles遇到的问题我在使用Charles抓包https之后，在使用applicationLoader上传ipa包的时候遇到了下面的问题：Communication error. Please use diagnostic mode to check connectivity. You need to have outbound access to TCP port 443. 解决：将charles关闭，然后再上传ipa文件。至于原因我也没弄明白，如果哪位朋友知道也可以告诉我一下。","categories":[{"name":"网络原理","slug":"网络原理","permalink":"https://wuyubeichen.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"抓包","slug":"抓包","permalink":"https://wuyubeichen.github.io/tags/%E6%8A%93%E5%8C%85/"}]},{"title":"Python学习05-数据类型(04)-set与dict","slug":"Python学习05-数据类型(04)-set与dict","date":"2018-08-08T15:39:33.000Z","updated":"2025-05-03T16:12:05.789Z","comments":true,"path":"2018/08/08/Python学习05-数据类型(04)-set与dict/","permalink":"https://wuyubeichen.github.io/2018/08/08/Python%E5%AD%A6%E4%B9%A005-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(04)-set%E4%B8%8Edict/","excerpt":"区别于序列型数据类型(str、list、tuple)，此篇学习到的是无序数据类型：set和dict； 一、集合set 集合set使用&#123;&#125;表示，定义一个空的集合使用set(); 集合中的数据无序存放的，因此也不能使用索引取值和切片操作； 集合中的元素是非重复的； 从数学的角度理解，集合可以实现差集(&#39;-&#39;)、交集(&#39;&amp;&#39;)、并集(&#39;|&#39;)","text":"区别于序列型数据类型(str、list、tuple)，此篇学习到的是无序数据类型：set和dict； 一、集合set 集合set使用&#123;&#125;表示，定义一个空的集合使用set(); 集合中的数据无序存放的，因此也不能使用索引取值和切片操作； 集合中的元素是非重复的； 从数学的角度理解，集合可以实现差集(&#39;-&#39;)、交集(&#39;&amp;&#39;)、并集(&#39;|&#39;) 测试1：创建集合有如下两种方法， 其中的元素是非重复的1234567891011&gt;&gt;&gt; set1 = &#123;1,2,3&#125;&gt;&gt;&gt; type(set1)&lt;class &#x27;set&#x27;&gt;&gt;&gt;&gt; print(set1)&#123;1, 2, 3&#125;&gt;&gt;&gt; set2 = set([3,4,4,6])&gt;&gt;&gt; type(set2)&lt;class &#x27;set&#x27;&gt;&gt;&gt;&gt; print(set2)&#123;3, 4, 6&#125; 测试2：集合之间的操作12345678&gt;&gt;&gt; set2 - set1&#123;4, 6&#125;&gt;&gt;&gt; set1 &amp; set2&#123;3&#125;&gt;&gt;&gt; set1 | set2&#123;1, 2, 3, 4, 6&#125; 测试3：向集合中添加和删除元素1234567891011&gt;&gt;&gt; set1.add(3)&gt;&gt;&gt; print(set1)&#123;1, 2, 3&#125;&gt;&gt;&gt; set1.add(4)&gt;&gt;&gt; print(set1)&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; set1.remove(1)&gt;&gt;&gt; print(set1)&#123;2, 3, 4&#125; 二、字典dict 字典dict使用&#123;&#125;表示，其中的键值对使用逗号将分开，定义一个空字典可以使用&#123;&#125;； 字典的数据是无序存放的，因此也不能使用索引取值和切片操作； 字典的元素是非重复的，新值会覆盖旧值; 字典的key不一定非要是字符串，也可以是数字等，但key必须不可变，比如list不可以作为key，tuple可以； 测试1：创建一个字典，并且通过key增加新的值123&gt;&gt;&gt; dict1 = &#123;&quot;1&quot;:&quot;one&quot;, &quot;2&quot;:&quot;two&quot;, &quot;3&quot;:&quot;three&quot;&#125;&gt;&gt;&gt; print(dict1)&#123;&#x27;1&#x27;: &#x27;one&#x27;, &#x27;2&#x27;: &#x27;two&#x27;, &#x27;3&#x27;: &#x27;three&#x27;&#125; 测试2：一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值覆盖掉123&gt;&gt;&gt; dict1[&quot;1&quot;]=&quot;oneone&quot;&gt;&gt;&gt; print(dict1)&#123;&#x27;1&#x27;: &#x27;oneone&#x27;, &#x27;2&#x27;: &#x27;two&#x27;, &#x27;3&#x27;: &#x27;three&#x27;&#125; 测试3：key不存在时取值报错，若要避免报错，有两种方法 方法1：使用in判断key是否在当前的字典中 方法2：使用字典的get方法，key不存在时会返回None，或者自定义返回的value 1234567891011121314&gt;&gt;&gt; dict1[&quot;5&quot;]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &#x27;5&#x27;&gt;&gt;&gt; &gt;&gt;&gt; &quot;5&quot; in dict1False&gt;&gt;&gt; print(dict1.get(&quot;5&quot;))None&gt;&gt;&gt; print(dict1.get(&quot;5&quot;,-1))-1","categories":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/tags/Python/"}]},{"title":"Python学习05-数据类型(03)-list与tuple","slug":"Python学习05-数据类型(03)-list与tuple","date":"2018-08-07T15:39:33.000Z","updated":"2025-05-03T16:11:56.831Z","comments":true,"path":"2018/08/07/Python学习05-数据类型(03)-list与tuple/","permalink":"https://wuyubeichen.github.io/2018/08/07/Python%E5%AD%A6%E4%B9%A005-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(03)-list%E4%B8%8Etuple/","excerpt":"一、理解列表list列表类似其他语言中数组的概念，使用type方法打印会得到&lt;class &#39;list&#39;&gt;，列表具有以下特点： 列表使用中括号[]来表示; 组中的数据类型并不是固定的，可以是字符串，整型，布尔值等的混合元素，如[1,False，&quot;helloworld&quot;]; 嵌套列表，即列表中还有列表元素，如[[1,2],[False],[&quot;Hello&quot;,&quot;World&quot;]]; 列表作为一个容器，其中的元素都是有序的；","text":"一、理解列表list列表类似其他语言中数组的概念，使用type方法打印会得到&lt;class &#39;list&#39;&gt;，列表具有以下特点： 列表使用中括号[]来表示; 组中的数据类型并不是固定的，可以是字符串，整型，布尔值等的混合元素，如[1,False，&quot;helloworld&quot;]; 嵌套列表，即列表中还有列表元素，如[[1,2],[False],[&quot;Hello&quot;,&quot;World&quot;]]; 列表作为一个容器，其中的元素都是有序的； 二、理解元组tuple元组类似其他语言中结构体的概念，使用type方法打印会得到&lt;class &#39;tuple&#39;&gt;，元组具有以下特点： 元组使用小括号()来表示； 元组中的元素个数是确定的； 三、区分列表与元组相同点： 列表、元组和字符串都是序列型数据，即它们中存放的元素都是有序的； 因此，所有适用于字符串的那些切片操作也能在列表和元组中使用； 不同点： 列表list是可变数据类型，可以追加和修改元素，但是元组则不能； 实际开发中，在不确定长度的相同类型队列的时候用列表，而对于提前知道元素数量的时候用元组； 123456789101112131415&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; a.append(&quot;Python&quot;)&gt;&gt;&gt; print(a)[1, 2, 3, &#x27;Python&#x27;]&gt;&gt;&gt; b = (1,2,3)&gt;&gt;&gt; b.append(&quot;Python&quot;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;tuple&#x27; object has no attribute &#x27;append&#x27;&gt;&gt;&gt; b[2] = &quot;Python&quot;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;tuple&#x27; object does not support item assignment 四、关于元组的一个有趣的测试在Python解释器中，使用type函数打印只有一个元素的元组如：type((1))，结果为int类型； 12&gt;&gt;&gt; type((1))&lt;class &#x27;int&#x27;&gt; 分析原因：Python中的小括号既表示数学的优先运算，也可以表示元组，此处存在歧义； 表示只有一个元素的元组和空元组，分别使用(1,)，(())，测试如下： 12345&gt;&gt;&gt; type((1,))&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; type(())&lt;class &#x27;tuple&#x27;&gt;","categories":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/tags/Python/"}]},{"title":"Python学习05-数据类型(02)-str","slug":"Python学习05-数据类型(02)-str","date":"2018-08-06T15:39:33.000Z","updated":"2025-05-03T16:25:14.663Z","comments":true,"path":"2018/08/06/Python学习05-数据类型(02)-str/","permalink":"https://wuyubeichen.github.io/2018/08/06/Python%E5%AD%A6%E4%B9%A005-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(02)-str/","excerpt":"主要内容： 引号的使用 多行字符串 转义字符","text":"主要内容： 引号的使用 多行字符串 转义字符 字符串常规操作 一、引号的使用Python中的字符串是由数字、字母、下划线组成的一串字符： 表示字符串需要使用用单引号、双引号和三引号； 用于表示字符串的引号必须是成对出现的； 字符串中使用引号，需要使用转义字符&quot;\\&quot;； 123456789&gt;&gt;&gt; &#x27;str1&#x27;&#x27;str1&#x27;&gt;&gt;&gt; &quot;str2&quot;&#x27;str2&#x27;&gt;&gt;&gt; &quot;&quot;&quot;str3&quot;&quot;&quot;&#x27;str3&#x27;&gt;&gt;&gt; &quot;str4\\&#x27;str5&quot;&quot;str4&#x27;str5&quot;&gt;&gt;&gt; 二、多行字符串在Python的解释器中输入多行字符串，并且可以在输入过程中换行，需要在字符串首尾使用三引号。 12345678910111213&gt;&gt;&gt; &quot;&quot;&quot;... 123... 456... 789... &quot;&quot;&quot;&#x27;\\n123\\n456\\n789\\n&#x27;&gt;&gt;&gt; &quot;Life is simple, \\nI use Python&quot;&#x27;Life is simple, \\nI use Python&#x27;&gt;&gt;&gt; print(&quot;Life is simple, \\nI use Python&quot;)Life is simple, I use Python 这里的三引号可以是三个单引号；也可以三个双引号； 输入多行字符串并手动换行，直接打印后，手动换行的操作会被转化为&quot;\\n&quot;； 输入字符串中存在换行符&quot;\\n&quot;，直接打印后，其中的&quot;\\n&quot;不会显示为换行，若要显示换行，还需要使用print函数； 三、转义字符Python使用反斜杠\\转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个r，表示原始字符串： 12345&gt;&gt;&gt; print(&#x27;Helllo\\nWorld&#x27;)HellloWorld&gt;&gt;&gt; print(r&#x27;Helllo\\nWorld&#x27;)Helllo\\nWorld 另外，反斜杠(\\)可以作为续行符，解决长字符串的输入的问题： 123456&gt;&gt;&gt; &quot;111\\... 222\\... 333\\... &quot;&#x27;111222333&#x27;&gt;&gt;&gt; 四、字符串常规操作首先，定义三个字符串变量来测试字符串操作： 123a = &quot;Hello World&quot;b=&quot;Python&quot;c=&quot;Hello Python Java C# javascript Php Ruby&quot; 1.字符串拼接:”+”123&gt;&gt;&gt; a+b&#x27;Hello WorldPython&#x27;&gt;&gt;&gt; 2.字符串重复：”*”字符串乘以一个整型数字，可以将原字符串按倍数重复连接。 123&gt;&gt;&gt; b*3&#x27;PythonPythonPython&#x27;&gt;&gt;&gt; 3.通过索引获取指定位置字符串：[]123456789&gt;&gt;&gt; a[0]&#x27;H&#x27;&gt;&gt;&gt; a[-1]&#x27;d&#x27;&gt;&gt;&gt; a[100]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: string index out of range&gt;&gt;&gt; 4.截取字符串，又称字符串切片：[:]测试1： 12345&gt;&gt;&gt; a[0:5]&#x27;Hello&#x27;&gt;&gt;&gt; &gt;&gt;&gt; a[0:-1]&#x27;Hello Worl&#x27; 测试2：截取”World“ 12345&gt;&gt;&gt; a[6:11]&#x27;World&#x27;&gt;&gt;&gt; &gt;&gt;&gt; a[6:]&#x27;World&#x27; 测试3：截取长字符串后的的部分，如c的”Ruby” 12&gt;&gt;&gt; c[-4:]&#x27;Ruby&#x27; 5.判断字符串：“in” ，判断字符串非包含：“not in”1234&gt;&gt;&gt; &quot;H&quot; in aTrue&gt;&gt;&gt; &quot;H&quot; not in aFalse 6.获取字符串长度12&gt;&gt;&gt; len(a)11 7.获取字符串最大和最小字符(按照ASCll码规则)：max(字符串)，min(字符串)12345678&gt;&gt;&gt; max(&quot;Hello World&quot;)&#x27;r&#x27;&gt;&gt;&gt; max(&quot;hello world&quot;)&#x27;w&#x27;&gt;&gt;&gt; min(&quot;hello world&quot;)&#x27; &#x27;&gt;&gt;&gt; min(&quot;helloworld&quot;)&#x27;d&#x27; 8.获取字符串的ASCll码：ord(字符串)12&gt;&gt;&gt; ord(&quot;w&quot;)119","categories":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/tags/Python/"}]},{"title":"Python学习05-数据类型(01)-Number","slug":"Python学习05-数据类型(01)-Number","date":"2018-08-05T15:39:33.000Z","updated":"2025-05-03T16:11:51.128Z","comments":true,"path":"2018/08/05/Python学习05-数据类型(01)-Number/","permalink":"https://wuyubeichen.github.io/2018/08/05/Python%E5%AD%A6%E4%B9%A005-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(01)-Number/","excerpt":"主要内容： Number类型 Number的各种运算 Number数据类型之间的转换","text":"主要内容： Number类型 Number的各种运算 Number数据类型之间的转换 一、Number类型 Python3的Number类型支持 int、float、bool、complex(复数)四种； Python3只有一种整数类型 int，表示为长整型，没有 python2 中的 Long； Number是不可改变的数据类型，这意味着改变数字，数据类型会分配一个新的对象； 1.整型Python3中的整型包括正或负整数; 区别于其他语言的是，其他语言中的整型细分为：短整型(short) 、整型(int)、长整型(long); 不同进制数字表示： 表示二进制：数字前加&quot;ob&quot;，比如表示十进制2：&quot;0b10&quot;; 表示八进制：数字前加&quot;0o&quot;，比如表示十进制8：&quot;0o10&quot;; 表示十进制：不需要特殊前缀； 表示十六进制：数字前加&quot;0x&quot;，比如表示十进制31：&quot;0x1F&quot;; 2.浮点型Python中的浮点型数字由整数部分与小数部分组成; 区别于其他语言的是，其他语言中的浮点型细分为：单精度(float)、双精度(double); 3.复数复数由实数部分和虚数部分构成，有一下几种表示方式： 可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型; 以后缀“j”结尾表示复数，如36j； 4.布尔型布尔型是Number类型的一种，表示真(True)与假(False)，它可以和整型相互转换。在Python解释器中，测试它的用法： 语法：int(True)、int(false)，可以分别转化为数字：1和0; 语法：bool(1)、bool(0)，可以分别转化为布尔型：True和False; 注意：但是并只有数字1和0可以表示True和False；对于数字0、空字符串、空数字等空数据对象都可以被转化为False，反之为True; 二、Number的各种运算 三、Number数据类型之间的转换 类型转换: int(x) 类型转换：将x转换为整型 float() 类型转换：将x转换为浮点型 bool(x) 类型转换：将x转换成一个布尔类型 complex(x, y) 类型转换：将x和y转换成一个复数，实数部分为x，虚数部分为y 进制转换: bin(number) 进制转换：将number转换为二进制数 oct(number) 进制转换：将number转换为八进制数 int(number) 进制转换：将number转换为十进制数 hex(number) 进制转换：将number转换为十六进制数 其他操作： chr(x) 将一个整数转换为字符 str(x) 讲一个数字转换为字符串 注意：在Python解释器中输入各进制数后直接回车，Python也会将其自动转换为十进制；","categories":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/tags/Python/"}]},{"title":"Python学习04-变量与数据类型","slug":"Python学习04-变量与数据类型","date":"2018-08-04T15:40:57.000Z","updated":"2025-05-03T16:11:48.730Z","comments":true,"path":"2018/08/04/Python学习04-变量与数据类型/","permalink":"https://wuyubeichen.github.io/2018/08/04/Python%E5%AD%A6%E4%B9%A004-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"学习一门新语言，一切从变量与基本类型说起。Python中的变量使用与其他常见语言有所不同，最大的特点就是Python的变量不需要声明。","text":"学习一门新语言，一切从变量与基本类型说起。Python中的变量使用与其他常见语言有所不同，最大的特点就是Python的变量不需要声明。 一、Python中变量使用特点 每个变量在使用前都必须赋值，变量赋值后才会被创建。 Python中的变量就是变量，它没有类型，我们所说的&quot;类型&quot;是变量所指的内存中对象的类型。 等号(=)用来给变量赋值。 等号(=)运算符左边是一个变量名，等号(=)运算符右边是存储在变量中的值。 变量名的首字母不能是数字，而是字母、数字、下划线的组合; 二、Python变量的定义1. 单个变量的定义12name = &quot;fengzi&quot;age = 18 2. 多个变量的定义如下：12a = b = c = 1a,b,c = 1,2, &quot;fengzi&quot; 三、基本数据类型在内存中存储的数据可以有多种类型。例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。Python也定义了一些基本的数据类型，用于存储各种类型的数据，大致可以被归纳为以下几种： 1.打印类型在Python的解释器中可以使用type函数来打印各种数据类型的值。尤其在学习初期，可以很方便的帮助我们理解各种类型的使用，操作如下： 2.测试可变与不可变 四、值类型与引用类型 Number、str、tuple是值类型 list 、set、 dict 是引用类型","categories":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/tags/Python/"}]},{"title":"Python学习03-理解计算机中的编码","slug":"Python学习03-理解计算机中的编码","date":"2018-08-03T15:40:57.000Z","updated":"2025-05-03T16:11:46.331Z","comments":true,"path":"2018/08/03/Python学习03-理解计算机中的编码/","permalink":"https://wuyubeichen.github.io/2018/08/03/Python%E5%AD%A6%E4%B9%A003-%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81/","excerpt":"我们学习Python编程，经常对字符串这样的数据进行处理。我们也都知道计算机内部信息是采用二进制编码的，那么这其中的处理原理是什么呢？本篇就计算机中关于编码的知识进行总结。","text":"我们学习Python编程，经常对字符串这样的数据进行处理。我们也都知道计算机内部信息是采用二进制编码的，那么这其中的处理原理是什么呢？本篇就计算机中关于编码的知识进行总结。 一、为什么计算机内部信息采用二进制编码计算机是由逻辑电路组成的，而逻辑电路只有接通与断开两个状态，正好可以对映二进制的“1”与“0”。这样的计算机设计在技术上会简单许多。 二、计算机编码的由来计算机内部信息采用二进制编码，这决定了它只能直接识别0和1。我们所有各类型数据也都需要被转换为二进制0和1的序列存放在计算机中的。但是这样就产生了问题，对于一个很长的二进制序列，我们很难理解它的含义。 因此，我们可以规定每个字符的二进制序列，并把它存在计算机内，当需要将二进制位转换成我们能看懂的字符数据时，让计算机去截取二进制位查找对应的表，翻译成我们看的懂的数据。这种规定字符的二进制序列的做法就是一种编码行为，让计算机翻译就是一种解码行为。 这样，也就产生了各种我们常见的计算机编码，如：ASCll编码、UTF-8编码、Unicode编码等。 三、认识常见的计算机编码1.ASCll编码计算机是由美国人发明的，他们设计的ASCll编码是基于罗马字母表的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。英语只有26个英文字母，所以ASCll编码只用8位二进制就表示了所有他们需要的字符。ASCll编码也是现今最通用的单字节编码系统。但是我们的汉字有几万个之多，ASCll编码并不能完全适用，所以后来我们也创造了适合中文的编码方式。 在计算机的存储中，一个ASCII码值占一个字节(8个二进制位)，其最高位(b7)用作奇偶校验位。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。 奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1； 偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1。 2.ISO-8859-1&#x2F;Windows-1252ISO-8859-1编码:ASCll编码的一个字节并未用完，后来的欧洲国家为了增加它们经常使用的字符，就在原ASCll编码的基础上扩充进而创造了ISO-8859-1编码，又称西欧语言。 Windows-1252编码:Windows-1252编码是ISO-8859-1编码的超集，现在的HTML5规范中就要求ISO-8859-1 的文档实际上用 Windows-1252 编码进行分析。 3.GB2312编码(简体中文)与GBK编码汉字众多，一个字节长度的编码显然不适合，所以我国在1981年5月1日开始实施的一套国家标准GB2312，适用于汉字处理、汉字通信等系统之间的信息交换。 GB2312使用两个字节来表示汉字。小于127的依然表示原来的字符（也就是该字节最高位为0），当计算机遇到两个大于127的字节时候（也就是两个字节的最高位都是1），就一次性读取两个字节，将它解码成一个汉字。 GB2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；同时，GB2312收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符。 4.GBK与GB18030GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。但是对于人名、古汉语等方面出现的罕用字，GB2312不能处理，这导致了后来GBK及GB18030汉字字符集的出现。 GBK：向下兼容GB2312，增加新的汉字，共收录了21003个汉字。 GB18030：再次对GBK的扩充，增加了日韩和少数民族的字符编码。 5.Unicode编码如果每个国家都按照自己的标准编码字符集，就会对编码不同的两个国家的交流造成很困难。为了统一所有文字的编码，Unicode应运而生。 但是，UNicode仅仅只是一个字符集，就是为每个字符规定一个用来表示该字符的二进制数字，至于这个二进制代码如何存储则没有任何规定。试想，如果按照汉字所需的2到4个字节来编码，那么英文文档的大小也就大出了1到3倍。 为了解决Unicode编码的问题，UTT-8和UTF-16以及UTF-32出现了。 UTF-8是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度；* UTF-16编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点； 四、参考文章 ISO-8859-1编码 Windows-1252编码","categories":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/tags/Python/"}]},{"title":"Python学习(2)：环境安装与运行","slug":"Python学习02-环境安装与运行","date":"2018-08-02T15:40:57.000Z","updated":"2025-05-03T16:11:39.880Z","comments":true,"path":"2018/08/02/Python学习02-环境安装与运行/","permalink":"https://wuyubeichen.github.io/2018/08/02/Python%E5%AD%A6%E4%B9%A002-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C/","excerpt":"Python作为一门跨平台语言，能够在不同的操作系统上很好的运行。当前主流计算机的操作系统有Windows，Mac OS，Linux三种，而在不同操作系统上安装Pyhton环境会有些许不同。","text":"Python作为一门跨平台语言，能够在不同的操作系统上很好的运行。当前主流计算机的操作系统有Windows，Mac OS，Linux三种，而在不同操作系统上安装Pyhton环境会有些许不同。 一、选择Python版本Python目前有两个版本，一个是2.x版本，一个是3.x版本，两个版本互不兼容。但由于3.x版本越来越流行，所以我们都应该选择3.x版本进行安装。 二、Windows安装PythonWindows操作系统并没有内置Python环境，需要独立安装。 1.下载Python进入Python官网，选择Downloads-&gt;Windows-&gt;选择Python版本下载 选择系统版本:x86-64(简称x64)支持64位系统安装，x84支持32位系统安装 选择安装方式: web-based: 通过网络安裝，下载的文件很小，点击运行会从网络下载安装Python; executable: 下载后得到完整的Python，在本机安装； embeddable zip file: 下载得到打包成zip的Python 2.安装Python.exe运行下载的Python.exe，勾选Add Python to PATH(添加后可以在window的命令行下运行Python)，然后选择Customize Installation，按照提示即可完成Python的安装。 三、Mac OS与Linux安装Python这两种系统其实已经替我们安装好了Python，而无需像Windows那样的下载安装，而且系统中提供两种Python的版本； 终端中输入Python：进入低版本Python环境； 终端中输入Python3：进入新版本Python3环境； 如果想在终端关闭Python环境，使用contrl + d命令 四、Python的三种运行方式1.使用自带的交互式解释器：REPL(Read、Eval、Print、Loop)运行环境在安装了Python环境之后，可以直接在Python自带的交互式解释器中编写和运行Python代码。 步骤1：进入Python运行环境Windows系统需要搜索IDLE或者在windows终端界面中输入python，进入python的编译运行环境，而Linux和Mac OS系统：使用terminal命令进入终端，并输入python或者python3命令进入Python环境。 步骤2：编写和运行Python，以Mac为例 在Mac上的Python环境中编写代码如：print(“Hello World”)&#96;，按下回车即可执行代码，效果图如下： 2.命令行执行Python脚本步骤1：创建脚本文件 使用任意的文本编辑器，写入Python代码如：print(“Hello World”)，并将文件保存为demo.py，注意后缀一定要是py。 步骤2：系统终端中执行脚本文件 Windows系统中的Python环境是我们下载的指定版本的，所以可以直接进入终端中执行命令：“python + 文件名.py”。而对于Linux和Mac OS系统，有两种不同的执行方式。 使用低版本Python运行脚本文件：python + 文件名.py 使用新版本Python运行脚本文件：python3 + 文件名.py 需要注意： 一定要在python脚本的当前目录下操作。 另外，在系统终端关于python的其他命令如下： 3.集成开发环境PycharmPyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统。 PyCharm 功能 : 调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制…… PyCharm官方下载地址 PyCharm破解下载地址","categories":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/tags/Python/"}]},{"title":"Python学习(1)：入门与导学","slug":"Python学习01-入门与导学","date":"2018-08-01T15:39:33.000Z","updated":"2025-05-03T16:11:36.149Z","comments":true,"path":"2018/08/01/Python学习01-入门与导学/","permalink":"https://wuyubeichen.github.io/2018/08/01/Python%E5%AD%A6%E4%B9%A001-%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AF%BC%E5%AD%A6/","excerpt":"Life is simple ,I use Python. 代码：代码是现实世界事物在计算机世界中的映射编程：将现实世界中事物用计算机语言来描述","text":"Life is simple ,I use Python. 代码：代码是现实世界事物在计算机世界中的映射编程：将现实世界中事物用计算机语言来描述 最近在网上找了一些资料在学习Python，就想把每次的学习内容记录下来，这也是为了避免新学的东西容易遗忘。自己选择Python只有一个原因，那就是兴趣。作为一个iOS开发者，我也很好奇，传说中无所不能的Python到底是怎样的一种语言，使用Python是否也能做出一些有意思的事情，比如爬虫、机器学习等。下面的系列文章就是我的Python学习之旅。 一、了解PythonPython并不是一门新兴的语言，反而是诞生于上世纪90年代初的语言。 随着大数据与人工智能的流行，Python逐步的流行起来。Python就像一个技术的润滑剂，大多数互联网公司或多或少都会用到，可以在开发中解决大大小小的很多问题。根据TIOBE语言排行，Python的语言排行为第四位，热度上升很快，其流行程度可见一斑。 说明：本系列文章是本人的Python学习记录，在1-9篇都是在Python自带的解释器IDLE中编写和运行代码。在实际开发中专业的开发工具使用Pycharm，而做一些轻量化的开发使用的是Sublime text3或者Visual Studio Code 二、Python能做些什么Pyhotn几乎是万能的，相对于其他语言可以做的事情很多: 爬虫 大数据与数据分析(Spark) 自动化运维与自动化测试 Web开发：Flask，Diango 机器学习：Tensor Flow 胶水语言：混合其他如C++、Java等来编程。能够把用其他语言制作的各种模块(尤其是C/C++)很轻松的结合在一起。 三、Pthon特点 Python语法简洁，灵活，优雅，哲学，编写程序容易阅读; Python支持跨平台，可以运行在Windows、Linux以及MacOS; Python是面向对象的动态语言，既有动态脚本的特性，又有面向对象的特性，非常具有自己的特点; Python拥有极为强大而丰富的标准库与第三方库，比如电子邮件，比如图形GUI界面; Python易于上手，难于精通; Python的语言靠缩进区分代码块，不强制每句代码添加分号；也不需要花括号确定作用域; Python依靠缩进区分作用域，因此不支持代码压缩，常常以源代码形式的存在，开源性较好; 四、Python的缺点1.运行效率低Python主要缺点就是一个字：慢，其相对于C、C++、Java运行效率较慢。 这主要是因为Pyhton是一种解释性语言，对于当前主流的编程语言大致可分为两类：编译型语言(C、C++)和解释型语言(Javascript、Python)。 编译型语言：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如C、C++、Delphi等. [1] 解释型语言：解释性语言编写的程序不进行预先编译，以文本方式存储程序代码。在发布程序时，看起来省了道编译工序。但是，在运行程序的时候，解释性语言必须先解释再运行 运行效率与开发效率，鱼与熊掌不可兼得。类似汇编和C的运行效率很高，但是却不适合做web开发。对于语言的选择，适合的才是最好的。 2.不能加密python依靠缩进来编写代码，代码不能被压缩和混淆，所以这也注定了Python代码不能被加密的特性。 五、Python之禅Python的交互式编译器内嵌了几句话(输入import this)，被开发者称之为Pyhon之禅，包含了Python编程的一种大致思想和规范。 123451.Simple is better than complex简洁胜于复杂2.Now is better than never ，Although never is often better than right now做也许好过不做，但不加思索就动手还不如不做 六、Python学习的相关资料 廖雪峰Python3的官方网站 Python基本教程","categories":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/tags/Python/"}]},{"title":"搭建个人博客网站Github、Hexo与Next","slug":"搭建个人博客网站Github、Hexo与Next","date":"2018-02-13T06:34:57.000Z","updated":"2025-05-03T16:23:21.038Z","comments":true,"path":"2018/02/13/搭建个人博客网站Github、Hexo与Next/","permalink":"https://wuyubeichen.github.io/2018/02/13/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99Github%E3%80%81Hexo%E4%B8%8ENext/","excerpt":"温馨提示：由于本篇是后期整理的文章，一些在实际操作中遇到的错误可能会遗漏，但都是可以百度到的，当然，我也欢迎大家留言问题，以供完善记录。 效果展示：梧雨北辰的博客 主要内容： 准备工作 搭建博客(远程与本地) 发布博客","text":"温馨提示：由于本篇是后期整理的文章，一些在实际操作中遇到的错误可能会遗漏，但都是可以百度到的，当然，我也欢迎大家留言问题，以供完善记录。 效果展示：梧雨北辰的博客 主要内容： 准备工作 搭建博客(远程与本地) 发布博客 更换主题 博客网站美化 在不同电脑管理hexo博客 遇到问题 其他方案 一、准备工作1.了解HexoHexo是高效的静态站点生成框架，她基于Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的标签插件来快速的插入特定形式的内容，而且相对于其他框架，Hexo在速度上也有很大优势。 2. 搭建Node.js环境我们了解到Hexo基于Node.js的，那么我们搭建博客网站首先需要安装Node.js环境。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。下载地址：http://nodejs.cn/download测试安装：命令行使用node -v 、mpm -v，查看显示版本号即成功。 3.安装Hexo博客框架工具Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在控制台下使用如下命令： 1npm install hexo-cli -g 若报错，请尝试在命令前加上sudo 4.安装Git版本工具Git是目前世界上最流行的分布式版本控制系统，是的，没有之一。使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步。下载地址：https://git-scm.com/downloadsWindows系统需下载，Mac系统因为自带Git无需操作。测试安装：git - -version，查看显示版本号即成功。 5.注册Github账号gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件。注册地址：https://github.com注册流程：https://www.baidu.com，百度一下，你就知道啦。 注意：注册Github的时候一定要选择一个合适的名字，因为后来博客网站的域名也会用到这个名字。虽然Github用户名支持后期修改，但是还是会带来很多不必要的麻烦。github的使用在网上有很多教程，这里也就不再累述了。 二、开始搭建博客1.开启GitHub Pages服务搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://UserName.github.io的形式。注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很冗长。 点击Create Repository之后，随后选择Setting进入设置，找到Github Pages如下： 这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下： 此时若再查看setting，我们会看到开启GitHub Pages之后得到的域名如下： 现在，我们就可以使用https://UserName.github.io，访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然有点点丑，是吧)： 2.创建本地博客站点上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下： 1hexo init myHexoBlog //myHexoBlog是项目名 下面来测试本地博客站点，在本地博客根目录下使用控制台命令： 123hexo g //g是generetor的缩写，生成博客hexo s //s是server的缩写，启动服务 此时打开浏览器，输入 http://localhost:4000/，我们将会看到Hexo自带默认主题显示的博客样式如下(呃，是好看了那么一点点)： 3.同步Github,允许公共访问在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。首先找到我们的博客仓库，并拷贝仓库地址： 然后修改本地博客目录的配置：修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下： 最后执行控制台命令： 123npm install hexo-deployer-git —save //安装部署插件hexo d //部署到github 现在，我们再次访问链接：https://userName.github.io，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 三、发布博客激动人心的时候到了，终于可以发布自己的第一篇博客了。来尝试一下以下的步骤：在本地博客文件夹根目录输入： 12345hexo new &quot;我个人博客的第一篇博客，哈哈哈...&quot;hexo g //生成网页hexo d //部署到远端(github) 查看我们本地的博客文件夹，将会看到我们创建一个条新的博客文章： 现在打开我们的博客网站：http://UserName.github.io,会看到网页如下(显示可能会延时，不如先喝杯茶放松下吧)： 这就是我们发布博客的方法啦，当然这里是为了演示，真正做的时候我们要找到_posts里的博客原文，先编辑内容，然后再部署到github上。 四、更换主题现在我们已经看见个人博客的雏形了，但是现在的博客网页一点也不高大上。为了让它看起来更美观一些，我们可以为其更换主题（当然也可以自己在默认主题下自己编写美化博客界面，可是我还不太会前端，以后再突破吧）。这里以使用github上的next主题为例： 1.创建next文件夹切换到本地博客根目录下，在主题文件thems下创建一个新文件夹next存放即将下载的next主题 1mkdir themes/next 2.下载主题Next1curl -s [https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest](https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest) | grep tarball_url | cut -d &#x27;&quot;&#x27; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1 此步骤可参考：https://github.com/iissnan/hexo-theme-next 下载成之后我们会看到next的主题已经存在thems里了如下： 3.修改博客配置文件，更换主题配置修改博客根目录(不是next主题)下的_config.yml文件，搜索theme字段，并将其值修改为next。 然后在控制台下输入如下命令： 12345hexo clean //清理缓存hexo g //重新生成博客代码hexo d //部署到本地 再次打开我们的博客网站：https://UserName.github.io，将会看到更换主题后的博客网页如下： 五、博客网站美化终于我们的博客也算像点样子了，如果你和我一样是个完美主义者，那我们来继续美化它吧。这需要我们对博客中的各种配置进行修改。 首先说明一下：在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 1.站点配置：在本地的博客根目录下找到_config.yml，用编辑器打开，如下： 这里可以修改博客网站的标题、描述，语言等属性，上面更换主题也是在这个文件中修改的。大家可以在这里稍作设置。 2.主题设置关于博客主题的配置这块本来想着自己写下呢，却发现官方文档更加详尽。大家可以参考Next文档来学习。文档地址：http://theme-next.iissnan.com/getting-started.html其他参考：hexo的next主题个性化教程打造个性超赞博客Hexo+Next+githubPages的超深度优化 3.更多主题选择next只是众多Hexo主题的一种，还有很多优秀的主题可供我们选择，参考以上的更换及配置方法我们就可以进一步美化我们的个人博客网站了。更多主题选择：https://github.com/hexojs/hexo/wiki/Themes 六、在不同电脑管理hexo博客其实，这也是我在使用Hexo搭建博客遇到的一个问题，如果我们检查自己博客在Github上的文件就会发现，github仓库里的文件和我们本地博客站点的文件夹是不同的，确切来说是少了很多内容。如果我们想在不同的电脑上管理自己的博客，就必须有源文件存在远端供我们随时下载、然后修改后重新部署到远端。 我们要理解这样一个过程：hexo -d是把本地博客源文件生成的静态网页文件同步到github上，实现部署。但是博客网站的源文件仍需要我们自己保存。这里主要有两种思路可以选择： 1.在github存放我们博客静态网页文件的仓库里另建分支brach，单独用于存放源文件。2.将本地博客文件存放在码云上。 这些都是关于git的操作，所以这里不用细说了。单对于这两种方法来说，我更倾向于第二种。因为毕竟这些都是我们搭建个人博客的源文件，将来还要在网站上发表文章，很多数据都在这里。使用码云我们可以创建私有仓库，将这些源文件私有存放更好一些，而且源文件和静态博客网页文件分开存放也避免使用分支频繁切换。 七、遇到问题 ####1.修改了配置，网站没有变化 这种情况，大多因为修改后配置后我们直接部署，没有执行hexo clean。 ####2.代码无法高亮显示 在Hexo的next主题下，我们使用markDown编辑文章，如果代码无法高亮，这有可能是我们没有在标记语言后添加语言类型，我需要在添加代码片段的时候使用如下的样式： 类似其他语言用：java、python… 八、其他方案 还有一种搭建博客网站的方案是Jekyll，还没有细致研究呢，先记在这里为以后扩展思路。 终于写完了，祝新的一年越来越好，加油！- 2018-02-13","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://wuyubeichen.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://wuyubeichen.github.io/tags/Hexo/"}]},{"title":"Swift学习10-协议","slug":"Swift学习10-协议","date":"2017-08-10T10:10:47.000Z","updated":"2025-05-03T16:26:03.882Z","comments":true,"path":"2017/08/10/Swift学习10-协议/","permalink":"https://wuyubeichen.github.io/2017/08/10/Swift%E5%AD%A6%E4%B9%A010-%E5%8D%8F%E8%AE%AE/","excerpt":"协议：是定义一些规范(属性、功能方法)，然后由类、结构体或者枚举遵循并实现这些规范，这一过程被称为遵循了协议； 主要内容： 协议的基本语法 定义协议与实现协议 协议与构造器 协议作为类型","text":"协议：是定义一些规范(属性、功能方法)，然后由类、结构体或者枚举遵循并实现这些规范，这一过程被称为遵循了协议； 主要内容： 协议的基本语法 定义协议与实现协议 协议与构造器 协议作为类型 协议实现委托代理模式 通过扩展遵循协议 协议类型的集合 协议继承协议 类类型专属协议 协议合成 检查协议的一致性 协议的可选性 协议扩展 一、协议的基本语法下面是协议的一些基本语法： 1.定义一个协议123456protocol SomeProtocol &#123; //这里是协议的定义部分&#125;protocol AnotherProtocol&#123; //这里是协议的定义部分&#125; 2.自定义类型遵循协议使用冒号，遵循多个协议时，各协议间使用逗号分隔123struct SomeStructure: SomeProtocol, AnotherProtocol &#123; //这里是结构体的定义部分&#125; 3.拥有父类的类在遵循协议时，需要将父类名放在协议名之前，以逗号分隔123class SomeClass: SomeSuperClass, SomeProtocol, AnotherProtocol &#123; //这里是类的定义部分&#125; 二、定义协议与实现协议协议可以要求遵循协议的类型提供特定的属性、方法，构造器。如果协议中的属性和方法没有实现，就会报错；除此之外，我们还需要注意一些具体的使用规则如下： 属性要求： 协议可以定义实例属性和类型属性(使用static); 协议不指定属性是存储属性还是计算型属性，只指定属性名称和类型以及读写性; 协议指定属性的读取类型，使用的get和set，中间不能使用逗号； 协议总是使用var关键字来声明变量属性; 不能给协议属性设置默认值，因为默认值被看做是一种实现; 方法要求： 协议可以定义实例方法和类方法(使用static); 协议定义函数时不能添加函数的实现，同时，传入的参数也不能使用默认参数； 如果协议定义的实例方法会改变实例本身，需要在定义的方法名前使用mutating；这使得结构体和枚举能够遵循此协议并满足此方法要求。 下面具体演示一个协议的使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445protocol PersonProtocol&#123; //1.定义属性 static var personCount: Int &#123;get&#125; var name:String&#123; get set &#125; var nickName:String&#123;get set&#125; //要求可读可写，则该属性不能是常量属性或者只读的计算型属性 var birthPlace:String&#123;get&#125; //只要求可读，若代码需要，实现时也是可写的 var age:Int&#123;get&#125; //2.定义函数 static func play() func eat(food:String) //func fed(food:string = &quot;defaultfood”) 错误，不能使用默认参数 mutating func changeNickName(newName:String)&#125;struct Student:PersonProtocol&#123; static var personCount = 0 //类属性 var name: String = &quot;&quot; var nickName: String = &quot;&quot; //这种形式的声明就代表可读可写 let birthPlace: String = &quot;beijing&quot; //将只读属性设置为let，在合适位置给其设置默认值就好了 var age:Int = 10 //其实，只读类型的属性也可以设置为var,这相当于是对其进行扩展，不仅遵循了原来的get，还增加了set static func play() &#123; //类方法 &#125; func eat(food: String) &#123; //普通实例方法 &#125; mutating func changeNickName(newName: String) &#123; //实例方法中修改了实例属性 self.nickName = newName &#125;&#125;//测试代码：var student:Student = Student()student.age = 18var stu:PersonProtocol = student //这里协议也当做了一种类型来使用，但是具体的实现还是是Dog完成的//stu.age = 10 //这里报错，因为协议中的age是只读的 注意：实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。 三、协议与构造器这里主要总结协议在定义构造器时候的一些要求，主要有如下几个方面： 协议中可设置指定或者便利构造器,实现时都需要添加required修饰符,因为这样可以确保所有子类也必须提供此构造器，从而符合协议，但是如果为final类，就不需要； 如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 required 和 override 修饰符； 协议中可定义可失败构造器(init?)、非可失败构造器(init)、隐式解包可失败构造器(init!)； 下面是协议与构造器使用的相关示例： 123456789101112131415protocol Protocol &#123; init()&#125;class SomeSuperClass &#123; init() &#123; // 这里是构造器的实现部分 &#125;&#125;class SomeSubClass: SomeSuperClass, SomeProtocol &#123; // 因为遵循协议，需要加上 required // 因为继承自父类，需要加上 override required override init() &#123; // 这里是构造器的实现部分 &#125;&#125; 四、协议作为类型协议虽本身并未实现任何功能，但是仍然可以像其他普通类型一样使用,如Int、Double等。协议作为类型使用的场景如下： 作为函数、方法或构造器中的参数类型或返回值类型 作为常量、变量或属性的类型 作为数组、字典或其他容器中的元素类型 下面演示协议类型的使用： 123456789101112131415161718192021222324252627282930313233343536373839//协议：定义了生成随机数方法protocol RandomNumberGenerator &#123; func random() -&gt; Double&#125;//实现了RandomNumberGenerator协议的类class LinearCongruentialGenerator: RandomNumberGenerator &#123; var lastRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random() -&gt; Double &#123; //使用truncatingRemainder方法进行浮点数取余 lastRandom = (lastRandom * a + c).truncatingRemainder(dividingBy: m) return lastRandom / m &#125;&#125;//Dice的generator属性，其类型是RandomNumberGenerator协议类型class Dice &#123; let sides: Int let generator: RandomNumberGenerator //协议作为属性 //协议作为参数类型 init(sides: Int, generator: RandomNumberGenerator) &#123; self.sides = sides self.generator = generator &#125; func roll() -&gt; Int &#123; return Int(generator.random() * Double(sides)) + 1 &#125;&#125;var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())for _ in 1...5 &#123; print(&quot;Random dice roll is \\(d6.roll())&quot;)&#125;//Random dice roll is 3//Random dice roll is 5//Random dice roll is 4//Random dice roll is 5//Random dice roll is 4 五、协议实现委托代理模式委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。 委托模式： 作用：用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型； 原理：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能； 下面例子演示了通过协议实现代理模式： 1234567891011121314151617181920212223//播放音乐的协议protocol PlayMusicTools&#123; func playMusic();&#125;//实现协议的类class QQMusisApp:PlayMusicTools&#123; func playMusic() &#123; print(“播放一首美妙的音乐&quot;) &#125;&#125;class Person&#123; var delegate:PlayMusicTools? func listenMusic()&#123; self.delegate?.playMusic() &#125;&#125;//人想听音乐但是又不能自己播放，就调用了代理的方法let person:Person = Person()person.delegate = QQMusisApp()person.listenMusic() 六、通过扩展遵循协议我们知道，扩展可以为已有类型添加属性、方法、下标以及构造器。同样道理，我们也可以通过扩展为已有类型实现需要遵循的协议，通过这种方法与在原始定义中遵循并实现协议效果完全相同。 6.1.通过扩展实现协议1234567891011121314//协议：定义一个可以打印UIView属性fame的方法protocol ViewProperty&#123; func printFrame()&#125;//通过扩展为UIView实现了ViewProperty协议extension UIView:ViewProperty&#123; func printFrame() &#123; print(self.frame) &#125;&#125;let view = UIView(frame: CGRect(x: 0, y: 0, width: 100, height: 100))view.printFrame() 6.2.已经符合协议的类如果一个类型已经符合了某个协议的所有要求，却还没有声明遵循这个协议，那么可以通过空扩展来遵循协议。 12345678910class CustomObject&#123; func printFrame() &#123; print(&quot;this is not a view，cant print frame&quot;) &#125;&#125;//空扩展表示遵循协议extension CustomObject:ViewProperty&#123;&#125;//遵循了协议之后，就可以使用协议作为类型let customOject:ViewProperty = CustomObject()customOject.printFrame() 七、协议类型的集合协议类型可以在数组或者字典这样的集合中使用；如下，等号左边的数组表示遵循了ViewProperty协议的对象构成的数组。 1234567let things:[ViewProperty] = [view,customOject]for thing in things&#123; thing.printFrame()&#125;//打印结果：//(0.0, 0.0, 100.0, 100.0)//this is not a view，cant print frame 八、协议继承协议协议继承协议具有以下特点： 协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。 协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔： 所有遵循新协议的类型，也同时满足新协议所继承的父协议 协议继承协议的格式如下： 123protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123; // 这里是协议的定义部分&#125; 九、类类型专属协议协议的继承列表中，通过添加 class 关键字来限制协议只能被类类型遵循，而结构体或枚举不能遵循该协议。class 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前。 1234protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123; // 这里是类类型专属协议的定义部分 //class 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前&#125; 十、协议合成有时候需要同时遵循多个协议，你可以将多个协议采用SomeProtocol &amp; AnotherProtocol这样的格式进行组合，称为协议合成(protocol composition)；你可以罗列任意多个你想要遵循的协议，以与符号(&amp;)分隔。 下面的例子中，将 Named 和 Aged 两个协议按照上述语法组合成一个协议，作为函数参数的类型： 123456789101112131415161718192021protocol Named &#123; var name: String &#123; get &#125;&#125;protocol Aged &#123; var age: Int &#123; get &#125;&#125;//Person遵循两个协议struct Person: Named, Aged &#123; var name: String var age: Int&#125;//函数参数celebrator的类型为 Name &amp; Aged；//这意味着它不关心参数的具体类型，只要参数符合这两个协议即可；func wishHappyBirthday(to celebrator: Named &amp; Aged) &#123; print(&quot;Happy birthday, \\(celebrator.name), you&#x27;re \\(celebrator.age)!&quot;)&#125;let birthdayPerson = Person(name: &quot;Malcolm&quot;, age: 21)wishHappyBirthday(to: birthdayPerson) //打印 “Happy birthday Malcolm - you&#x27;re 21!” 注意：协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个只在局部作用域有效的临时协议中 十一、检查协议的一致性类型转换中描述的is和as操作符同样可以用来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同： is：用来检查实例是否符合某个协议，若符合则返回 true，否则返回 false。 as?： 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil。 as!：将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。 1234567891011121314151617181920212223242526272829303132333435363738394041//定义协议：定义一个Double类型的可读属性areaprotocol HasArea &#123; var area: Double &#123; get &#125;&#125;//Circle类和Country类遵循协议HasAreaclass Circle: HasArea &#123; let pi = 3.1415927 var radius: Double var area: Double &#123; return pi * radius * radius &#125; //计算型 init(radius: Double) &#123; self.radius = radius &#125;&#125;class Country: HasArea &#123; var area: Double //存储型 init(area: Double) &#123; self.area = area &#125;&#125;//Animal未遵循协议class Animal &#123; var legs: Int init(legs: Int) &#123; self.legs = legs &#125;&#125;let objects: [AnyObject] = [ Circle(radius: 2.0), Country(area: 243_610), Animal(legs: 4)]//迭代测试，并检测协议for object in objects &#123; if let objectWithArea = object as? HasArea &#123; print(&quot;Area is \\(objectWithArea.area)&quot;) &#125; else &#123; print(&quot;Something that doesn&#x27;t have an area&quot;) &#125;&#125;// Area is 12.5663708// Area is 243610.0// Something that doesn&#x27;t have an area” 十二、协议的可选性协议可以定义可选要求，即遵循协议的类型可以选择是否实现这些要求。 在协议中使用optional关键字作为前缀来定义可选要求。 可选要求用在你需要和Objective-C打交道的代码中。协议和可选要求都必须带上@objc属性。 标记@objc特性的协议只能被继承自Objective-C类的类或者@objc类遵循，其他类以及结构体和枚举均不能遵循这种协议； 协议中的可选要求可通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求； 下面的例子定义了一个名为Counter的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由CounterDataSource协议定义，包含两个可选要求： 12345678910111213141516171819202122232425262728293031323334353637383940//1.协议CounterDataSource包含两个可选要求@objc protocol CounterDataSource &#123; @objc optional func incrementForCount(count: Int) -&gt; Int @objc optional var fixedIncrement: Int &#123; get &#125;&#125;//2.Counter类含有CounterDataSource?类型的可选属性dataSourceclass Counter &#123; var count = 0 var dataSource: CounterDataSource? func increment() &#123; if let amount = dataSource?.incrementForCount?(count: count) &#123; count += amount &#125; else if let amount = dataSource?.fixedIncrement &#123; //通过可选链调用，每次使用的是fixedIncrement的3 count += amount &#125; &#125;&#125;//3.ThreeSource类遵循了CounterDataSource协议//它实现了可选属性fixedIncrement，而并未实现incrementForCount方法class ThreeSource: NSObject, CounterDataSource &#123; let fixedIncrement = 3&#125;//4.使用ThreeSource实例作为Counter实例的数据源对象var counter = Counter()counter.dataSource = ThreeSource()for _ in 1...4 &#123; counter.increment() print(counter.count)&#125;//测试结果：//3//6//9//12 注意：严格来讲，CounterDataSource协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要求，尽管技术上允许这样做，不过最好不要这样写； 十三、协议扩展协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。 下面的代码演示了协议扩展的用法： 123456789101112131415161718192021222324252627282930//协议：定义random函数生成随机数方法protocol RandomNumProtocol &#123; func random() -&gt; Double&#125;//扩展RandomNumProtocol协议，增加了randomBool方法//注意：通过协议扩展，所有遵循协议的类型都能自动获得这个扩展所增加的方法实现，无需任何额外修改extension RandomNumProtocol &#123; func randomBool() -&gt; Bool &#123; return random() &gt; 0.5 &#125;&#125;//遵循协议的类：一个实现了RandomNumProtocol协议的类//RandomNum类只实现了协议方法random()，但是同样可以使用协议扩展里的方法randomBool()class RandomNum: RandomNumProtocol &#123; var lastRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random() -&gt; Double &#123; //使用truncatingRemainder方法进行浮点数取余 lastRandom = (lastRandom * a + c).truncatingRemainder(dividingBy: m) return lastRandom / m &#125;&#125;//测试代码：let generator = RandomNum()print(&quot;Here&#x27;s a random number: \\(generator.random())&quot;)//打印：Here&#x27;s a random number: 0.37464991998171print(&quot;And here&#x27;s a random Boolean: \\(generator.randomBool())&quot;)//打印：And here&#x27;s a random Boolean: true 13.1.提供默认实现可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。但是，如果遵循协议的类型也为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。 注意：通过协议扩展为协议要求提供的默认实现，这和可选的协议要求不同；虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。 123456789101112131415161718192021222324//协议：一个宠物协议，定义发出声音的方法makeSoundprotocol PetProtocol&#123; func makeSound()&#125;//扩展协议：提供默认方法实现extension PetProtocol&#123; func makeSound()&#123; print(&quot;aaaaaa。。。。&quot;) &#125;&#125;class Cat:PetProtocol&#123; //因为有协议扩展，已经提供了默认的方法实现；所以这里只遵循了协议&#125;class Dog:PetProtocol&#123; func makeSound() &#123; print(&quot;汪汪汪。。。。&quot;) &#125;&#125;//测试代码：let cat = Cat();cat.makeSound(); //打印：aaaaaa。。。。let dog = Dog();dog.makeSound() //打印：汪汪汪。。。。 13.2.为协议扩展添加限制条件在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 where子句来描述 例如:你可以扩展Collection协议，通过限制集合元素遵循Equatable 协议， 作为标准库的一部分，你可以使用&#x3D;&#x3D;和!&#x3D;操作符来检查两个元素的等价性和非等价性； 123456789101112131415extension Collection where Element: Equatable &#123; func allEqual() -&gt; Bool &#123; for element in self &#123; if element != self.first &#123; return false &#125; &#125; return true &#125;&#125;//如果集合中的所有元素都一致，allEqual()方法才返回 truelet equalNumbers = [100, 100, 100, 100, 100]print(equalNumbers.allEqual()) //打印 &quot;true&quot;let differentNumbers = [100, 100, 200, 100, 200]print(differentNumbers.allEqual()) //打印 &quot;false&quot; 注意：如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wuyubeichen.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/tags/Swift/"}]},{"title":"Swift学习09-扩展","slug":"Swift学习09-扩展","date":"2017-08-09T10:11:32.000Z","updated":"2025-05-03T16:12:36.856Z","comments":true,"path":"2017/08/09/Swift学习09-扩展/","permalink":"https://wuyubeichen.github.io/2017/08/09/Swift%E5%AD%A6%E4%B9%A009-%E6%89%A9%E5%B1%95/","excerpt":"扩展：就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力(即逆向建模 ) 主要内容： 理解扩展 扩展的基本使用 嵌套类型 扩展系统类库","text":"扩展：就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力(即逆向建模 ) 主要内容： 理解扩展 扩展的基本使用 嵌套类型 扩展系统类库 一、理解扩展1.1.扩展特点： 扩展和 Objective-C 中的分类类似，但与之不同的是，Swift 的扩展没有名字； 扩展可以为一个类型添加新的功能，但是不能重写已有的功能； 1.2.扩展功能： 添加计算型实例属性和计算型类型属性。 定义实例方法和类型方法 提供新便利构造器和便利析构器 定义下标 定义和使用新的嵌套类型 使一个已有类型符合某个协议” 1.3.使用注意： 不可以添加存储属性，也不可以为已有属性添加属性观察器 扩展中不能为类添加新的指定构造器，因为指定构造器和析构器必须由原始的类来实现 扩展可以为一个类型添加新的功能，但是不能重写已有的功能。 通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。 二、扩展的基本使用定义如下的Point 、Size、Rectangle，并对其进行扩展。 123456789101112131415161718struct Point&#123; var x = 0.0 var y = 0.0&#125;struct Size&#123; var width = 0.0 var height = 0.0&#125;class Rectangle &#123; var origin:Point = Point() var size = Size() init (origin:Point, size: Size)&#123; self.origin = origin self.size = size &#125;&#125; 2.1.扩展属性扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器 123456789101112131415161718192021extension Rectangle&#123; //注意：扩展不能扩展存储型属性 //var center:Point = Point() //报错 //只能扩展计算型属性 var center: Point &#123; get &#123; let center_x = origin.x + size.width/2 let center_y = origin.y + size.height/2 return Point(x: center_x, y: center_y) &#125; set&#123; origin.x = newValue.x - size.width/2 origin.y = newValue.y - size.height/2 &#125; &#125;&#125;let rect1 = Rectangle(origin: Point(x:0,y:0), size: Size(width: 100, height: 100))print(rect1.center) //Point(x: 50.0, y: 50.0)rect1.center = Point(x: 0, y: 0)print(rect1.center) //Point(x: 0.0, y: 0.0) 2.2.扩展方法扩展可以为已有类型添加新的实例方法和类型方法。 123456789101112extension Rectangle&#123; //注意：这里直接修改了属性，如果是结构体Struct，不能直接这样修改 //func之前需要使用 mutating func translate(x:Double , y:Double)&#123; self.origin.x += x self.origin.y += y &#125;&#125;let rect2 = Rectangle(origin: Point(x:0,y:0), size: Size(width: 100, height: 100))rect2.translate(x: 100, y: 100)print(rect2.center) //Point(x: 150.0, y: 150.0) 2.3.扩展构造器扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现提供. 1234567891011extension Rectangle&#123; //注意：在扩展中添加了构造函数，必须是便利构造函数，其中调用指定构造函数 convenience init(center:Point, size:Size) &#123; let origin_x = center.x - size.width/2 let origin_y = center.y - size.height/2 //便利构造函数必须调用指定构造函数 self.init(origin:Point(x: origin_x, y: origin_y),size:size) &#125;&#125;let rect3 = Rectangle(center: Point(x:200, y:200), size: Size(width: 100, height: 100)) **注意1：**如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。 **注意2：**如果你使用扩展为一个值类型添加构造器，同时该值类型的原始实现中未定义任何定制的构造器且所有存储属性提供了默认值，那么我们就可以在扩展中的构造器里调用默认构造器和逐一成员构造器。 2.4.扩展下标扩展可以为已有类型添加新下标。下面的例子为Swift内建类型Int添加了一个整型下标。该下标 [n] 返回十进制数字从右向左数的第n个数字： 12345678910111213extension Int &#123; subscript(digitIndex: Int) -&gt; Int &#123; var decimalBase = 1 for _ in 0..&lt;digitIndex &#123; decimalBase *= 10 &#125; return (self / decimalBase) % 10 &#125;&#125; //测试代码：print(746381295[3]) //1print(746381295[6]) //6 三、嵌套类型扩展可以为已有的类、结构体和枚举添加新的嵌套类型。在下面的示例中，Rectangle中就嵌套一个枚举类型，用以获取矩形的各个定点坐标。 1234567891011121314151617181920212223242526272829303132333435363738extension Rectangle&#123; enum Vertex:Int &#123; case TopLeft case TopRight case BottomLeft case BottomRight &#125; //扩展出一个方法来获取各个顶点坐标 func pointAtVertex(v:Vertex) -&gt; Point&#123; switch v &#123; case .TopLeft: return origin case .TopRight: return Point(x: origin.x + size.width, y: origin.y) case .BottomLeft: return Point(x: origin.x, y: origin.y + size.height) case .BottomRight: return Point(x: origin.x + size.width, y: origin.y + size.height) &#125; &#125; //扩展下标 subscript (index:Int) -&gt;Point&#123; assert(index &gt;= 0 &amp;&amp; index&lt;4,&quot;out of range&quot;) //修改枚举的原始值是Int类型，而这里🈶使用rowValue方法构建了枚举型 return pointAtVertex(v: Vertex(rawValue: index)!) //已经使用了断言，这里使用强制解包 &#125;&#125;//测试代码：let rect4 = Rectangle(origin: Point(x:0,y:0), size: Size(width: 100, height: 100))let point1 = rect4.pointAtVertex(v: .TopRight)print(point1) //Point(x: 100.0, y: 0.0)let point2 = rect4.pointAtVertex(v: Rectangle.Vertex.BottomRight)print(point2) //Point(x: 100.0, y: 0.0)let point3 = rect4[2]print(point3) //Po 四、扩展系统类库4.1.扩展Double扩展Double，为其添加计算型属性，提供与距离单位协作的基本支持。 12345678910111213extension Double &#123; var km: Double &#123; return self * 1_000.0 &#125; var m : Double &#123; return self &#125; var cm: Double &#123; return self / 100.0 &#125; var mm: Double &#123; return self / 1_000.0 &#125; var ft: Double &#123; return self / 3.28084 &#125;&#125; //测试代码：let distance1 = 25.4.mmprint(&quot;distance1 is \\(distance1) meters&quot;) //distance1 is 0.0254 meterslet distance2 = 42.mm + 1.kmprint(&quot;disatance2 is \\( distance2) meters&quot;) //disatance2 is 1000.042 meters 4.2.扩展Int类扩展Int，为其添加平方、立方、范围判断等方法。 1234567891011121314151617181920212223242526272829303132extension Int&#123; //平方运算 var square:Int&#123; return self * self &#125; //立方运算 var cube:Int&#123; return self * self * self &#125; //判断整型是否在某个范围内 func inRange(closedLeft:Int, opendRight:Int) -&gt; Bool&#123; return self &gt;= closedLeft &amp;&amp; self &lt; opendRight &#125; //通过传入一个闭包参数，简单的实现循环操作 func repetitions(task: () -&gt; Void)&#123; for _ in 0...10&#123; //执行闭包 task() &#125; &#125;&#125; //测试代码：var tempNum = 10;tempNum.square() //100tempNum.inRange(closedLeft: 10, opendRight: 100) //falsetempNum.repetitions &#123; print(tempNum)&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wuyubeichen.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/tags/Swift/"}]},{"title":"Swift学习08-泛型","slug":"Swift学习08-泛型","date":"2017-08-08T10:01:32.000Z","updated":"2025-05-03T16:25:56.953Z","comments":true,"path":"2017/08/08/Swift学习08-泛型/","permalink":"https://wuyubeichen.github.io/2017/08/08/Swift%E5%AD%A6%E4%B9%A008-%E6%B3%9B%E5%9E%8B/","excerpt":"Swift泛型：允许根据自定义的需求，编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图； 主要内容： 泛型解决的问题 泛型函数 泛型类型","text":"Swift泛型：允许根据自定义的需求，编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图； 主要内容： 泛型解决的问题 泛型函数 泛型类型 扩展一个泛型类型 泛型的类型约束 关联类型 一、泛型解决的问题Swift泛型代码让你能够根据自定义的需求，编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图。这种说法很模糊，下面我们结合一个示例来说明泛型的作用。 需求描述：使用函数来交换两个变量的值 123456789//互换两个整型func swapTwoInt(a:inout Int , b:inout Int)&#123; (a, b) = (b, a)&#125;//互换两个Doublefunc swapTwoDouble(a:inout Double, b:inout Double)&#123; (a,b) = (b,a)&#125; 代码分析： swapTwoInt与swapTwoDouble两个函数功能相同，唯一的区别就是传入的变量类型不同。这样的代码看起来重复又累赘。在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。 二、泛型函数泛型函数可以适用于任何类型，下面的swapTwoValues(_:_:)函数是上面两个函数的泛型版本,可以交换任意类型的两个变量。 尖括号里声明一种通用类型T，参数列表里可以使用这种类型名表示通用类型 123456789101112131415func SwapTwoThing&lt;T&gt;(a:inout T, b:inout T)&#123; (a, b) = (b, a)&#125;var a = 100var b = 200swapTwoInt(a: &amp;a , b: &amp;b)a //200b //100var string1 = &quot;hello&quot;var string2 = &quot;world&quot;SwapTwoThing(a: &amp;string1, b: &amp;string2)string1 //worldstring2 //hello 总结泛型函数的使用： 使用了占位类型名(T)，来替换实际类型名(Int，Double)； 占位类型符并不指定T必须是什么类型，但是却限制了参数a和b必须是同一种类型T； 只有SwapTwoValues&lt;T&gt;(_:_)函数在调用时，才能根据所传入的实际类型决定T所代表的类型； T只是一个符号，可以使用大写字母开头的驼峰命名法（例如T和MyTypeParameter)来为类型参数命名，以表明它们是占位类型，而不是一个值。 三、泛型类型3.1.系统类型使用到的泛型事实上，泛型类型的使用贯穿了Swift语言。例如，Swift的Array和Dictionary都是泛型集合。你可以创建一个Int数组，也可创建一个String数组。 123let arr = Array&lt;Int&gt;()let dict = Dictionary&lt;String,Int&gt;()let set = Set&lt;Float&gt;() 3.2.自定义泛型类型：实现一个栈结构体除了泛型函数，Swift还允许你定义泛型类型；这些自定义类、结构体和枚举可以适用于任何类型，类似于Array和 Dictionary。下面的示例就是创建一个具有栈功能的结构体，适用于各种类型。 123456789101112131415161718192021222324struct Stack&lt;Element&gt;&#123; //存放栈中变量的数组 var items = Array&lt;Element&gt;() //入栈：向栈中添加一个新元素 mutating func push(item:Element)&#123; items.append(item) &#125; //出栈：删除栈顶元素,并返回此元素 mutating func pop() -&gt;Element?&#123; return items.removeLast() &#125;&#125;var stack = Stack&lt;Int&gt;()stack.push(item: 11)stack.push(item: 22)stack.pop() //22var stack1 = Stack&lt;String&gt;()stack1.push(item:&quot;aaa&quot;)stack1.push(item:&quot;bbb&quot;)stack1.pop() //“bbb&quot; 3.3.自定义泛型类型：多个占位符自定义泛型类型可以设置多个类型占位符，下面就是自定义了一个泛型类型Pair，它具有两个占位类型符。 12345678struct Pair&lt;T1, T2&gt;&#123; var t1:T1 var t2:T2&#125;var pair1 = Pair(t1: &quot;hello&quot;, t2: &quot;hi&quot;)print(pair1) //Pair&lt;String, String&gt;(t1: &quot;hello&quot;, t2: &quot;hi&quot;)var pair2:Pair&lt;String, Int&gt; = Pair(t1:&quot;hello&quot;,t2: 123)print(pair2) //Pair&lt;String, Int&gt;(t1: &quot;hello&quot;, t2: 123) 四、扩展一个泛型类型扩展一个泛型类型，可以直接使用原始类型定义中声明的类型参数列表，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。 比如，我们现在扩展泛型类型Stack，为其添加计算型属性topItem，用于获取栈顶元素，代码示例如下： 12345678910111213extension Stack &#123; //返回当前栈顶元素而不会将其从栈中移除 var topItem: Element? &#123; return items.isEmpty ? nil : items[items.count - 1] &#125;&#125;var stack3 = Stack&lt;Int&gt;()stack3.push(item:1)stack3.push(item:2)stack3.push(item: 3)if let topItem = stack3.topItem&#123; print(&quot;栈顶元素:\\(topItem)&quot;) //栈顶元素:3&#125; 注意：扩展中的占位类型符需要与原始类保持一致，所以这里用的还是Element。 五、泛型的类型约束swapTwoValues(_:_:)函数和Stack类型可以作用于任何类型。但如果可以为泛型函数和泛型类型的类型添加一个特定的类型约束，将会是非常有用的。 通常情况下，我们设置泛型类型约束的时候，会指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。 5.1.类型约束语法对泛型函数添加类型约束的基本语法如下所示(作用于泛型类型时的语法与之相同)。 1234//在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123; // 这里是泛型函数的函数体部分&#125; 5.2.泛型类型约束实践下面的泛型函数用于查找数组中某个元素的索引位置；但由于for循环里用到了对象比较”&#x3D;&#x3D;”，要确保所有的类型都适用，所以在泛型函数的中添加了类型约束，使用此泛型函数的参数必须遵循Equatable协议。 12345678910func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array:[T]) -&gt; Int? &#123; for (index, value) in array.enumerated() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125;let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25]) //nillet stringIndex = findIndex(of: &quot;Andrea&quot;, in: [&quot;Mike&quot;, &quot;Malcolm&quot;, &quot;Andrea&quot;]) //2 注意：Swift标准库定义了Equatable协议，该协议要求任何遵循该协议的类型必须实现等式符（&#x3D;&#x3D;）及不等符(!&#x3D;)。从而能对该类型的任意两个值进行比较。所有的Swift标准类型自动支持 Equatable 协议 六、关联类型关联类型是在为协议中的某个类型提供一个占位名，其所代表的实际类型会在协议被采纳时才会被指定。这里涉及到两个关键字，其作用就是给一个类型起一个别名，首先来说明一下： associatedtype：协议声明中使用 typealias：协议实现中使用 下面通过一个示例来理解关联类型的作用：定义一个可称重的协议，其中使用了泛型关联类型。这种方式可以更大程度的使用协议，具体实现协议的时候再决定类型。 12345678910111213141516171819202122232425262728protocol WeightCaclulable&#123; //associatedtype设置别名，即关联类型 associatedtype WeightType var weight:WeightType&#123;get&#125; //返回重量属性，其类型是WeightType&#125;//iphone7:手机较轻，表示重量时会有小数点，所以使用Double描述class Iphone7:WeightCaclulable&#123; //实现的时候用的是typealias typealias WeightType = Double var weight: Double &#123; return 0.114 &#125;&#125;//Ship:轮船较重,表示重量可以忽略小数，所以使用Int描述class Ship:WeightCaclulable&#123; typealias WeightType = Int var weight: WeightType init(weight:WeightType) &#123; self.weight = weight &#125;&#125;let iphone7 = Iphone7()print(iphone7.weight) //0.114let ship = Ship(weight: 100000)print(ship.weight) //100000 6.1.关联类型添加约束协议中存在关联类型，我们也可以为其添加约束，下面是一个Container协议，我们设置其关联类型Item遵循了协议Equatable，具体代码如下： 1234567protocol Container &#123; associatedtype Item: Equatable mutating func append(_ item: Item) var count: Int &#123; get &#125; subscript(i: Int) -&gt; Item &#123; get &#125;&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wuyubeichen.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/tags/Swift/"}]},{"title":"Swift学习07-可选型","slug":"Swift学习07-可选型","date":"2017-08-07T10:14:55.000Z","updated":"2025-05-03T16:25:52.651Z","comments":true,"path":"2017/08/07/Swift学习07-可选型/","permalink":"https://wuyubeichen.github.io/2017/08/07/Swift%E5%AD%A6%E4%B9%A007-%E5%8F%AF%E9%80%89%E5%9E%8B/","excerpt":"顾名思义，可选类型表示一个变量可能有值，也可能没有值（nil），但是它的用法却与OC中的nil完全不同 主要内容： 可选型使用要点 可选型解包 可选链 Option chaining","text":"顾名思义，可选类型表示一个变量可能有值，也可能没有值（nil），但是它的用法却与OC中的nil完全不同 主要内容： 可选型使用要点 可选型解包 可选链 Option chaining 空合并运算符nil coalesce 隐式可选型 可选型使用的其他示例 最后小结 一、可选型使用要点 可选类型类似于OC指针的nil值，但是OC中的nil只对类有用，而可选择型中nil对所有类型都可用，更安全 可选型的声明的方式是“数据类型+问号”。如：var errorCode :Int? = 404 当要使用一个可选类型的变量时，要在后面加感叹号“!”或者“?”。 不能把一个可选型便量赋值给非可选型的变量, 如：let tempValue = nil，这样会报错； 可选型数据一般都是可变的，所以可选型的数据也通常是变量； 声明一个可选型的时候，必须是添加？,swift不能隐式的自动推断可选型； swift不能用同类中的一个特殊值代表无或者没有，在Swift中，nil代表着没有，但是它却不能直接使用，示例如下： 123456var errorCode :Int = 404errorCode = nil //报错//改：使用Int? 声明一个整型可选型var errorCode :Int? = 404errorCode = nil //将其声明为为可选型变量才能赋值为nil 二、可选型解包一个可选型数据，就意味着其值是可以为nil的，这样的数据不可以直接使用，所以将可选型解包后再使用是十分重要的操作。 12345//直接使用var errorCode: String? = &quot;404&quot;print(errorCode)//&quot;The errorCode is&quot; +errorCode //直接使用显式可选型会编译不通过，报错 1.解包方法1：普通的if判断，但不方便12345if(errorCode != nil)&#123; &quot;The errorCode is &quot; + errorCode!&#125;else&#123; &quot;No error&quot;&#125; 2.解包方法2：强制解包，使用感叹号“!”，存在错误风险一般情况下，我们在确定使用的可选型变量不会是nil，才通过!强制解包并使用 12var errorCode: String? = &quot;404&quot;&quot;The errorCode is &quot; + errorCode! 3.解包方法3：尝试解包，使用问号“？”，较为安全当不确定使用的可选型变量是否是nil,通过?执行调用方法等操作，意味着不为nil时才可以执行成功 12var errorCode: String? = &quot;404&quot;&quot;The errorCode is &quot; + errorCode？ 4.解包方法4：if-let解包, 当我们希望在可选型为nil时候，执行别的代码，此时更适合使用if-let方式解包1234567891011121314if let unwrappedErrorCode = errorCode&#123; //unwrappedErrorCode 是经过解包的数据，得到非nil值 &quot;The errorCode is&quot; + unwrappedErrorCode&#125;else&#123;&#125;------------优美的分割线----------------- //if-let解包方法的改进：可以使用原来的变量名if let errorCode = errorCode&#123; //errorCode 是经过解包的数据，得到非nil值 //括号内的errorCode 只在此括号内使用 &quot;The errorCode is&quot; + errorCode&#125;else&#123; //处理nil情况&#125; 5.解包时注意事项：隐式声明的可选型不需要解包，但是这样可能因为nil报错（详情请看第五部分） 123var blog:String! = &quot;helloWord&quot;//blog = nil &quot;My blog is&quot; + blog if-let可以同时解包多个变量，而且因为使用了if，也可以增加判断逻辑 123456if let errorCode = errorCode, errorMessage = errorMessage where errorCode == &quot;404&quot; &#123; print(&quot;Page not found&quot;)&#125; else &#123; print(&quot;No error&quot;)&#125; 三、可选链 Option chaining可选链的使用简化了可选型的使用。在某些情况下可以避免if-let 解包的使用，而是通过尝试解包（使用问号？）或者强制解包（感叹号!）来使用操作对象 示例： 12345var errorCodeStr: String? = &quot;Hello, playground&quot;//errorCodeStr.uppercaseString ; errorCodeStr是可选型不能直接使用，需要解包如下：if let errorCodeStr = errorCodeStr&#123; errorCodeStr.uppercaseString&#125; 上述代码使用可选链简化，如下： 1234//推荐写法:使用？尝试解包，如果成功就会将字符串大写errorCodeStr?.uppercaseString//不安全写法，当errorCode为nil时报错，除非我们确保errorCodeStr不为nil才能这样写errorCodeStr!.uppercaseString 基于这样的使用，可能会出现类似 Person?.address?.addressName 的使用，这就构成了可选链,调用链中任何一个节点为nil,整个调用都会失败，返回nil，使用？是安全的; 四、空合并运算符nil coalesce使用空合并运算符，可以解决解包之后的存值问题 示例1：123456var uppperCaseErrorStr = errorCodeStr?.uppercaseString//uppperCaseErrorStr此时是一个可选型变量，不需要显示声明，因为后面的表达式是可选型//实现解包同时实现了大写if let errorCodeStr = errorCodeStr?.uppercaseString&#123; errorCodeStr&#125; 示例2：1234567var errorMessage: String? = nillet message: Stringif let errorMessage = errorMessage&#123; message = errorMessage&#125;else&#123; message = &quot;no error&quot;&#125; 改进示例2：使用三目运算符1let message2 = errorMessage == nil ? &quot;no errror&quot; :errorMessage; 改进示例2:使用空合并运算符??，如果errorMessage有值，使用errorMessage!赋值 12//？？是空和并运算符let message3 = errorMessage ?? &quot;no error&quot; 五、隐式可选型 区别于显式可选型的创建：类型+？，创建隐式可选型使用：类型+！ 隐式可选型变量使用时，相当于其后面自带了一个感叹号，可以直接赋值给一个非可选型变量，但是隐式可选型依然保持可选型的特性，可以被赋值为nil，这就体现出来隐式可选类型的优点,即可用被赋值为nil，也可以不用每次显式的解包 隐式解析可选类型还可以在类中做属性，解决循环引用问题 示例： 1234var errorMessage: String! = nilerrorMessage = &quot;not found&quot;//这里errorMessage是隐式可选型，使用时候不需要显式的解包，但是如果errorMessage为nil就会报错&quot;The error is &quot; + errorMessage 六、可选型使用的其他示例示例1.123var error1:(errorCode: Int, errorMessage: String?) = (404 , &quot;page not found&quot;)error1.errorMessage = nil//error1 = nil 整个元组并非可选型，不能使用nil赋值 示例2.123456var ageInt: String = &quot;xyz&quot;//使用强制转换之后，age是可选型，需要按照可选型的规则去使用var age = Int(ageInt)if let age = age where age &lt; 20&#123; print(&quot;you are a tennager!&quot;)&#125; 示例3.1234var greeting = &quot;hello&quot;//rangeString 返回一个可选型，需要按照可选型的规则去使用greeting.rangeOfString(&quot;ll&quot;) //2..&lt;4greeting.rangeOf3String(&quot;oo&quot;)//nil 七、最后小结 有了可选型，你在声明隐式可选变量或特性的时候就不用指定初始值，因为它有缺省值nil。尤其是在一个创建一个类的属性的时候。 由于隐式解析可选的值会在使用时自动解析，所以没必要使用操作符!来解析它。但是有可能运行时报错。 使用可选链会选择性的执行隐式解析可选表达式上的某一个操作。如果值为nil，就不会执行任何操作，因此也不会产生运行错误。 非可选型的变量或者常量不可能赋值为nil，所以不能使用：notOptioalValue !&#x3D; nil,判断是否nil。这是可选型和非可选型数据的一个明显区别","categories":[{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wuyubeichen.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/tags/Swift/"}]},{"title":"Swift学习06-构造器(下)","slug":"Swift学习06-构造器(下)","date":"2017-08-06T10:15:09.000Z","updated":"2025-05-03T16:25:46.604Z","comments":true,"path":"2017/08/06/Swift学习06-构造器(下)/","permalink":"https://wuyubeichen.github.io/2017/08/06/Swift%E5%AD%A6%E4%B9%A006-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%8B)/","excerpt":"主要内容： 可失败的构造器 枚举类型可失败的构造器 构造失败的传递 重写一个可失败的构造器","text":"主要内容： 可失败的构造器 枚举类型可失败的构造器 构造失败的传递 重写一个可失败的构造器 可失败构造器init! 必要构造器 通过闭包或函数设置属性的默认值 一、可失败的构造器顾名思义，这是用于我们构造过程可能失败情况的构造器。失败的原因可能是给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。一个可失败构造器示例如下： 12345678910111213//可失败构造器语法是init关键字后面添加问号即(init?) struct Animal &#123; let name :String init?(name:String)&#123; if name.isEmpty &#123; //其实Swift构造器并不支持返回值，因为构造器本来就是要确保对象能被正确构造。 //所以这里使用return nil只是为了表明可失败构造器构造失败。 return nil &#125; //参数不为空，继续构造器得到可用的实例 self.name = name &#125; &#125; 注意： 可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同; 可失败构造器其实是在构造失败时创建一个类型为自身类型的可选类型的对象; 二、枚举类型可失败的构造器通过枚举类型可失败构造器获取枚举类型中特定的枚举成员，完成构造任务。如果提供的参数无法匹配任何枚举成员则构造失败。使用示例如下： 123456789101112131415enum TestNum&#123; case First, Second, Third init?(number : Character)&#123; switch number&#123; case &quot;1&quot;: self = .First case &quot;2&quot;: self = .Second case &quot;3&quot;: self = .Third default: return nil &#125; &#125;&#125; 不同于以上的写法，swift中还可以使用带原始值的枚举类型可失败构造器。带原始值的枚举类型会自带一个可失败构造器init?(rawValue:)，这里名为rawValue的参数，其类型和枚举类型的原始值类型一致， 如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。 123456789enum TestNum2:Character&#123; //枚举值自带原始值 case First = &quot;1&quot;, Second = &quot;2&quot;, Third = &quot;3&quot;&#125;let number = TestNum2(rawValue: &quot;6&quot;)if number == nil&#123; print(&quot;枚举类型构造失败&quot;)//此句被打印&#125; 三、构造失败的传递与普通的构造器相似，可失败构造器也是可以代理的。这里包括类、结构体、枚举中的横向代理，也包括子类和父类之间的向上代理。 无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。 可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中； 123456789101112131415161718192021class Product &#123; var name: String! init?(name: String) &#123; if name.isEmpty &#123; return nil &#125; self.name = name &#125;&#125;class CartItem: Product &#123; var quantity: Int! init?(name: String, quantity: Int) &#123; if (quantity &lt; 1) &#123; //验证quantity不符合要求，就立刻终止构造器，返回nil对象，剩余代码也不再执行 return nil; &#125; super.init(name: name) self.quantity = quantity &#125;&#125; 四、重写一个可失败的构造器既然是重写，这里主要是应用于类中。这里包括两种情况: 用子类的可失败构造器重写父类的可失败构造器（这种情况针对于可能子类增加了更多的可失败处理） 用子类的非可失败构造器重写一个父类的可失败构造器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//重写一个可失败的构造器一个示例如下：//父类Person:要求其name属性必须是非空字符串或者nilclass Person &#123; var name:String? //该构造器可创建name属性是nil的Person实例 init()&#123;&#125; //父类的可失败构造器，当传入参数为空的时候，不能创建有效实例 init?(name :String)&#123; self.name = name if name.isEmpty&#123; return nil &#125; &#125;&#125;//子类Student:class Student:Person &#123; override init()&#123; super.init() self.name = &quot;匿名&quot; &#125; //子类的非可失败构造器init(name:)重写了父类的可失败构造器init?(name:)。 //因为这里很好的处理了空字符串的情况，无论传入参数是否是空字符串，都将创建有效实例 //注意：可以用非可失败构造器重写可失败构造器，但反过来却不行。 override init(name: String) &#123; super.init() if name.isEmpty&#123; self.name = &quot;匿名&quot; &#125;else&#123; self.name = name &#125; &#125;&#125;//子类：Teacher://我们也可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器，具体使用如下:class Teacher:Person&#123; override init() &#123; super.init(name: &quot;匿名&quot;)! &#125; //这里子类的非可失败构造器重写父类的可失败构造器 //向上代理到父类的可失败构造器，并对父类的可失败构造器的返回值进行强制解包 override init(name: String) &#123; if name.isEmpty&#123; super.init(name: &quot;匿名&quot;)! &#125;else&#123; super.init(name: name)! &#125; &#125;&#125; 五、可失败构造器init!区别于init?方式的可失败构造器，init!形式的可失败构造器器将创建一个对应类型的隐式解包可选型对象 init?和init!可以相互代理，也可以相互重写。我们也可以用init代理到init!,但是一旦init!构造失败，将触发断言 六、必要构造器在类的构造器前添加required修饰符表明所有该类的子类都必须实现该构造器。 12345678910111213class SuperClass &#123; required init() &#123; // 构造器的实现代码 &#125;&#125;class SubClass: SuperClass &#123; //1.子类重写父类的必要构造器，构造器前也必须添加required修饰符，表明该构造器要求也应用于继承链后面的子类。 //2.但是这里虽然重写父类中必要的指定构造器时，却不需要添加override修饰符： required init() &#123; //构造器的实现代码 &#125;&#125; 七、通过闭包或函数设置属性的默认值在构造过程中，我们可以使用闭包或全局函数为某个存储型属性提供定制的默认值。 在新实例被创建时，对应的闭包或函数会被调用，其返回值会当做默认值赋值给这个属性, 具体的时候用如下： 12345678910111213141516struct Weather &#123; //常见的一些天气 let commonWeather: [String] = &#123; var weather = [&quot;sunny&quot;, &quot;cloud&quot;,&quot;rain&quot;,&quot;snow&quot;]; return weather &#125;() //打印 func printCommonWeather()&#123; for i in 0 ..&lt; commonWeather.count &#123; print(commonWeather[i]) &#125; &#125; &#125;let weather = Weather()//同时初始化了默认属性weather.printCommonWeather()","categories":[{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wuyubeichen.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/tags/Swift/"}]},{"title":"Swift学习05-构造器(中)","slug":"Swift学习05-构造器(中)","date":"2017-08-05T10:15:21.000Z","updated":"2025-05-03T16:12:27.318Z","comments":true,"path":"2017/08/05/Swift学习05-构造器(中)/","permalink":"https://wuyubeichen.github.io/2017/08/05/Swift%E5%AD%A6%E4%B9%A005-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%AD)/","excerpt":"主要内容： 构造器简介 指定构造器和便利构造器 类的构造器的使用","text":"主要内容： 构造器简介 指定构造器和便利构造器 类的构造器的使用 一、构造器简介本篇继续对Swift中的构造器进行介绍，这里主要说到类的继承和构造。 作为引用类型的类具有的继承特性，这使得类的构造过程较为复杂一些，因为涉及到很多细节性的问题。在使用之前，我们需要了解一些基本的问题： 类中所有存储属性，包括继承父类的属性，都要在构造过程中设置初值 Swift类的构造器分为指定构造器和便利构造器，确保完成构造过程 二、指定构造器和便利构造器指定构造器： 类的主要构造器，负责初始化类中所有属性，在继承关系中可调用父类链中的父类构造器; 每个类至少一个指定构造器。但是某些情况下，许多类是通过继承父类的指定构造器来满足这个条件; 便利构造器： 辅助类型的构造器，调用同一个类中的指定构造器完成类的初始化操作; 便利构造器需要在init关键字之前添加convenience关键字，使用空格分开; 12345678910111213141516171819202122class FatherClass &#123; var valueOne: Int //指定构造器 init(valueOne: Int)&#123; self.valueOne = valueOne &#125;&#125;class ChildClass: FatherClass &#123; var valueTwo:Int //子类的新引入属性 //指定构造器 init(valueOne: Int , valueTwo:Int)&#123; self.valueTwo = valueTwo //先初始化新引入属性，再初始化超类 super.init(valueOne: valueOne) &#125; //便利构造器 override convenience init(valueOne: Int)&#123; self.init(valueOne: valueOne); &#125;&#125; 三、类的构造器的使用关于类的构造器的使用在使用的时候，细节方面需要要注意很多，通过查找一些资料，现总结如下： 1. 指定构造器和便利构造器的基本使用原则： 当前类存在父类时，指定构造器器必须调用其直接父类的指定构造器，为保证继承的属性得以初始化; 便利构造器必须调用同一类中定义的其他构造器。而且最终会导致一个指定构造器被调用; 2. Swift两段式构造过程Swift 中类的构造过程包含两个阶段，被称为是二段式构造: 第一阶段：每个存储型的值指定一个初值; 第二阶段：给当前类一个机会，在新实例准备使用之前进一步修改定制存储型的属性; 与OC的区别：Swift与OC的构造过程相似，区别在于阶段一，OC给每个属性赋值为0或者空值，但是Swift更为灵活，允许开发者指定自己所需的初始值(默认值); 3. 两段式构造需要注意的事项 指定构造器必须保证当前类新引入所有属性初始化完成之后，才能将其构造器任务继续向上代理给父类的构造器。 指定构造器必须先向上代理调用父类构造器，然后再为其继承的属性设置新值，否则，指定构造器赋予的新值将被父类中的构造器所覆盖。 便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。否则，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。 构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self 作为一个值，因为此时还没构造有效实例。 4. 总结两段式构造的详细流程第一阶段： 某个指定构造器或便利构造器被调用。 完成新实例内存的分配，但此时内存还没有被初始化。 指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。 指定构造器将调用父类的构造器，完成父类属性的初始化。这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。 当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。 第二阶段： 从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等; 最终，任意构造器链中的便利构造器可以有机会定制实例和使用self; 四、构造器的继承与重写与OC不同，Swift中的子类默认情况不会自动继承父类的构造器，这是因为子类可能有更多新增属性，直接调用父类的构造器，可能会有一些属性无法初始化为出现错误; 如果我们希望子类拥有一个或多个与父类相同的构造器，那么这相当于子类重写了父类的构造器，需要在重写方法前添加override修饰符。（override的作用是提示编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确） 注意： 重写系统自带的默认构造器（虽然不是显式的），也要带上override修饰符; 重写父类指定构造器必须带上override，即使你的子类将父类的指定构造器重写成了便利构造器; 子类编写和父类便利构造器相匹配的子类构造器时，由于子类不能直接调用父类的便利构造器，并不能看做是对父类构造器的重写。所以子类中“重写”父类便利构造器时，不需要加override修饰符; 五、构造器的自动继承子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器还是是可以被自动继承的; 构造器的自动继承需要满足前提条件是：子类中引入的所有新属性都提供了默认值。 然后可分为两种情况： 情况1:子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。123456789101112131415class SuperClass &#123; var valueOne: Int //指定构造器 init(valueOne: Int)&#123; self.valueOne = valueOne &#125;&#125;class SubClass: SuperClass &#123; var valueTwo:Int = 100 //子类的新引入属性&#125;//自动继承了父类的构造器,这里被使用创建子类，子类新属性使用默认值let subClass = SubClass(valueOne: 10)print(&quot;subClass：(\\(subClass.valueOne)) valueTwo(\\(subClass.valueTwo))&quot;) 情况2：子类提供了所有父类指定构造器的实现(通过情况1继承过来的或者子类自定义实现)，此时子类将自动继承所有父类的便利构造器。123456789101112131415161718192021222324class Animal&#123; var name:String var age: Int init(name:String, age:Int)&#123; self.name = name self.age = age &#125; //父类的便利构造器 convenience init(name:String)&#123; self.init(name:name, age:10) &#125;&#125;class Person: Animal&#123; var nickName:String! //实现了父类中的指定构造器 override init(name:String, age:Int)&#123; super.init(name:name, age:age) self.name = name self.age = age + 2 &#125;&#125;let ps = Person(name: &quot;zs&quot;, age: 18) 自动继承注意： 即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。 对于情况 2，子类可以将父类的指定构造器实现为便利构造器。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wuyubeichen.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/tags/Swift/"}]},{"title":"Swift学习04-构造器(上)","slug":"Swift学习04-构造器(上)","date":"2017-08-04T10:15:31.000Z","updated":"2025-05-03T16:12:24.930Z","comments":true,"path":"2017/08/04/Swift学习04-构造器(上)/","permalink":"https://wuyubeichen.github.io/2017/08/04/Swift%E5%AD%A6%E4%B9%A004-%E6%9E%84%E9%80%A0%E5%99%A8(%E4%B8%8A)/","excerpt":"主要内容： 构造器简介 默认构造器 - 最简单的构造器 逐一成员构造器：类中不存在，适用于结构体 可选型属性在构造器中的使用 构造器代理","text":"主要内容： 构造器简介 默认构造器 - 最简单的构造器 逐一成员构造器：类中不存在，适用于结构体 可选型属性在构造器中的使用 构造器代理 一、构造器简介Swift赋予自定义类型更加丰富的功能，一个显著地方就是构造过程。Swift可以为自定义类型设置构造器来初始化一个实例。有关Swift构造器的使用特点可以总结如下： 构造器适用于类、结构体、枚举。是新的实例可用之前必须执行的一个过程 构造器具体的操作包括：必须保证所有存储型属性有合适初始值，执行其他必须的设置 构造器无需返回值，区别于OC 类的实例可以定义析构器，在实例释放之前执行特定的清除工作 存储型属性设置默认值和构造器中为其设置初始值，这种不会触发任何属性观察器 二、默认构造器 - 最简单的构造器默认构造器原理：返回一个所有属性都使用其原有默认值的一个实例 存在默认构造器的条件: 定义变量的时候，就可以保证所有属性都有可用的值。 没有自定义的构造器 12345678class Person&#123; var name: String? var age = 18 var gender = &quot;男&quot; //如果存在schoolName，那就必须添加一个构造器来确保没有默认值的schoolName也能赋值 //let schoolName:String&#125;let ps = Person() //使用了默认构造器 二、逐一成员构造器：类中不存在，适用于结构体结构体不会像类一样，对构造器给予限制，必须保证每个属性都可用，因为除了默认构造器，结构体还有逐一成员构造器，可以对每个属性进行设置; 123456struct Size&#123; var width = 0.0 var height:Int&#125;//let size = Size() //此时不满足默认构造器条件1，不能使用let size1 = Size(width: 10, height: 10) //使用逐一成员构造器 三、自定义构造器：输入参数的形式构造实例，满足多种情况的需要 常量只能被赋值一次，所有如果定义常量时有默认值，即使是构造函数也不能修改此值 对于类的实例，它的常量属性只能在定义它的类的构造函数中修改，不能在子类中修改 12345678class Student&#123; let type = &quot;学生&quot; let name :String init(name :String)&#123; //self.type = &quot;教师&quot; //不能修改已经有默认值的常量属性 self.name = name //构造函数必须保证所有值可用，此处赋值操作必须有 &#125;&#125; 四、可选型属性在构造器中的使用使用可选型是因为在业务逻辑上允许此属性为nil，包括两种情况如下： 初始化的时候无法为其赋值,只能默认nil； 在后续使用中需要将其赋值为nil； 12345678class Teacher&#123; var name:String var age:Int? init(name:String)&#123; self.name = name //以为age是可选型，存在默认值nil,所以构造函数不为其设置值也不报错 &#125;&#125; 五、构造器代理构造器通过调用其他构造器来完成实例的部分构造，被称为构造器代理,实现减少代码重复，构造器代理分为两种： 值类型构造器代理：适用于值类型（结构体&#x2F;枚举），没有继承等复杂过程，较为简单 类构造器代理：因为有涉及到继承，需要保证所有继承属性也能正确的初始化（也即是便利构造器，见下篇） 注意： 对于值类型，可以在自定义构造器中使用self.init来调用其他构造器 如果值类型定义了自定义构造器将不能使用默认构造器和逐一成员构造器。解决办法：将自定义构造器写在扩展里，而不是值类型的原始定义中 12345678910111213141516171819202122232425262728struct NewSize &#123; var width = 0.0 , height = 0.0&#125;struct Point &#123; var x = 0.0, y = 0.0&#125;struct Rect &#123; var origin = Point() var size = NewSize() //构造器1：与默认构造函数一样，全部使用默认值 init()&#123;&#125; //构造器2: 与逐一成员构造器一样 init(origin:Point, size:NewSize)&#123; self.origin = origin self.size = size &#125; //构造器3：调用了构造器2方法 //如果我们不去实现构造器2，将不能调用与其功能相似的逐一成员构造器 //所以我们可以参考扩展，将自定义方法写在扩展中，就不必这样麻烦了 init(center: Point, size: NewSize) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wuyubeichen.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/tags/Swift/"}]},{"title":"Swift学习03-闭包","slug":"Swift学习03-闭包","date":"2017-08-03T10:12:53.000Z","updated":"2025-05-03T16:12:21.645Z","comments":true,"path":"2017/08/03/Swift学习03-闭包/","permalink":"https://wuyubeichen.github.io/2017/08/03/Swift%E5%AD%A6%E4%B9%A003-%E9%97%AD%E5%8C%85/","excerpt":"闭包：是自包含的函数代码块，可以在代码中被传递和使用。Swift中的闭包与C和 Objective-C中的代码块(blocks)以及其他一些编程语言中的匿名函数比较相似；","text":"闭包：是自包含的函数代码块，可以在代码中被传递和使用。Swift中的闭包与C和 Objective-C中的代码块(blocks)以及其他一些编程语言中的匿名函数比较相似； 主要内容： 闭包表达式 闭包的使用与优化 值捕获 逃逸闭包 自动闭包 一、闭包表达式Swift闭包的三种存在形式： 全局函数是一个有名字但不会捕获任何值的闭包 嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包 闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包 闭包表达式的语法一般有如下的一般形式: 123&#123; (parameters) -&gt; returnType in statements&#125; 说明: 闭包的外层是一个大括号，先写的参数和返回值，然后操作部分之前使用in； 闭包就相当于OC中的block, 也可以看做是匿名函数； 闭包表达式参数可以是in-out参数，但不能设定默认值； 闭包的函数体部分由关键字in引入，该关键字表示闭包参数和返回值类型已经完成，闭包函数体开始； 二、闭包的使用与优化下面，我们使用Swift标准库中的sorted(by:)方法来测试闭包的使用。 sorted(by:)方法允许外部传入一个用于排序的闭包函数，将已知类型数组中的值进行排序，完成排序之后，该方法会返回一个与原数组大小相同，包含同类型元素已正确排序的新数组: 123456789101112131415//定义一个整型数组var someInts: [Int] = [5,9,7,0,1,3]//定义一个排序函数func biggerNumFirst(num1:Int, num2:Int) -&gt; Bool&#123; return num1 &gt; num2&#125;//普通用法：将biggerNumFirst函数传入sorted函数，实现排序var sortInts = someInts.sorted(by: biggerNumFirst)print(sortInts) //[9, 7, 5, 3, 1, 0]//闭包用法：为sorted函数参数传入一个闭包，实现排序sortInts = someInts.sorted(by:&#123; (a:Int, b:Int) -&gt; Bool in return a &gt; b&#125;)print(sortInts) //[9, 7, 5, 3, 1, 0] 注意：因为闭包不会在其他地方调用，所以不使用外部参数名 闭包使用起来十分灵活，我们可以在某些特定情况下对齐进行优化，下面是对上述闭包的优化： 2.1.根据上下文推断类型，省略参数类型与括号由于排序闭包函数是作为sorted(by:)方法的参数传入的，Swift可以推断其类型和返回值类型。所以sorted(by:)方法被一个Int类型的数组调用，其参数必定是(Int,Int)-&gt;Bool类型的函数。 最后，根据上下文推断类型，我们可以省略参数类型和参数周围的括号： 1234sortInts = someInts.sorted(by: &#123;a,b in return a &gt; b&#125;)print(sortInts) 2.2.对于不会发生歧义的闭包，可将其写成一行12sortInts = someInts.sorted(by:&#123;a,b in return a &gt; b&#125;)print(sortInts) 2.3.单行闭包表达式，省略return关键字省略return关键字的条件： sorted(by:)方法的参数类型明确了闭包必须返回一个Bool类型值； 单行闭包表达式中，其返回值类型没有歧义； 12sortInts = someInts.sorted(by: &#123;a,b in a &gt; b&#125;)print(sortInts) 2.4.使用参数名缩写(不推荐使用)Swift自动为内联闭包提供了参数名称缩写功能，你可以直接通过$0，$1，$2 来顺序调用闭包的参数，以此类推； 如果我们在闭包表达式中使用参数名称缩写， 我们就可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。in关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成： 12sortInts = someInts.sorted(by: &#123;$0&gt;$1&#125;)print(sortInts) 2.5.使用运算符简化闭包(不推荐使用)Swift的Int类型定义了关于大于号（&gt;）的字符串实现，其作为一个函数接受两个Int类型的参数并返回Bool类型的值。而这正好与sorted(by:)方法的参数需要的函数类型相符合。可以使用大于号来代替闭包 12sortInts = someInts.sorted(by: &gt;)print(sortInts) 2.6.尾随闭包，解决长闭包的书写问题定义：将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性； 写法：将闭包书写在函数括号之后，函数会支持将其作为最后一个参数调用，使用尾随闭包，不需要写出它的参数标签； 12345678910111213141516171819func someFunctionThatTakesAClosure(closure: () -&gt; Void) &#123; //函数体部分 closure(); //调用闭包&#125;//不使用尾随闭包进行函数调用someFunctionThatTakesAClosure(closure: &#123; //闭包主体部分&#125;)//使用尾随闭包进行函数调用someFunctionThatTakesAClosure() &#123; //闭包主体部分&#125;//注意：如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 () 省略掉：someFunctionThatTakesAClosure &#123; print(&quot;Hello World!&quot;) //打印：Hello World!&#125; 总结Swift闭包主要的四种优化方法： 利用上下文推断参数和返回值类型，省略参数类型与括号； 隐式返回单表达式闭包，即单表达式闭包可以省略return关键字； 参数名称缩写； 尾随闭包语法； 三、值捕获闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。Swift会为你管理在捕获过程中涉及到的所有内存操作； 12345678func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int &#123; var runningTotal = 0 func incrementer() -&gt; Int &#123; runningTotal += amount return runningTotal &#125; return incrementer&#125; 代码分析： makeIncrementer函数以amount为参数，以()-&gt;Int作为返回值类型，其函数体中还嵌套了另一个函数incrementer； 如果我们把incrementer单独拿出来，会发现其中runingTotal和amount变量都无法使用，因为这两个变量的引用是incrementer从外部捕获的； Swift会负责被捕获变量的所有内存管理工作，包括对捕获的一份值拷贝，也包括释放不再需要的变量； 现在再来测试makeIncrementer函数的使用: 12345678910let incrementByTen = makeIncrementer(forIncrement: 10)incrementByTen(); //10incrementByTen(); //20let incrementBySeven = makeIncrementer(forIncrement: 7)incrementBySeven() //7incrementBySeven(); //14let alsoIncrementByTen = incrementByTenalsoIncrementByTen() //30 代码分析: incrementByTen与incrementBySeven，是通过makeIncrementer函数传入不同的增量参数amount而创建的； 两个函数都有属于各自的引用，其中的runningTotal变量都是从makeIncrementer中捕获的，但是已经各自没有关系； 函数和闭包都是引用类型，将其赋值给变量或者常量，都只是操作的它们的引用，而不会改变闭包或者函数本身； 四、逃逸闭包当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。 逃逸闭包：在定义接受闭包作为参数的函数时，我们需要在参数名之前标注@escaping，以此表明这个闭包是允许”逃逸”出这个函数的。 1234567var completionHandlers: [() -&gt; Void] = []func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123; //代码1：执行闭包，不需要添加@escaping //completionHandler(); //代码2：函数外部对闭包进行了操作 completionHandlers.append(completionHandler) &#125; 代码分析： someFunctionWithEscapingClosure(_:) 函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果不将这个参数标记为@escaping，就会得到一个编译错误。 4.1.逃逸闭包的使用逃逸闭包和非逃逸闭包在使用上有所不同。将一个闭包标记为@escaping(即逃逸闭包)后，在调用这个闭包时就必须在闭包中显式地引用 self。一个示例如下： 12345678910111213141516171819//定义一个带有非逃逸闭包参数的函数func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123; closure()&#125;//定义一个可以使用闭包的类class SomeClass &#123; var x = 10 func doSomething() &#123; //调用逃逸闭包：必须在闭包中显式引用self someFunctionWithEscapingClosure &#123; self.x = 100 &#125; //调用非逃逸闭包：可以隐式引用self someFunctionWithNonescapingClosure &#123; x = 200 &#125; &#125;&#125;let instance = SomeClass()instance.doSomething()print(instance.x) //打印出 &quot;200” 五、自动闭包**自动闭包：**一种自动创建的闭包，用与包装传递给函数作为参数的表达式； 自动闭包不接受任何参数； 自动闭包被调用的时候，会返回被包装在其中的表达式的值； 自动闭包是用一个普通的表达式来代替显式的闭包，能够省略闭包的花括号； 其实，我们经常调用采用自动闭包的函数，但是却少去实现这样的函数，assert函数就是其中之一： 1assert(condition:, message:) assert函数中： condition参数可以接受自动闭包作为值，condition参数仅会在debug模式下被求值； 在condidtion被调用返回值为false时，message参数将被使用。 5.1.自动闭包的基本使用自动闭包能够实现延迟求值，直到调用这个闭包时，代码才会被执行。这对于有副作用或者高计算成本的代码来说是有益处的;下面的代码展示了自动闭包实现延时求值的具体做法： 12345678910var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]print(customersInLine.count) //打印出 “5&quot;//自动闭包不接受参数，只是一个表达式let customerProvider = &#123; customersInLine.remove(at: 0) &#125;print(customersInLine.count) //打印出 “5&quot;//调用自动闭包print(&quot;Now serving \\(customerProvider())!&quot;) // Prints &quot;Now serving Chris!&quot;print(customersInLine.count) //打印出 &quot;4” 代码分析：闭包实现了移除第一元素的功能，但是在闭包被调用之前，这个元素是不会被移除的。这就实现了延迟的作用 5.2.自动闭包在函数中的使用现在将闭包作为参数传递给一个函数，同样可以实现延时求值行为。下面的serve函数接受了一个闭包参数(具有删除第一个元素且返回这个元素的功能)； 1234567//customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]func serve(customer customerProvider: () -&gt; String) &#123; print(&quot;Now serving \\(customerProvider())!&quot;)&#125;//以闭包的形式传入参数serve(customer: &#123; customersInLine.remove(at: 0) &#125; ) //打印出&quot;Now serving Alex!” 现在使用自动闭包来实现上述函数功能，使用@autoclosure关键字，标明参数使用的是自动闭包，具体示例如下： 123456// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]func serve(customer customerProvider: @autoclosure () -&gt; String) &#123; print(&quot;Now serving \\(customerProvider())!&quot;)&#125;//由于标明了自动闭包，这里直接省略了闭包的花括号serve(customer: customersInLine.remove(at: 0)) //打印出&quot;Now serving Ewa!\\n&quot; 注意：过度使用 autoclosures 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。 5.3.可”逃逸”的自动闭包一个自动闭包可以“逃逸”，这时候应该同时使用@autoclosure 和 @escaping 属性，下面举例说明： 123456789101112131415// customersInLine is [&quot;Barry&quot;, &quot;Daniella&quot;]var customerProviders: [() -&gt; String] = []func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) &#123; customerProviders.append(customerProvider)&#125;//调用collectCustomerProviders，向数组中追加闭包collectCustomerProviders(customersInLine.remove(at: 0))collectCustomerProviders(customersInLine.remove(at: 0))print(&quot;Collected \\(customerProviders.count) closures.&quot;) //打印 &quot;Collected 2 closures.&quot;//循环数组中闭包，并且执行for customerProvider in customerProviders &#123; print(&quot;Now serving \\(customerProvider())!&quot;)&#125;// 打印 &quot;Now serving Barry!&quot;// 打印 &quot;Now serving Daniella!” 代码分析： 作为逃逸闭包：collectCustomerProviders函数中，闭包customerProvider被追加到customerProviders中，而这个数据是定义在函数作用域范围之外的，这意味数组内的闭包能够在函数返回之后被调用，所以customerProvider必须允许”逃逸”出函数作用域； 作为自动闭包：调用collectCustomerProviders函数时，传入的闭包是表达式的形式，自动闭包省略了闭包花括号；","categories":[{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wuyubeichen.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/tags/Swift/"}]},{"title":"Swift学习02-函数","slug":"Swift学习02-函数","date":"2017-08-02T10:14:31.000Z","updated":"2025-05-03T16:25:28.647Z","comments":true,"path":"2017/08/02/Swift学习02-函数/","permalink":"https://wuyubeichen.github.io/2017/08/02/Swift%E5%AD%A6%E4%B9%A002-%E5%87%BD%E6%95%B0/","excerpt":"函数：是一段完成特定任务的独立代码片段。你可以通过给函数命名来标识某个函数的功能，这个名字可以被用来在需要的时候”调用”这个函数来完成它的任务；","text":"函数：是一段完成特定任务的独立代码片段。你可以通过给函数命名来标识某个函数的功能，这个名字可以被用来在需要的时候”调用”这个函数来完成它的任务； 主要内容： 函数的定义与调用 函数参数与返回值 函数外部参数名和参数名称 默认参数 可变参数 输入输出参数 函数类型 函数类型 一、函数的定义与调用下面演示了在Swift中，定义函数和调用函数的基本操作： 12345678910111213//定义函数func greet(person: String) -&gt; String &#123; let greeting = &quot;Hello, &quot; + person + &quot;!&quot; return greeting&#125;//调用函数print(greet(person: &quot;Anna&quot;)) // 打印 &quot;Hello, Anna!”func greetAgain(person: String) -&gt; String &#123; return &quot;Hello again, &quot; + person + &quot;!&quot;&#125;print(greetAgain(person: &quot;Anna&quot;)) // 打印 &quot;Hello again, Anna!” 二、函数参数与返回值2.1.无参，有返回值函数1234func sayHi() -&gt; String &#123; return &quot;Hi！&quot;&#125;print(sayHi()) 2.2.多参，有返回值函数12345func sayHi(person: String, greet: String) -&gt; String &#123; let greetString = greet + person return greetString&#125;print(sayHi(person: &quot;zhoushuai&quot;, greet: &quot;Hi！&quot;)) 2.3.无返回值函数严格意义上，虽然没有返回值，但是sayHello函数依然返回了值。没有定义返回类型的函数会返回一个特殊的Void值。它其实是一个空的元组(tuple)，没有任何元素，可以写成() 123456789101112131415func sayHi(person: String) &#123; print(&quot;Hi-Hi, \\(person)!&quot;)&#125;sayHi(person: &quot;Tom”) //打印 &quot;Hi-Hi, Tom!”//sayHello函数与下面的两个函数，会被Swift识别为同一种函数，进而报错重复定义。/*func sayHi(person: String) -&gt;()&#123; print(&quot;Hello, \\(person)!&quot;)&#125;func sayHi(person: String) -&gt;Void &#123; print(&quot;Hello, \\(person)!&quot;)&#125;*/ 2.4.多重返回值函数可以用元组（tuple）类型让多个值作为一个复合值从函数中返回,即返回多个参数 12345678func findMaxMin(array:[Int]) -&gt;(max:Int,min:Int)&#123; let max = array.max() let min = array.min() return (max!,min!)&#125;let bounds = findMaxMin(array: [8, -6, 2, 109, 3, 71])print(&quot;min is \\(bounds.min) and max is \\(bounds.max)&quot;)//打印 &quot;min is -6 and max is 109 2.5.可选返回值类型1234567891011121314151617func findMaxMin2(array:[Int]) -&gt;(max:Int,min:Int)?&#123; guard !array.isEmpty else&#123; return nil &#125; var maxVlaue = array[0] var minValue = array[0] for number in array&#123; maxVlaue = maxVlaue &gt; number ? maxVlaue : number minValue = minValue &lt; number ? minValue : number &#125; //返回的类型是可选型，因为结果有可能是nil return (maxVlaue, minValue)&#125;if let bounds2 = findMaxMin2(array: [1, 2, 3, 4, 5, 6])&#123; print(&quot;min is \\(bounds2.min) and max is \\(bounds2.max)&quot;)&#125; 注意：可选元组类型如 (Int, Int)? 与元组包含可选类型如 (Int?, Int?) 是不同的.可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。 2.6.无参，无返回值函数1234func sayHiHi()&#123; print(&quot;sayHiHi:无参五返回值的函数！&quot;)&#125;sayHiHi() 三、函数外部参数名和参数名称每个函数参数都有一个外部参数名(参数标签)以及参数名称，只不过默认情况下，函数参数直接使用参数名来作为它们的外部参数名。下面来总结函数外部参数名的各种用法。 3.1.指定外部参数名，让函数表意更明确函数外部参数名的使用能够让一个函数在调用时更有表达力，更类似自然语言，并且仍保持了函数内部的可读性以及清晰的意图。 1234567891011121314//正常写法：func sayHelloTo(name: String , greeting: String) -&gt; String&#123; return &quot;\\(greeting), \\(name)!&quot;&#125;print(sayHelloTo(name: &quot;风恣&quot;, greeting: &quot;Hello”)) //打印：&quot;Hello，风恣！&quot;//改进上面的函数，为第二个参数指定外部参数名，让表意更加明确func sayHelloTo(name: String, withGreetingWord greeting:String) -&gt; String&#123; return &quot;\\(greeting),\\(name)&quot;&#125;print(sayHelloTo(name: &quot;FengZi&quot;, withGreetingWord: &quot;Hello&quot;))//打印：&quot;Hello，FengZi&quot; 特别说明： 一般情况下，第一个参数不设置外部参数名，因为第一个参数的外部参数名是隐藏在函数名中的。 3.2.忽略参数标签有时候，使用外部参数名反而会使函数更加繁琐，这又需要隐藏外部参数名：这时候使用下划线**”_“**来代替一个明确的参数标签。 1234567891011121314151617//正常写法：func mutipleOf(num1: Int, and num2:Int)-&gt; Int&#123; return num1 * num2&#125;mutipleOf(num1: 1, and: 6) //6//改进1：忽略参数标签func mutipleOf(num1:Int , num2:Int) -&gt; Int&#123; return num1 * num2;&#125;mutipleOf(num1: 1, num2: 6) //6//改进2:彻底不使用参数名,使用下划线省略func mutiply(_ num1:Int, _ num2:Int) -&gt; Int&#123; return num1 * num2&#125;mutiply(1, 6) //6 四、默认参数定义函数的时候，可以给某些参数设置默认值(Deafult Value)，当默认值被定义后，调用这个函数时可以忽略这个参数。 下面的函数包括两个默认参数，而且设置的默认参数都要在非默认参数后面。 1234567891011121314151617func playMusic(name: String, instrument:String = &quot;drum&quot;, sound:String = &quot;咚咚咚。。。&quot;) -&gt; String&#123; let scene = name + &quot; play the &quot; + instrument + &quot;,&quot; + sound; print(scene) return scene;&#125;//使用了默认参数的参数, 相关的默认参数可以不用传值playMusic(name: &quot;zhoushuai”)//对于默认参数，可以有选择的传入值playMusic(name: &quot;zhoushuai&quot;, instrument: &quot;panio&quot;)playMusic(name: &quot;zhoushuai&quot;, instrument: &quot;panio&quot; ,sound: &quot;lingling~&quot;)//测试打印：//zhoushuai play the drum,咚咚咚。。。//zhoushuai play the panio,咚咚咚。。。//zhoushuai play the panio,lingling~ 五、可变参数一个可变参数可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数传入不确定数量的输入值。通过在变量类型名后面加入（…）的方式来定义可变参数。下面的算术平均函数演示了可变参数的用法： 12345678910func arithmeticMean(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;arithmeticMean(1, 2, 3, 4, 5) //返回3.0, 是这5个数的平均数。arithmeticMean(3, 8.25, 18.75) //返回10.0, 是这3个数的平均数。 注意：一个函数只能拥有一个可变参数 六、输入输出参数函数参数默认是常量形参，所以我们在函数中对其修改都不会对参数的原值产生影响。为了解决这个问题，我们可以将这些需要修改的参数定义为输入输出参数。 1234567891011121314var somInt = 10;//普通函数:报错，因为num是常量，不能被再次修改/*func modifyNum(num:Int)&#123; num = num * 2;&#125;*///带有输入输出函数的函数func modifyNum2(num:inout Int)&#123; num = num * 2&#125;modifyNum2(num: &amp;somInt)print(somInt) //20，someIn被修改 注意： 1.只能传递变量给输入输出参数，而不能是常量或者字面量，因为这些量是不能被修改的； 2.传入参数作为输入输出参数时，需要在参数名前添加&amp;符号，表示这个值可以被修改； 七、函数类型如同参数有整型，布尔型等参数类型一样，每个函数都有种特定的函数类型。函数的类型由函数的参数类型和返回值类型组成。下面举例说明： 1.以下两个函数具有相同的函数类型：（Int,Int）-&gt;Int1234567func addTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a + b&#125;func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a * b&#125; 2.没有参数也没有返回值的函数类型：()-&gt;Void123func printHelloWorld() &#123; print(&quot;hello, world&quot;)&#125; 3.使用函数类型3.1定义一个函数类型的变量或常量，然后可以使用适当函数为其赋值下面的mathFunction变量，经过赋值之后，指向了addTwoInts函数，所以它也可以当做addTwoInts函数使用 12345678var mathFunction:(Int,Int)-&gt;Int = addTwoInts//赋值了加法函数：addTwoIntsprint(mathFunction(3,4)) //7//赋值了乘法函数：multiplyTwoIntsmathFunction = multiplyTwoInts;print(mathFunction(3,4)) //12 3.2函数类型做为参数类型函数类型也可以作为另一个函数的参数类型，这样我们就可以将函数的一部分实现留给函数的调用者来提供。 123456789101112131415161718192021222324252627282930313233343536373839404142//测试1：func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123; print(&quot;Result: \\(mathFunction(a, b))&quot;)&#125;printMathResult(addTwoInts, 3, 5) //打印 &quot;Result: 8”printMathResult(multiplyTwoInts, 3, 5) //打印：&quot;Result: 15&quot;//测试2：//生成随机数组成的数组var array: [Int] = []for _ in 0..&lt;6&#123; let max=20 let randNum0=arc4random()%UInt32(max) let randNum1=Int(randNum0) if(array.contains(randNum1))&#123; continue; &#125; array.append(randNum1)&#125;print(array) //[12, 9, 19, 13, 3]//自定义排序方法1：从大到小排序func biggerNumFirst(num1:Int, num2:Int) -&gt; Bool&#123; return num1 &gt; num2&#125;//自定义排序方法2：将数字转化为字符串， 按照字符换的字典排序func compareByNumberString(num1: Int, num2: Int) -&gt;Bool&#123; return String(num1) &gt; String(num2)&#125;//自定义排序方法3：距离某个数字最近func nearTo10(num1: Int, num2: Int) -&gt;Bool&#123; return abs(num1 - 10) &lt; abs(num2 - 10) ? true :false&#125;array.sort(by: biggerNumFirst(num1:num2:))array.sort(by: compareByNumberString)array.sort(by: nearTo10)//测试打印://[19, 13, 12, 9, 3]//[9, 3, 19, 13, 12]//[9, 12, 13, 3, 19] 3.3.函数类型作为返回值类型你可以用函数类型作为另一个函数的返回类型。你需要做的是在返回箭头（-&gt;）后写一个完整的函数类型。 12345678910111213func getMathFunction(symbol: String)-&gt;(Int,Int)-&gt;Int&#123; if symbol == &quot;*&quot; &#123; return multiplyTwoInts; &#125;else&#123; return addTwoInts &#125;&#125;//传入不同的字符串参数，会返回不同的函数var function = getMathFunction(symbol: &quot;*&quot;)function(1,2) //2function = getMathFunction(symbol: &quot;abcdefg&quot;)function(1,2) //3 八、嵌套函数通常，我们见到的都是全局函数，即定义在全局域中的函数。我们也可以把函数定义在别的函数体中，称作嵌套函数。 1234567891011121314151617181920func getMathFunction2(symbol: String)-&gt;(Int,Int)-&gt;Int&#123; func mathFunc1(a:Int,b:Int)-&gt;Int&#123; return a - b &#125; func mathFunc2(a: Int, b: Int) -&gt; Int&#123; return a * b &#125; if symbol == &quot;*&quot; &#123; return mathFunc2; &#125;else&#123; return mathFunc1; &#125;&#125;var method = getMathFunction2(symbol: &quot;*&quot;)method(5,6) //30method = getMathFunction2(symbol: &quot;123123&quot;)method(5,6) //-1","categories":[{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wuyubeichen.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/tags/Swift/"}]},{"title":"Swift学习01-属性","slug":"Swift学习01-属性","date":"2017-08-01T10:14:43.000Z","updated":"2025-05-03T16:12:14.614Z","comments":true,"path":"2017/08/01/Swift学习01-属性/","permalink":"https://wuyubeichen.github.io/2017/08/01/Swift%E5%AD%A6%E4%B9%A001-%E5%B1%9E%E6%80%A7/","excerpt":"属性：是与特定的Swift类、结构体、枚举相关联的值；与其他语言相比，属性不再是被类所特有； 主要内容： 存储属性与计算属性 属性观察器 类型属性 全局变量与局部变量","text":"属性：是与特定的Swift类、结构体、枚举相关联的值；与其他语言相比，属性不再是被类所特有； 主要内容： 存储属性与计算属性 属性观察器 类型属性 全局变量与局部变量 一、存储属性与计算属性从属性被定义的方式上看，Swift属性有存储属性和计算属性两种： 存储属性：存储在特定类或结构体实例里的一个常量(let)或变量(var)，作为实例的一部分； 计算属性：计算属性不直接存储值，而是提供一个getter和一个可选的setter，来间接设置其他属性或变量值； 下面通过一段代码演示这两种属性的区别： 1234567891011121314struct Square&#123; //存储属性 var width:Double //计算属性：通过一定计算方法得到的属性 var area:Double&#123; get&#123; return width * width &#125; &#125;&#125;let square = Square(width: 10.0)print(&quot;正方形边长：\\(square.width)&quot;) //正方形边长：10.0print(&quot;正方形面积：\\(square.area)&quot;) //正方形面积：100.0 总结存储属性和计算属性的用法还有如下几种情况： 1.1.常量结构体的存储属性如果创建一个结构体的实例并且将其赋值给一个常量，则无法再修改该实例的任何属性(包括其中的变量属性)。这是因为结构体是值类型，值类型实例被声明为常量，其所有属性都成了常量；在这点上，类与结构体不同，这种情况下，类中的可变属性可以被修改。 123456let square1 = Square(width: 10.0)//square1.width = 11.0 //报错var square2 = Square(width:20.0)square2.width = 21.0 //可以修改//注：如果Squre是一个类，那么以上两种情况都可以通过 1.2.延迟存储属性 定义：第一次被调用的时候才会计算其初始值的属性。在属性声明前使用lazy来表示一个延迟存储属性； 作用：当属性的值依赖于在实例的构造过程结束后才会知道影响值的外部因素时，或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它； 123456789101112131415161718192021222324252627282930313233class Number&#123; //存储属性 var startNum: Int! var endNum:Int! //计算属性 var length :Int&#123; return endNum - startNum + 1 &#125; //延迟属性：使用闭包计算出了延迟属性的值，此过程只执行一次 lazy var sum: Int = &#123; print(&quot;计算延迟属性。。。。&quot;) var tempNum = 0; for i in self.startNum...self.endNum&#123; tempNum += i; &#125; return tempNum &#125;() //可失败的构造方法 init?(startNum: Int , endNum:Int)&#123; if(startNum &gt; endNum)&#123; return nil &#125; self.startNum = startNum self.endNum = endNum &#125;&#125;let number = Number(startNum: 1, endNum: 100)number?.length //100number?.sum //5050number?.sum //5050 注意： 必须将延迟存储属性声明成变量(使用var关键字)，因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性； 如果一个被标记为 lazy 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次； 1.3.计算属性的使用计算属性不直接存储值，而是提供一个getter和一个可选的setter，来间接设置其他属性或变量值；总结它的使用特点如下： 只有getter没有setter的计算属性就是只读计算属性。只读属性通过点运算符访问，只能返回值而不可设置新值； 计算属性与其他属性相关，是变化的，所以必须使用var关键字进行修饰，包括只读计算属性； 只读计算属性可以去掉get关键字和花括号； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct Point &#123; var x = 0.0 var y = 0.0&#125;struct Size &#123; var width = 0.0 var height = 0.0&#125;class Rectangle&#123; //存储型数据 var originPoint = Point() var size = Size() //计算型属性 var center:Point&#123; //get方法：获取计算属性值 get&#123; let center_x = originPoint.x + size.width/2 let center_y = originPoint.y + size.height/2 return Point(x: center_x, y: center_y) &#125; //如果没有set方法，是只读， /* set(newCenter)&#123; originPoint.x = newCenter.x - size.width/2 originPoint.y = newCenter.y - size.height/2 &#125; */ //set方法：设置计算属性新值 //这里也可以省略括号和newCenter.使用newValue set&#123; originPoint.x = newValue.x - size.width/2 originPoint.y = newValue.y - size.height/2 &#125; &#125; //计算属性：area属性只有get,可以不显式的声明出get；此属性为只读属性 var area:Double&#123; return size.width * size.height &#125; init(origin: Point, size: Size)&#123; self.originPoint = origin self.size = size &#125;&#125;//创建一个长方形var rect = Rectangle(origin: Point(x: 0, y: 0), size: Size(width: 100, height: 100))rect.centerrect.area //10000 二、属性观察器属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外； 属性观察器可以为延迟属性外的其他存储属性添加属性观察，也可以通过继承的方式重写父类属性，为其添加属性观察期。但是我们没有必要为非重写的计算属性添加属性观察器，因为它本身就可以通过自己的setter直接监控和响应值的变化； 添加属性观察器方式如下： willSet方法：在新的值被设置之前调用，拥有一个默认参数newValue(代表新的属性值)； didSet方法：在新的值被设置之后立刻调用,拥有一个默认参数oldValue(代表就的属性值)； 下面通过lightBlub演示用法，其中为currentDianYa属性添加了观察器： 1234567891011121314151617181920212223242526272829303132333435class lightBlub &#123; //最大电压和当前电压 static let maxDianYa = 30 //属性监听 //注意：willSet和didSet括号中的值可以省略，直接使用系统自带的newVlaue和oldValue var currentDianYa = 0 &#123; //可以使用系统默认的属性newValue和oldValue willSet(newCurrentDianya)&#123; print(&quot;当前电压值将要改变: \\(currentDianYa) -&gt; \\(newCurrentDianya)&quot;) &#125; //当调用此方法时，已经设置了值的时候, didSet(oldCurentDianYa)&#123; if(currentDianYa == lightBlub.maxDianYa)&#123; print(&quot;请注意 ,当前电压达到了最大电压值&quot;) &#125;else if(self.currentDianYa &gt; lightBlub.maxDianYa)&#123; print(&quot;当前电压过高，不能设置新的电压值&quot;) currentDianYa = oldCurentDianYa &#125; &#125; &#125;&#125;let light = lightBlub()light.currentDianYa = 10light.currentDianYa = 30light.currentDianYa = 40/* 打印结果： 当前电压值将要改变: 0 -&gt; 10 当前电压值将要改变: 10 -&gt; 30 请注意 ,当前电压达到了最大电压值 当前电压值将要改变: 30 -&gt; 40 当前电压过高，不能设置新的电压值*/ 注意：willSet和didSet并不会在初始化时被调用 三、类型属性实例属性属于一个特定类型的实例，因此实例之间的属性相互独立。但其实，也可以为类型本身定义属性，这样无论创建了多少个该类型实例，这些属性只有唯一的一份，这种属性就是类型属性。 Swift的类型属性就相当于OC或者C中的类变量，但他们有着以下的不同： 在OC或者C中，与某个类型相关的静态常量和静态变量，是作为全局静态变量来定义的。但是Swift中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内； Swift类型属性使用关键字static,下面是一个具体示例： 123456789101112131415161718192021222324252627282930313233343536373839404142//测试Int的类型属性Int.min Int.maxclass Player &#123; var name: String = &quot;&quot; //对象属性：本人的得分 var score: Int = 0 //类型属性：本游戏的最高得分,使用类名来访问，使用关键字static声明 static var heighestScore:Int = 0; //构造方法 init(name: String)&#123; self.name = name &#125; //玩一句游戏得分 func playGame()&#123; let tempNum = Int(arc4random()%100)+1 self.score += tempNum print(&quot;\\(name) 的游戏得分是：\\(score)&quot;) if(self.score &gt; Player.heighestScore)&#123; Player.heighestScore = self.score &#125; print(&quot;当前本游戏的最高分是:\\(Player.heighestScore)&quot;) &#125;&#125;let player1 = Player(name: &quot;zs&quot;)player1.playGame()player1.playGame()let player2 = Player(name: &quot;cf&quot;)player2.playGame()/* 打印结果 zs 的游戏得分是：11 当前本游戏的最高分是:11 zs 的游戏得分是：87 当前本游戏的最高分是:87 cf 的游戏得分是：88 当前本游戏的最高分是:88*/ 四、全局变量与局部变量 全局变量：在函数、方法、闭包或者任意类型之外定义的变量； 局部变量：在函数、方法或者闭包内部定义的变量； 全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于：全局的常量或变量不需要标记lazy修饰符。 局部范围的常量或变量从不延迟计算。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wuyubeichen.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/tags/Swift/"}]}],"categories":[{"name":"iOS高级","slug":"iOS高级","permalink":"https://wuyubeichen.github.io/categories/iOS%E9%AB%98%E7%BA%A7/"},{"name":"iOS底层","slug":"iOS底层","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BA%95%E5%B1%82/"},{"name":"iOS开发","slug":"iOS开发","permalink":"https://wuyubeichen.github.io/categories/iOS%E5%BC%80%E5%8F%91/"},{"name":"网络原理","slug":"网络原理","permalink":"https://wuyubeichen.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"},{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/categories/Python/"},{"name":"个人博客","slug":"个人博客","permalink":"https://wuyubeichen.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/categories/Swift/"}],"tags":[{"name":"静态库","slug":"静态库","permalink":"https://wuyubeichen.github.io/tags/%E9%9D%99%E6%80%81%E5%BA%93/"},{"name":"动态库","slug":"动态库","permalink":"https://wuyubeichen.github.io/tags/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"name":"Mach-O","slug":"Mach-O","permalink":"https://wuyubeichen.github.io/tags/Mach-O/"},{"name":"编译原理","slug":"编译原理","permalink":"https://wuyubeichen.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"Xcode","slug":"Xcode","permalink":"https://wuyubeichen.github.io/tags/Xcode/"},{"name":"环境配置","slug":"环境配置","permalink":"https://wuyubeichen.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"内存管理","slug":"内存管理","permalink":"https://wuyubeichen.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"Runtime","slug":"Runtime","permalink":"https://wuyubeichen.github.io/tags/Runtime/"},{"name":"Block","slug":"Block","permalink":"https://wuyubeichen.github.io/tags/Block/"},{"name":"响应式编程","slug":"响应式编程","permalink":"https://wuyubeichen.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"UI问题","slug":"UI问题","permalink":"https://wuyubeichen.github.io/tags/UI%E9%97%AE%E9%A2%98/"},{"name":"CPU架构","slug":"CPU架构","permalink":"https://wuyubeichen.github.io/tags/CPU%E6%9E%B6%E6%9E%84/"},{"name":"抓包","slug":"抓包","permalink":"https://wuyubeichen.github.io/tags/%E6%8A%93%E5%8C%85/"},{"name":"Python","slug":"Python","permalink":"https://wuyubeichen.github.io/tags/Python/"},{"name":"Hexo","slug":"Hexo","permalink":"https://wuyubeichen.github.io/tags/Hexo/"},{"name":"iOS","slug":"iOS","permalink":"https://wuyubeichen.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://wuyubeichen.github.io/tags/Swift/"}]}